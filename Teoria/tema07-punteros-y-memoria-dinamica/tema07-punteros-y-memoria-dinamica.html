



<!doctype html>
<html lang="es" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copiar al portapapeles">
      
        <meta name="lang:clipboard.copied" content="Copiado al portapapeles">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No se encontraron documentos">
      
        <meta name="lang:search.result.one" content="1 documento encontrado">
      
        <meta name="lang:search.result.other" content="# documentos encontrados">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.4.0">
    
    
      
        <title>Tema 7: Punteros y memoria dinámica - P1 Robótica</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.0284f74d.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.01803549.css">
      
      
        
        
        <meta name="theme-color" content="#009688">
      
    
    
      <script src="../../assets/javascripts/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="teal" data-md-color-accent="teal">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#tema-7-punteros-y-memoria-dinamica" tabindex="1" class="md-skip">
        Saltar a contenido
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="P1 Robótica" class="md-header-nav__button md-logo">
          
            <img src="../../imagenes/logo.png" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              P1 Robótica
            </span>
            <span class="md-header-nav__topic">
              
                Tema 7: Punteros y memoria dinámica
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Búsqueda" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Teclee para comenzar búsqueda
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="P1 Robótica" class="md-nav__button md-logo">
      
        <img src="../../imagenes/logo.png" width="48" height="48">
      
    </a>
    P1 Robótica
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1">
    
    <label class="md-nav__link" for="nav-1">
      Teoría
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-1">
        Teoría
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../tema00-descripcion-asignatura/tema00-descripcion-asignatura.html" title="Tema 0: Descripción de la asignatura" class="md-nav__link">
      Tema 0: Descripción de la asignatura
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html" title="Tema 1: Introducción a la programación" class="md-nav__link">
      Tema 1: Introducción a la programación
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html" title="Tema 2: Tipos de datos simples" class="md-nav__link">
      Tema 2: Tipos de datos simples
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema03-sentencias-de-control/tema03-sentencias-de-control.html" title="Tema 3: Sentencias de control" class="md-nav__link">
      Tema 3: Sentencias de control
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Prácticas
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Prácticas
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../Practicas/practica00/practica00.html" title="Práctica 0: Entorno Linux y herramientas" class="md-nav__link">
      Práctica 0: Entorno Linux y herramientas
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Practicas/practica01/practica01.html" title="Práctica 1: Tipos de datos simples" class="md-nav__link">
      Práctica 1: Tipos de datos simples
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Practicas/practica02/practica02.html" title="Práctica 2: Sentencias de selección" class="md-nav__link">
      Práctica 2: Sentencias de selección
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Tabla de contenidos</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-punteros" title="1. Punteros" class="md-nav__link">
    1. Punteros
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11-operadores-para-el-manejo-de-punteros" title="1.1 Operadores para el manejo de punteros" class="md-nav__link">
    1.1 Operadores para el manejo de punteros
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12-punteros-y-arrays" title="1.2 Punteros y arrays" class="md-nav__link">
    1.2 Punteros y arrays
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13-punteros-a-estructuras" title="1.3 Punteros a estructuras" class="md-nav__link">
    1.3 Punteros a estructuras
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-gestion-de-memoria-dinamica" title="2. Gestión de memoria dinámica" class="md-nav__link">
    2. Gestión de memoria dinámica
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-memoria-dinamica" title="2.1 Memoria dinámica" class="md-nav__link">
    2.1 Memoria dinámica
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22-funciones-para-gestionar-la-memoria-dinamica" title="2.2 Funciones para gestionar la memoria dinámica" class="md-nav__link">
    2.2 Funciones para gestionar la memoria dinámica
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23-arrays-dinamicos-multidimensionales" title="2.3 Arrays dinámicos multidimensionales" class="md-nav__link">
    2.3 Arrays dinámicos multidimensionales
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-punteros-y-funciones" title="3. Punteros y funciones" class="md-nav__link">
    3. Punteros y funciones
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#arrays-y-matrices-como-parametro" title="Arrays y matrices como parámetro" class="md-nav__link">
    Arrays y matrices como parámetro
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#paso-de-parametros-por-referencia" title="Paso de parámetros por referencia" class="md-nav__link">
    Paso de parámetros por referencia
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#devolucion-de-punteros" title="Devolución de punteros" class="md-nav__link">
    Devolución de punteros
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-array-estatico-de-punteros" title="4. Array estático de punteros" class="md-nav__link">
    4. Array estático de punteros
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-array-dinamico-de-registros" title="5. Array dinámico de registros" class="md-nav__link">
    5. Array dinámico de registros
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ejercicios-resueltos" title="Ejercicios resueltos" class="md-nav__link">
    Ejercicios resueltos
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ejercicio-1-array-dinamico-de-registros" title="Ejercicio 1: Array dinámico de registros" class="md-nav__link">
    Ejercicio 1: Array dinámico de registros
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ejercicio-2-tabla-3d-definida-con-typedef" title="Ejercicio 2: Tabla 3D definida con typedef" class="md-nav__link">
    Ejercicio 2: Tabla 3D definida con typedef
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bibliografia" title="Bibliografía" class="md-nav__link">
    Bibliografía
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="tema-7-punteros-y-memoria-dinamica">Tema 7: Punteros y memoria dinámica<a class="headerlink" href="#tema-7-punteros-y-memoria-dinamica" title="Permanent link">&para;</a></h1>
<h2 id="1-punteros">1. Punteros<a class="headerlink" href="#1-punteros" title="Permanent link">&para;</a></h2>
<p>Ya hemos visto que la <strong>memoria</strong> del ordenador es el lugar donde se almacenan los datos y las instrucciones de un programa. Se llama memoria RAM, que es diferente a la memoria de almacenamiento como discos duros, etc. Está compuesta por un gran número de <strong>celdas</strong> (bytes) de información. A cada una de estas celdas se le asigna una <strong>dirección de memoria</strong>, que permite distinguir unas celdas de otras. De forma que, dada la dirección de memoria de una celda, se podrá obtener su valor actual y modificarlo, como ya hemos visto por ejemplo en el paso de parámetros por referencia.</p>
<p>Cuando se accede a una variable almacenada en memoria el compilador necesita saber:</p>
<ul>
<li>número de bytes que componen la variable</li>
<li>dirección de memoria del byte inicial de la variable</li>
</ul>
<p>Estos términos ya los hemos utilizado al definir una variable:</p>
<ul>
<li>la dirección de memoria se representa con el nombre de la variable (el compilador se encarga de sustituir el nombre por su dirección de memoria)</li>
<li>El tamaño se define con el tipo de datos de la variable (<code>int</code>, <code>char</code>...). El compilador se encarga de reservar los bytes necesarios.</li>
</ul>
<p>Los <strong>punteros</strong> son un nuevo tipo de datos. La diferencia con el resto es que los que hemos visto hasta ahora almacenan datos y los punteros almacenan <strong>direcciones de memoria</strong>. Es decir, hacen referencia a otra zona de memoria donde se encuentran los datos. Se dice que un puntero <em>apunta</em> a un dato.</p>
<p>Características:</p>
<ul>
<li>Un <strong>puntero</strong> es una variable que almacena una dirección de memoria.</li>
<li>Una variable contiene siempre un valor (de un tipo).</li>
<li>Un puntero contiene la dirección de una variable que contiene un valor.</li>
<li>El valor de un puntero es una dirección de memoria.</li>
<li>Un puntero puede apuntar a una variable de cualquier tipo: tipos básicos, tipos definidos por el usuario, estructuras de datos, o incluso a funciones.</li>
<li>Los punteros se pueden utilizar para referenciar y manipular estructuras de datos, y para referenciar bloques de memoria asignados dinámicamente.</li>
</ul>
<p>Sintaxis:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>tipo *nombre_variable;
</pre></div>
</td></tr></table>

<ul>
<li>La variable declarada es un puntero al tipo de dato
especificado: <code>nombre_variable</code> almacenará la dirección de memoria en la cual se almacenará un dato de ese tipo.</li>
<li>Con esa declaración <strong>se reserva memoria SÓLO para el puntero, NUNCA para la variable a la que apunta</strong>.</li>
</ul>
<p>Ejemplos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="o">*</span><span class="n">entero</span><span class="p">;</span> <span class="cm">/* entero es un puntero a int */</span>
<span class="kt">float</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>   <span class="cm">/* res es un puntero a float */</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">mensaje</span><span class="p">;</span> <span class="cm">/* mensaje es un puntero a char */</span>
</pre></div>
</td></tr></table>

<h3 id="11-operadores-para-el-manejo-de-punteros">1.1 Operadores para el manejo de punteros<a class="headerlink" href="#11-operadores-para-el-manejo-de-punteros" title="Permanent link">&para;</a></h3>
<p>Existen dos operadores unarios para trabajar con punteros: <code>*</code> y <code>&amp;</code></p>
<ul>
<li><code>*puntero</code>: operador indirección. Devuelve el contenido de la dirección de memoria apuntado por <code>puntero</code></li>
<li><code>&amp;variable</code>: operador dirección: Devuelve la dirección de memoria de una    <code>variable</code></li>
</ul>
<p>Ejemplo 1:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//Declaración de variable entera de tipo entero</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="c1">//Declaración de variable puntero de tipo entero</span>
    <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span> <span class="c1">//Asignación de la dirección memoria de a</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;El valor de a es: %d. </span><span class="se">\n</span><span class="s">El valor de *p es: %d. </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;La direccion de memoria de *p es: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Ejemplo 2:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">yPtr</span><span class="p">;</span> <span class="cm">/* yPtr es puntero a entero */</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">yPtr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">;</span> <span class="cm">/* yPtr toma la dirección de y */</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;y: %d, yPtr: %p, &amp;y: %p, &amp;yPtr: %p, *yPtr: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yPtr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">yPtr</span><span class="p">,</span> <span class="o">*</span><span class="n">yPtr</span><span class="p">);</span>

<span class="cm">/* Salida por pantalla:</span>
<span class="cm">y: 5, yPtr: 0x7fff5d9829ec (1050), &amp;y: 0x7fff5d9829ec (1050), &amp;yPtr: 0x7fff5d9829e0 (1200), *yPtr: 5</span>
<span class="cm">*/</span>
</pre></div>
</td></tr></table>

<p><img src="imagenes/puntero.png" width="500px"/></p>
<ul>
<li>Una variable se refiere directamente a un valor y un puntero se refiere indirectamente a un valor.</li>
<li>El puntero, al tener una dirección de memoria es como si apuntara a dicha dirección.</li>
<li>Las direcciones de memoria de cada variable las asigna el sistema operativo y el programa no puede ni cambiarlas ni usar otras posiciones distintas.</li>
</ul>
<p>Ejemplo 3:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">py</span><span class="p">;</span>

   <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">- Introduzca un número: &quot;</span><span class="p">);</span>
   <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%i&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">y</span><span class="p">);</span>

   <span class="n">py</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">;</span>
   <span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">py</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span> <span class="cm">/* Suma 10 con el contenido de la dirección py */</span>

   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">- Enteros: %d, %d y %d.&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">py</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">- Direcciones: %p y %p.&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">,</span> <span class="n">py</span><span class="p">);</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Salida por pantalla:</span>
<span class="cm">- Introduzca un número: 4</span>
<span class="cm">- Enteros: 4, 4 y 14.</span>
<span class="cm">- Direcciones: 0x7fff5afeb9e8 y 0x7fff5afeb9e8</span>
<span class="cm">*/</span>
</pre></div>
</td></tr></table>

<p>Ejemplo 4:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="o">*</span><span class="n">punteroInt</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">valor</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

<span class="n">punteroInt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">valor</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Puntero: dir: %p, valor: %d, referencia: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">punteroInt</span><span class="p">,</span> <span class="o">*</span><span class="n">punteroInt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">punteroInt</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Variable: valor: %d, referencia: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">valor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">valor</span><span class="p">);</span>

<span class="cm">/* Salida por pantalla:</span>
<span class="cm">Puntero: dir: 0x7fff523e19e4, valor: 8, referencia:0x7fff523e19e8</span>
<span class="cm">Variable: valor: 8, referencia: 0x7fff523e19e4</span>
<span class="cm">*/</span>
</pre></div>
</td></tr></table>

<p>Muchas de las funciones estándares de C trabajan con punteros, como es el caso del <code>scanf</code>. A <code>scanf</code> se le pasa la dirección de memoria del dato a leer.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">char</span> <span class="n">a</span><span class="p">;</span>
<span class="n">scanf</span> <span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Ejemplo 5:</p>
<p>El siguiente programa muestra el concepto de creación, inicialización e indirección de una variable puntero:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
   <span class="kt">char</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>

   <span class="n">pc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>

   <span class="k">for</span><span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;Z&#39;</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c &quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pc</span><span class="p">);</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//Salida: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</span>
</pre></div>
</td></tr></table>

<h4>Punteros a punteros</h4>
<p>Un puntero puede apuntar a otra variable puntero. Este concepto se utiliza mucho en programas complejos en C y en la definición de estructuras de datos multidimensionales. Para declarar un puntero a un puntero se precede a la variable con dos asteriscos <code>**</code>. Ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="n">valor</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">ptr1</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">**</span><span class="n">ptr5</span><span class="p">;</span>

<span class="n">ptr1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">valor</span><span class="p">;</span>
<span class="n">ptr5</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ptr1</span><span class="p">;</span>
</pre></div>
</td></tr></table>

<p><code>ptr1</code>y <code>ptr5</code>son punteros. <code>ptr1</code>apunta a la variable <code>valor</code>de tipo <code>int</code>. <code>ptr5</code>contiene la dirección de <code>ptr1</code>.</p>
<p>Se pueden asignar valores a <code>valor</code>con cualquiera de las siguientes sentencias:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">valor</span> <span class="o">=</span> <span class="mi">95</span><span class="p">;</span>
<span class="o">*</span><span class="n">ptr1</span> <span class="o">=</span> <span class="mi">105</span><span class="p">;</span>  <span class="c1">// Asigna 105 a valor</span>
<span class="o">**</span><span class="n">ptr5</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>  <span class="c1">// Asigna 99 a valor</span>
</pre></div>
</td></tr></table>

<h3 id="12-punteros-y-arrays">1.2 Punteros y arrays<a class="headerlink" href="#12-punteros-y-arrays" title="Permanent link">&para;</a></h3>
<p>En C los punteros y los arrays están fuertemente relacionados. Se pueden direccionar arrays como si fueran punteros y punteros como si fueran arrays.</p>
<h4>Nombres de arrays como punteros</h4>
<p>El nombre de un vector es en sí mismo un puntero a la primera posición del vector. Todas las operaciones que
utilizan vectores e índices pueden realizarse mediante punteros.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="n">v</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</pre></div>
</td></tr></table>

<p><img alt="" src="imagenes/vector.png" /></p>
<p><code>v</code>: designa 10 posiciones consecutivas de memoria donde se pueden almacenar enteros.</p>
<p>Si visualizamos <code>v[0]</code> veremos 1.  ¿Y si visualizamos <code>*v</code>? Como el nombre del array también es un puntero, también se verá 1. Esto significa que:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">v</span> <span class="o">+</span> <span class="mi">0</span> <span class="n">apunta</span> <span class="n">a</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">v</span> <span class="o">+</span> <span class="mi">1</span> <span class="n">apunta</span> <span class="n">a</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">v</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">apunta</span> <span class="n">a</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">v</span> <span class="o">+</span> <span class="mi">3</span> <span class="n">apunta</span> <span class="n">a</span> <span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="p">...</span>
</pre></div>
</td></tr></table>

<p>Por tanto, para manejar los elementos de un array, se puede utilizar la notación de subíndices o la notación de punteros. Dado que el nombre del array contiene la dirección del primer elemento del array, se debe indireccionar el puntero para obtener el valor del elemento.</p>
<h4>Arrays de caracteres</h4>
<p>Podemos hacer un array de caracteres usando punteros.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">char</span> <span class="o">*</span><span class="n">nombre</span> <span class="o">=</span> <span class="s">&quot;Hola que tal&quot;</span><span class="p">;</span><span class="c1">//Es una cadena de 13 caracteres (12 + &#39;\0&#39;)</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span><span class="n">nombre</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Realmente se define como una constante de caracteres y no podemos modificarla despues de definir sus valores. Como por ejemplo no podemos reemplazar un carácter, o leer un nuevo valor.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">//Error de ejecución:</span>
<span class="n">strcpy</span><span class="p">(</span><span class="n">nombre</span><span class="p">,</span> <span class="s">&quot;hola&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>Se soluciona utilizando memoria dinámica (lo veremos más adelante).</p>
<h3 id="13-punteros-a-estructuras">1.3 Punteros a estructuras<a class="headerlink" href="#13-punteros-a-estructuras" title="Permanent link">&para;</a></h3>
<p>Un puntero también puede apuntar a un registro. Se puede declarar el puntero a una estructura tal y como se declara un puntero a cualquier otro tipo.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span><span class="n">TPunto</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="n">TPunto</span> <span class="o">*</span><span class="n">p1</span><span class="p">;</span>
   <span class="n">TPunto</span> <span class="o">*</span><span class="n">p2</span><span class="p">;</span>
<span class="p">}</span><span class="n">TSegmento</span><span class="p">;</span>
</pre></div>
</td></tr></table>

<p><code>TSegmento</code> tiene como campos dos punteros a <code>TPunto</code>.</p>
<p>Ejemplo completo, donde dos segmentos comparten el mismo punto:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span><span class="n">TPunto</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="n">TPunto</span> <span class="o">*</span><span class="n">p1</span><span class="p">;</span>
   <span class="n">TPunto</span> <span class="o">*</span><span class="n">p2</span><span class="p">;</span>
<span class="p">}</span><span class="n">TSegmento</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">imprimeSegmento</span><span class="p">(</span><span class="n">TSegmento</span> <span class="n">s</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">TPunto</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
   <span class="n">TPunto</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">};</span>
   <span class="n">TPunto</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">};</span>
   <span class="n">TPunto</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">};</span>

   <span class="n">TSegmento</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">;</span>
   <span class="n">s1</span><span class="p">.</span><span class="n">p1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
   <span class="n">s1</span><span class="p">.</span><span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>
   <span class="n">s2</span><span class="p">.</span><span class="n">p1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>
   <span class="n">s2</span><span class="p">.</span><span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>

   <span class="n">imprimeSegmento</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
   <span class="n">imprimeSegmento</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>

   <span class="c1">// P1: [2,3] P2: [10,10]</span>
   <span class="c1">// P1: [10,10] P2: [5,6]</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>En el ejemplo anterior, los segmentos s1 y s2 comparten el punto b. Si éste cambiase, afectaría a los dos puntos, porque apuntan al mismo punto. Al referenciar al mismo punto y no ser una copia, al modificar uno de los dos, el otro se modifica.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span> <span class="c1">// Seguimos con el código anterior</span>
 <span class="c1">// Modificamos el punto compartido por ambos segmentos</span>
 <span class="c1">// Cambiamos el p2 del s1:</span>

   <span class="n">s1</span><span class="p">.</span><span class="n">p2</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="n">s1</span><span class="p">.</span><span class="n">p2</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

   <span class="n">imprimeSegmento</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
   <span class="n">imprimeSegmento</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>

  <span class="c1">// P1: [2,3] P2: [100,100]</span>
  <span class="c1">// P1: [100,100] P2: [5,6]</span>
</pre></div>
</td></tr></table>

<p>Como podemos observar, cambiando p2 de s1 hace que cambie también el p1 de s2. Esto sucede porque están compartiendo una referencia al mismo punto, no son copias. Esta es la filosofía de funcionamiento en otros lenguajes, como Java, donde se utiliza el paradigma de programación orientado a objetos.</p>
<h2 id="2-gestion-de-memoria-dinamica">2. Gestión de memoria dinámica<a class="headerlink" href="#2-gestion-de-memoria-dinamica" title="Permanent link">&para;</a></h2>
<h3 id="21-memoria-dinamica">2.1 Memoria dinámica<a class="headerlink" href="#21-memoria-dinamica" title="Permanent link">&para;</a></h3>
<ul>
<li>La <strong>memoria estática</strong> es el espacio en memoria que se crea al declarar variables de cualquier tipo de dato. La memoria que estas variables ocupan no puede cambiarse durante la ejecución y tampoco puede ser liberada manualmente.</li>
<li>La <strong>memoria dinámica</strong> es memoria que se reserva en tiempo de ejecución. Su principal ventaja frente a la estática, es que su tamaño puede variar durante la ejecución del programa. En C, el programador es encargado de liberar esta memoria cuando no la utilice más. El uso de memoria dinámica es necesario cuando a priori no conocemos el número de datos o elementos a tratar o cuando queremos optimizarla.</li>
</ul>
<p>Definimos las <strong>variables dinámicas</strong> como zonas de memoria que pueden reservarse y liberarse durante el transcurso del programa. La única forma de acceder a su contenido es mediante una variable puntero que almacene la dirección de memoria correspondiente. Las variables dinámicas se guardan en la zona de memoria dinámica y se gestionan con las funciones de memoria dinámica (<code>malloc</code>, <code>calloc</code>, <code>realloc,</code>free`).</p>
<h3 id="22-funciones-para-gestionar-la-memoria-dinamica">2.2 Funciones para gestionar la memoria dinámica<a class="headerlink" href="#22-funciones-para-gestionar-la-memoria-dinamica" title="Permanent link">&para;</a></h3>
<p>La biblioteca estándar de C proporciona las funciones <code>malloc</code>, <code>calloc</code>, <code>realloc</code> y <code>free</code> para el manejo de memoria dinámica. Estas funciones están definidas la librería <code>stdlib.h</code>.</p>
<h4>malloc</h4>
<p>La función <code>malloc</code> reserva un bloque de memoria y devuelve un puntero al inicio de la misma.</p>
<p>Sintaxis:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>void *malloc(size_t size);
</pre></div>
</td></tr></table>

<p>donde el parámetro <code>size</code> especifica el número de bytes a reservar. En caso de que no se pueda realizar la asignación, devuelve el valor nulo (definido en la macro <code>NULL</code> ), lo que permite saber si hubo errores en la asignación de memoria.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="o">*</span><span class="n">vect1</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Número de elementos del vector: &quot;</span><span class="p">);</span>
   <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>

   <span class="cm">/* reservamos memoria para almacenar n enteros */</span>
   <span class="n">vect1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

   <span class="cm">/* Verificamos que la asignación se haya realizado correctamente */</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">vect1</span>  <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Error al intentar reservar memoria */</span>
   <span class="p">}</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>El operador <code>sizeof(tipo)</code> nos devuelve el número de <em>bytes</em> que ocupa el tipo de dato pasado como parámetro.</p>
<p>Uno de los usos más comunes de la memoria dinámica es la creación de vectores/matrices cuyo número de elementos se define en tiempo de ejecución.</p>
<h4>calloc</h4>
<p>La función <code>calloc</code> funciona de modo similar a <code>malloc</code>, pero además de reservar memoria, inicializa a 0 la memoria reservada.</p>
<p>Sintaxis:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>void* calloc(size_t num, size_t size);
</pre></div>
</td></tr></table>

<p>Devuelve un puntero a una zona de memoria en la que se reservan <code>num</code> elementos de <code>size</code> bytes. La memoria se inicializa a 0.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="cp">#define TAM = 25</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="kt">float</span> <span class="o">*</span><span class="n">vectorFloat</span><span class="p">;</span>
   <span class="n">vectorFloat</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="n">TAM</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>

   <span class="cm">/* Verificamos que la asignación se haya realizado correctamente */</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">vectorFloat</span>  <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/* Error al intentar reservar memoria */</span>
      <span class="p">...</span>
   <span class="p">}</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h4>realloc</h4>
<p>La función <code>realloc</code> redimensiona el espacio asignado de forma dinámica anteriormente a un puntero.</p>
<p>Sintaxis:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>void* realloc(void *ptr, size_t size);
</pre></div>
</td></tr></table>

<p>Donde <code>ptr</code> es el puntero a redimensionar, y <code>size</code> el nuevo tamaño, en bytes, que tendrá. Si el puntero que se le pasa tiene el valor <code>NULL</code>, esta función actúa como <code>malloc</code>. Si la reasignación no se pudo hacer con éxito, devuelve un puntero nulo.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="cp">#define TAM = 20</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="kt">float</span> <span class="o">*</span><span class="n">vectorFloat</span><span class="p">;</span>
   <span class="n">vectorFloat</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">TAM</span><span class="p">);</span>
   <span class="n">vectorFloat</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span><span class="n">realloc</span><span class="p">(</span><span class="n">vectorFloat</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="mi">50</span><span class="p">);</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="kt">float</span> <span class="o">*</span><span class="n">vectorFloat</span><span class="p">;</span>
   <span class="n">vectorFloat</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
   <span class="n">vectorFloat</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span><span class="n">realloc</span><span class="p">(</span><span class="n">vectorFloat</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="mi">50</span><span class="p">);</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Cuando se redimensiona la memoria con <code>realloc</code>, si el nuevo tamaño es mayor que el anterior, se conservan todos los valores originales, quedando los bytes restantes sin inicializar. Si el nuevo tamaño es menor, se conservan los valores de los primeros size bytes. Los restantes también se dejan intactos, pero no son parte del bloque que devuelve la función.</p>
<h4>free</h4>
<p>La función <code>free</code> sirve para liberar memoria que se asignó dinámicamente. Requiere como parámetro la dirección de memoria inicial de una zona de memoria reservada en la memoria dinámica (tal cual se reservó con <code>malloc</code> o <code>realloc</code>). La función <code>free</code>se encarga de marcar como libre esta memoria. Si el puntero es nulo, <code>free</code> no hace nada.</p>
<p>Además existe la función <code>cfree</code>, que sirve para liberar memoria de los elementos que han sido reservados con <code>calloc</code>.</p>
<p>Sintaxis:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>void free(void *ptr);
void cfree (void *ptr);
</pre></div>
</td></tr></table>

<ul>
<li>Libera la memoria reservada para el puntero <code>ptr</code></li>
<li>No se ejecuta automáticamente cuando se acaba el ámbito en el que se definió el puntero</li>
<li>Las llamadas a <code>free</code> han de ser explícitas</li>
</ul>
<h5><code>NULL</code></h5>
<ul>
<li><code>NULL</code> hace referencia a una dirección de memoria nula, no válida</li>
<li>Lo utilizamos cuando queremos indicar que un puntero no tiene memoria reservada o la que tenía ya ha sido liberada por medio de una llamada a <code>free()</code></li>
<li><code>NULL</code> es también el valor devuelto por funciones que han de devolver un puntero cuando no pueden realizar su labor.</li>
<li><code>[m|c|re]alloc</code> devuelven <code>NULL</code> cuando no hay memoria disponible</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="cp">#define TAM = 20</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="kt">float</span> <span class="o">*</span><span class="n">vectorFloat</span><span class="p">;</span>
   <span class="n">vectorFloat</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">TAM</span><span class="p">);</span>
   <span class="p">...</span>
   <span class="n">free</span><span class="p">(</span><span class="n">vectorFloat</span><span class="p">);</span>
   <span class="n">vectorFloat</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="23-arrays-dinamicos-multidimensionales">2.3 Arrays dinámicos multidimensionales<a class="headerlink" href="#23-arrays-dinamicos-multidimensionales" title="Permanent link">&para;</a></h3>
<p>Para definir un array multidimensional de manera dinámica utilizaremos punteros a punteros. En este caso vamos a definir una matriz de dos dimensiones:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="o">**</span><span class="n">tabla2D</span><span class="p">;</span>  <span class="c1">// un puntero por cada dimensión</span>
</pre></div>
</td></tr></table>

<p>Se interpreta como un puntero a un tipo que es un puntero a un entero.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="cp">#define X 5</span>
<span class="cp">#define Y 7</span>

<span class="kt">void</span> <span class="nf">rellenarTabla2D</span><span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="o">**</span><span class="n">tabla2D</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">;</span>

   <span class="c1">// Reservamos la memoria</span>
   <span class="n">tabla2D</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">X</span><span class="p">);</span>

   <span class="k">for</span><span class="p">(</span><span class="n">dim1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dim1</span> <span class="o">&lt;</span> <span class="n">X</span><span class="p">;</span> <span class="n">dim1</span><span class="o">++</span><span class="p">){</span>
      <span class="n">tabla2D</span><span class="p">[</span><span class="n">dim1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">Y</span><span class="p">);</span>
      <span class="k">for</span><span class="p">(</span><span class="n">dim2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dim2</span> <span class="o">&lt;</span> <span class="n">Y</span><span class="p">;</span> <span class="n">dim2</span><span class="o">++</span><span class="p">){</span>
         <span class="n">tabla2D</span><span class="p">[</span><span class="n">dim1</span><span class="p">][</span><span class="n">dim2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>

   <span class="c1">// Rellenamos sus valores en una función</span>
   <span class="n">rellenarTabla2D</span><span class="p">(</span><span class="n">tabla2D</span><span class="p">);</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tabla2D</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]);</span> <span class="c1">// comprobamos una posición al azar</span>

   <span class="c1">//Liberamos la memoria de la tabla3D</span>
   <span class="k">for</span><span class="p">(</span><span class="n">dim1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dim1</span> <span class="o">&lt;</span> <span class="n">X</span><span class="p">;</span> <span class="n">dim1</span><span class="o">++</span><span class="p">)</span>
      <span class="n">free</span><span class="p">(</span><span class="n">tabla2D</span><span class="p">[</span><span class="n">dim1</span><span class="p">]);</span>

   <span class="n">free</span><span class="p">(</span><span class="n">tabla2D</span><span class="p">);</span>
   <span class="n">tabla2D</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rellenarTabla2D</span><span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="n">tabla</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>

  <span class="k">for</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">X</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">Y</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">){</span>
        <span class="n">tabla</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h2 id="3-punteros-y-funciones">3. Punteros y funciones<a class="headerlink" href="#3-punteros-y-funciones" title="Permanent link">&para;</a></h2>
<p>Uno de los usos de los punteros es el paso de
parámetros por referencia a una función.
Recordemos que los parámetros de una función se
pueden pasar por valor o por referencia.</p>
<p>En C todos los parámetros de las funciones se pasan por valor. Para simular un paso de parámetro por referencia en C, lo que se
hace es pasar un puntero al objeto que se pasa. Así,
la función tiene acceso no sólo al valor del
parámetro sino también a su situación en memoria,
lo que permite su modificación.</p>
<p>Ya vimos que para que un parámetro de una función pueda ser modificado, ha de pasarse por referencia, y en C eso sólo es posible pasando la dirección de la variable en lugar de la propia variable.
Si se pasa la dirección de una variable, la función puede modificar el contenido de esa posición (no así
la propia dirección, que es una copia)</p>
<h3 id="arrays-y-matrices-como-parametro">Arrays y matrices como parámetro<a class="headerlink" href="#arrays-y-matrices-como-parametro" title="Permanent link">&para;</a></h3>
<h4>Paso de parámetros por valor</h4>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">funcion</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">cad</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Función. Valor: %s, Dirección: %p, Referencia: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cad</span><span class="p">,</span> <span class="n">cad</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cad</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="c1">// Definimos una cadena de caracteres constante</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">cadena</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Hola mundo&quot;</span><span class="p">};</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Main. Valor: %s, Dirección: %p, Referencia: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cadena</span><span class="p">,</span> <span class="n">cadena</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cadena</span><span class="p">);</span>
  <span class="n">funcion</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Salida por pantalla:</span>
<span class="cm">Main. Valor: Hola mundo, Dirección: 0x1046e0f77, Referencia: 0x7fff5b51f9e8</span>
<span class="cm">Función. Valor: Hola mundo, Dirección: 0x1046e0f77, Referencia: 0x7fff5b51f9c8</span>
<span class="cm">*/</span>
</pre></div>
</td></tr></table>

<p>Como vemos, en <code>funcion</code> hay una referencia a los elementos del array pero no al puntero en sí, que es una copia. Es decir, no podríamos modificar dinámicamente su memoria porque no tenemos una referencia a la misma.</p>
<h3 id="paso-de-parametros-por-referencia">Paso de parámetros por referencia<a class="headerlink" href="#paso-de-parametros-por-referencia" title="Permanent link">&para;</a></h3>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">funcionRef</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">cad</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Función. Valor: %s, Dirección: %p, Referencia: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">cad</span><span class="p">,</span> <span class="o">*</span><span class="n">cad</span><span class="p">,</span> <span class="n">cad</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="kt">char</span> <span class="o">*</span><span class="n">cadena</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Hola mundo&quot;</span><span class="p">};</span>

   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Main. Valor: %s, Dirección: %p, Referencia: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cadena</span><span class="p">,</span> <span class="n">cadena</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cadena</span><span class="p">);</span>
   <span class="n">funcionRef</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cadena</span><span class="p">);</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Salida por pantalla:</span>
<span class="cm">Main. Valor: Hola mundo, Dirección: 0x10861af77, Referencia: 0x7fff575e59e8</span>
<span class="cm">Función. Valor: Hola mundo, Dirección: 0x10861af77, Referencia: 0x7fff575e59e8</span>
<span class="cm">*/</span>
</pre></div>
</td></tr></table>

<p>Ahora tenemos referencia a los datos y al propio puntero con lo que podemos modificar la memoria que tiene reservada.</p>
<p>Ejemplo con vector:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#define TAM 20</span>

<span class="kt">void</span> <span class="nf">creaVector</span><span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="o">*</span><span class="n">vector</span><span class="p">;</span>

   <span class="c1">// Reservamos la memoria</span>
   <span class="n">creaVector</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vector</span><span class="p">);</span>
   <span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">//Rellenamos al azar</span>
   <span class="n">vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Pos 2: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span> <span class="c1">//Comprobamos</span>

   <span class="c1">// Liberamos memoria</span>
   <span class="n">free</span><span class="p">(</span><span class="n">vector</span><span class="p">);</span>
   <span class="n">vector</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">creaVector</span><span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
   <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">TAM</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Ejemplo con <code>typedef</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#define TAM 20</span>

<span class="k">typedef</span> <span class="kt">int</span><span class="o">*</span> <span class="n">TVector</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">creaVector</span><span class="p">(</span><span class="n">TVector</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">ampliaVector</span><span class="p">(</span><span class="n">TVector</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">TVector</span> <span class="n">vector</span><span class="p">;</span>

   <span class="c1">// Reservamos la memoria</span>
   <span class="n">creaVector</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vector</span><span class="p">);</span>
   <span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">//Rellenamos al azar</span>
   <span class="n">vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Pos 2: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span> <span class="c1">//Comprobamos</span>
   <span class="n">ampliaVector</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vector</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>

   <span class="c1">// Liberamos memoria</span>
   <span class="n">free</span><span class="p">(</span><span class="n">vector</span><span class="p">);</span>
   <span class="n">vector</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">creaVector</span><span class="p">(</span><span class="n">TVector</span><span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
   <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">TAM</span><span class="p">);</span>
<span class="c1">// Equivalente:</span>
<span class="c1">// *v = (TVector)malloc(sizeof(int) * TAM);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ampliaVector</span><span class="p">(</span><span class="n">TVector</span><span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tam</span><span class="p">)</span> <span class="p">{</span>
   <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">realloc</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">tam</span><span class="p">);</span>
<span class="c1">// Equivalente:</span>
<span class="c1">// *v = (TVector)realloc(*v, sizeof(int)*tam);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="devolucion-de-punteros">Devolución de punteros<a class="headerlink" href="#devolucion-de-punteros" title="Permanent link">&para;</a></h3>
<p>Una función también puede devolver un tipo de datos
puntero. La función se declara así:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>&lt;tipo*&gt; funcion(&lt;argumentos&gt;);
</pre></div>
</td></tr></table>

<p>Este tipo de funciones se suelen usar para reservar
memoria o crear elementos en estructuras
dinámicas de datos. En el ejemplo anterior, la reserva de memoria dinámica del vector también podría hacerse así:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span><span class="o">*</span> <span class="nf">creaVector</span><span class="p">()</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
   <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">TAM</span><span class="p">);</span>

   <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Ejercicio: Dado un <code>TPunto</code>, define una estructura que contenga un array dinámico de puntos y la cantidad de puntos que contiene. Sólo se debe reservar la memoria necesaria.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span><span class="n">TPunto</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
    <span class="n">TPunto</span> <span class="o">*</span><span class="n">puntos</span><span class="p">;</span>
<span class="p">}</span> <span class="n">TPuntos</span><span class="p">;</span>

<span class="n">TPuntos</span> <span class="nf">rellenaLista</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">TPuntos</span> <span class="n">puntos</span><span class="p">;</span>

   <span class="n">puntos</span> <span class="o">=</span> <span class="n">rellenaLista</span><span class="p">();</span>

   <span class="c1">//Función para imprimir los puntos</span>

   <span class="n">free</span><span class="p">(</span><span class="n">puntos</span><span class="p">.</span><span class="n">puntos</span><span class="p">);</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TPuntos</span> <span class="nf">rellenaLista</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">TPuntos</span> <span class="n">lista</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="n">fin</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>


   <span class="n">fin</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
   <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">lista</span><span class="p">.</span><span class="n">puntos</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
   <span class="n">lista</span><span class="p">.</span><span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Introduce puntos hasta introducir -1 -1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
   <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">fin</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d %d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span> <span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">lista</span><span class="p">.</span><span class="n">puntos</span> <span class="o">=</span> <span class="p">(</span><span class="n">TPunto</span> <span class="o">*</span><span class="p">)</span> <span class="n">realloc</span><span class="p">(</span><span class="n">lista</span><span class="p">.</span><span class="n">puntos</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TPunto</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
         <span class="n">lista</span><span class="p">.</span><span class="n">puntos</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
         <span class="n">lista</span><span class="p">.</span><span class="n">puntos</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
         <span class="n">n</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span>
         <span class="n">fin</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="n">lista</span><span class="p">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

   <span class="k">return</span> <span class="n">lista</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>En el siguiente ejemplo modificamos la función <code>rellenaLista</code> y le pasamos por parámetro por referencia <code>TPuntos lista</code>. ¿Qué sucede si quitamos los paréntesis de <code>(*lista)</code>?</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">rellenaLista</span><span class="p">(</span><span class="n">TPuntos</span> <span class="o">*</span><span class="n">lista</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">bool</span> <span class="n">fin</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

   <span class="n">fin</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
   <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="p">(</span><span class="o">*</span><span class="n">lista</span><span class="p">).</span><span class="n">puntos</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
   <span class="p">(</span><span class="o">*</span><span class="n">lista</span><span class="p">).</span><span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Introduce puntos hasta introducir -1 -1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
   <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">fin</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d %d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span> <span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
         <span class="p">(</span><span class="o">*</span><span class="n">lista</span><span class="p">).</span><span class="n">puntos</span> <span class="o">=</span> <span class="p">(</span><span class="n">TPunto</span> <span class="o">*</span><span class="p">)</span> <span class="n">realloc</span><span class="p">((</span><span class="o">*</span><span class="n">lista</span><span class="p">).</span><span class="n">puntos</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TPunto</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
         <span class="p">(</span><span class="o">*</span><span class="n">lista</span><span class="p">).</span><span class="n">puntos</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
         <span class="p">(</span><span class="o">*</span><span class="n">lista</span><span class="p">).</span><span class="n">puntos</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
         <span class="n">n</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span>
         <span class="n">fin</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="p">(</span><span class="o">*</span><span class="n">lista</span><span class="p">).</span><span class="n">num</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h2 id="4-array-estatico-de-punteros">4. Array estático de punteros<a class="headerlink" href="#4-array-estatico-de-punteros" title="Permanent link">&para;</a></h2>
<p>Si se necesita reservar muchos punteros o gestionar de forma más eficiente la memoria, se puede declarar un array de punteros. Un array de punteros es un array cuyos elementos son punteros. Ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span><span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// Array de 10 punteros a enteros</span>
</pre></div>
</td></tr></table>

<p>Cada elemento contiene una dirección que apunta a otras posiciones de memoria. Cada valor apuntado en este caso debe ser un entero.. Ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">edad</span><span class="p">;</span>  <span class="c1">// a[5] apunta a la dirección de edad</span>
<span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>   <span class="c1">// a[4] no contiene dirección</span>
</pre></div>
</td></tr></table>

<p>Podemos crear arrays de punteros a cualquier tipo: arrays de punteros a cadenas, a registros, etc.</p>
<h4>Ejemplo de array de punteros a registro</h4>
<p>Siguiendo con el ejemplo de los puntos y los segmentos, vamos definir un array de punteros a segmento:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">TSegmento</span><span class="o">*</span> <span class="n">segmentos</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="n">TSegmento</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">;</span>

<span class="n">segmentos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">;</span>
<span class="n">segmentos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">;</span>
</pre></div>
</td></tr></table>

<h2 id="5-array-dinamico-de-registros">5. Array dinámico de registros<a class="headerlink" href="#5-array-dinamico-de-registros" title="Permanent link">&para;</a></h2>
<p>Vamos a definir un array dinámico de <code>TSegmento</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">TSegmento</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
<span class="c1">// Reservando una zona de memoria dinámica:</span>
<span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">TSegmento</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TSegmento</span><span class="p">));</span>
<span class="n">segmentos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
<span class="p">...</span>
<span class="c1">// Después de su uso hay que liberar la memoria:</span>
<span class="n">free</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<p>También podemos reservar la memoria dinámica dentro de una función:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">//Funciones para reservar memoria de dos formas diferentes:</span>
<span class="n">TSegmento</span><span class="o">*</span> <span class="nf">creaSegmento</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">creaPunto</span><span class="p">(</span><span class="n">TPunto</span><span class="o">**</span><span class="p">);</span>  <span class="c1">// Pasamos por referencia el puntero a TPunto</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">TSegmento</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
   <span class="n">TPunto</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
   <span class="n">TPunto</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

   <span class="c1">// Reservar memoria</span>
   <span class="n">s</span> <span class="o">=</span> <span class="n">creaSegmento</span><span class="p">();</span>
   <span class="n">creaPunto</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p1</span><span class="p">);</span>
   <span class="n">creaPunto</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p2</span><span class="p">);</span>

   <span class="c1">// Resto del código</span>
   <span class="n">s</span><span class="o">-&gt;</span><span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>   
   <span class="n">s</span><span class="o">-&gt;</span><span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="p">;</span>

   <span class="n">p1</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>   <span class="c1">// Modificamos los puntos</span>
   <span class="n">p1</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>   <span class="c1">// Por tanto, se modifica el segmento</span>
   <span class="n">p2</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>   <span class="c1">// Porque apuntan al mismo &quot;objeto&quot;</span>
   <span class="n">p2</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

   <span class="n">imprimeSegmento</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">);</span>

   <span class="c1">// Liberar memoria</span>
   <span class="n">free</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
   <span class="n">free</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>
   <span class="n">free</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
   <span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
   <span class="n">p1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
   <span class="n">p2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TSegmento</span><span class="o">*</span> <span class="nf">creaSegmento</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">TSegmento</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
   <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">TSegmento</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TSegmento</span><span class="p">));</span>
   <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">creaPunto</span><span class="p">(</span><span class="n">TPunto</span> <span class="o">**</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">TPunto</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TPunto</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<hr />
<h2 id="ejercicios-resueltos">Ejercicios resueltos<a class="headerlink" href="#ejercicios-resueltos" title="Permanent link">&para;</a></h2>
<h3 id="ejercicio-1-array-dinamico-de-registros">Ejercicio 1: Array dinámico de registros<a class="headerlink" href="#ejercicio-1-array-dinamico-de-registros" title="Permanent link">&para;</a></h3>
<p>Escribe un programa que guarde información de vehículos. De cada vehículo interesa almacenar la matrícula, la marca, el propietario y el precio. Del propietario guardaremos sus datos personales: nombre, dirección, teléfono y nif. Se almacenarán en un array dinámico que irá aumentando conforme se vayan añadiendo coches.
Después responde a las siguientes preguntas:</p>
<ul>
<li>¿Qué sucede si no inicializamos el array a NULL?</li>
<li>Si hacemos el <code>realloc</code> en el <code>main</code>, ¿qué habría que cambiar? ¿Por qué?</li>
<li>Prueba a no pasar el vector por referencia a nuevoCoche. Qué sucede?</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#define TAMCAD 15</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="kt">char</span> <span class="n">nombre</span><span class="p">[</span><span class="n">TAMCAD</span><span class="p">];</span>
   <span class="kt">char</span> <span class="n">nif</span><span class="p">[</span><span class="n">TAMCAD</span><span class="p">];</span>
<span class="p">}</span><span class="n">TPersona</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="kt">char</span> <span class="n">matricula</span><span class="p">[</span><span class="n">TAMCAD</span><span class="p">];</span>
   <span class="kt">char</span> <span class="n">marca</span><span class="p">[</span><span class="n">TAMCAD</span><span class="p">];</span>
   <span class="kt">float</span> <span class="n">precio</span><span class="p">;</span>
   <span class="n">TPersona</span> <span class="n">propietario</span><span class="p">;</span>
<span class="p">}</span><span class="n">TFichaCoche</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">TFichaCoche</span> <span class="o">*</span><span class="n">TCoches</span><span class="p">;</span> <span class="c1">// Array dinámico de tipo TFichaCoche</span>

<span class="kt">void</span> <span class="nf">nuevoCoche</span><span class="p">(</span><span class="n">TCoches</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">muestraCoches</span><span class="p">(</span><span class="n">TCoches</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">TCoches</span> <span class="n">coches</span><span class="p">;</span> <span class="c1">// Array dinámico que va aumentando conforme se añaden coches</span>
   <span class="kt">int</span> <span class="n">numCoches</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

   <span class="n">coches</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">//Necesario si no inicializamos el puntero con malloc</span>
<span class="c1">// Probamos: añadimos 3 coches</span>
   <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">nuevoCoche</span><span class="p">(</span><span class="o">&amp;</span><span class="n">coches</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">numCoches</span><span class="p">);</span>
   <span class="p">}</span>

<span class="c1">// Los mostramos</span>
   <span class="n">muestraCoches</span><span class="p">(</span><span class="n">coches</span><span class="p">,</span> <span class="n">numCoches</span><span class="p">);</span>

<span class="c1">// Liberamos memoria</span>
   <span class="n">free</span><span class="p">(</span><span class="n">coches</span><span class="p">);</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nuevoCoche</span><span class="p">(</span><span class="n">TCoches</span> <span class="o">*</span><span class="n">coches</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">numCoches</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>

   <span class="o">*</span><span class="n">coches</span> <span class="o">=</span> <span class="p">(</span><span class="n">TFichaCoche</span> <span class="o">*</span><span class="p">)</span><span class="n">realloc</span><span class="p">(</span><span class="o">*</span><span class="n">coches</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TFichaCoche</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>

   <span class="n">num</span> <span class="o">=</span> <span class="o">*</span><span class="n">numCoches</span><span class="p">;</span>

   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;**** Coche %d ****</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Introduce matrícula: &quot;</span><span class="p">);</span>
   <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,(</span><span class="o">*</span><span class="n">coches</span><span class="p">)[</span><span class="n">num</span><span class="p">].</span><span class="n">matricula</span><span class="p">);</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Introduce marca: &quot;</span><span class="p">);</span>
   <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">%[^</span><span class="se">\n</span><span class="s">]s&quot;</span><span class="p">,(</span><span class="o">*</span><span class="n">coches</span><span class="p">)[</span><span class="n">num</span><span class="p">].</span><span class="n">marca</span><span class="p">);</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Introduce precio: &quot;</span><span class="p">);</span>
   <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%f&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">coches</span><span class="p">)[</span><span class="n">num</span><span class="p">].</span><span class="n">precio</span><span class="p">);</span>

   <span class="c1">// propietario</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Nombre propietario: &quot;</span><span class="p">);</span>
   <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">%[^</span><span class="se">\n</span><span class="s">]s&quot;</span><span class="p">,(</span><span class="o">*</span><span class="n">coches</span><span class="p">)[</span><span class="n">num</span><span class="p">].</span><span class="n">propietario</span><span class="p">.</span><span class="n">nombre</span><span class="p">);</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;NIF propietario: &quot;</span><span class="p">);</span>
   <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">%s&quot;</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">coches</span><span class="p">)[</span><span class="n">num</span><span class="p">].</span><span class="n">propietario</span><span class="p">.</span><span class="n">nif</span><span class="p">);</span>

   <span class="p">(</span><span class="o">*</span><span class="n">numCoches</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">muestraCoches</span><span class="p">(</span><span class="n">TCoches</span> <span class="n">coches</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

   <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;***********************</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Matrícula: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">coches</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">matricula</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Marca: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">coches</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">marca</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Precio: %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">coches</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">precio</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Propietario: %s con nif: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">coches</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">propietario</span><span class="p">.</span><span class="n">nombre</span><span class="p">,</span> <span class="n">coches</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">propietario</span><span class="p">.</span><span class="n">nif</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;***********************</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="ejercicio-2-tabla-3d-definida-con-typedef">Ejercicio 2: Tabla 3D definida con <code>typedef</code><a class="headerlink" href="#ejercicio-2-tabla-3d-definida-con-typedef" title="Permanent link">&para;</a></h3>
<p>Como hemos visto en temas anteriores, definir tipos propios con <code>typedef</code>resulta muy útil.</p>
<p>Veamos el ejemplo de un array multidimensional de 3 dimensiones <code>tabla3D</code> usando <code>typedef</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#define X 5</span>
<span class="cp">#define Y 7</span>
<span class="cp">#define Z 20</span>

<span class="k">typedef</span> <span class="kt">int</span><span class="o">***</span> <span class="n">TTabla3D</span><span class="p">;</span>

<span class="n">TTabla3D</span> <span class="nf">crearTabla3D</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">freeTabla3D</span><span class="p">(</span><span class="n">TTabla3D</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">rellenarTabla3D</span><span class="p">(</span><span class="n">TTabla3D</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">TTabla3D</span> <span class="n">tabla3D</span><span class="p">;</span>

   <span class="n">tabla3D</span> <span class="o">=</span> <span class="n">crearTabla3D</span><span class="p">();</span>

   <span class="k">if</span><span class="p">(</span><span class="n">tabla3D</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Comprobamos que malloc no haya devuelto NULL</span>
      <span class="n">rellenarTabla3D</span><span class="p">(</span><span class="n">tabla3D</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tabla3D</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// comprobamos una posición al azar</span>
      <span class="n">freeTabla3D</span><span class="p">(</span><span class="n">tabla3D</span><span class="p">);</span>
      <span class="n">tabla3D</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
      <span class="c1">// Si queremos poner tabla3D = NULL dentro de la función</span>
      <span class="c1">// freeTabla3D, tenemos que pasar el puntero tabla3D por</span>
      <span class="c1">// referencia para poder modificarlo</span>
   <span class="p">}</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TTabla3D</span> <span class="nf">crearTabla3D</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">TTabla3D</span> <span class="n">tabla3D</span><span class="p">;</span>  <span class="c1">//será de 5x7x20</span>
   <span class="kt">int</span> <span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">,</span> <span class="n">dim3</span><span class="p">;</span>

   <span class="n">tabla3D</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">***</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="o">**</span><span class="p">)</span> <span class="o">*</span> <span class="n">X</span><span class="p">);</span>

   <span class="k">for</span><span class="p">(</span><span class="n">dim1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dim1</span> <span class="o">&lt;</span> <span class="n">X</span><span class="p">;</span> <span class="n">dim1</span><span class="o">++</span><span class="p">){</span>
      <span class="n">tabla3D</span><span class="p">[</span><span class="n">dim1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">Y</span><span class="p">);</span>
      <span class="k">for</span><span class="p">(</span><span class="n">dim2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dim2</span> <span class="o">&lt;</span> <span class="n">Y</span><span class="p">;</span> <span class="n">dim2</span><span class="o">++</span><span class="p">){</span>
         <span class="n">tabla3D</span><span class="p">[</span><span class="n">dim1</span><span class="p">][</span><span class="n">dim2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">Z</span><span class="p">);</span>
         <span class="k">for</span><span class="p">(</span><span class="n">dim3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dim3</span> <span class="o">&lt;</span> <span class="n">Z</span><span class="p">;</span> <span class="n">dim3</span><span class="o">++</span><span class="p">){</span>
            <span class="n">tabla3D</span><span class="p">[</span><span class="n">dim1</span><span class="p">][</span><span class="n">dim2</span><span class="p">][</span><span class="n">dim3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/*inicialización*/</span>
         <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}</span>

   <span class="k">return</span> <span class="n">tabla3D</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">freeTabla3D</span><span class="p">(</span><span class="n">TTabla3D</span> <span class="n">tabla</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">,</span> <span class="n">dim3</span><span class="p">;</span>

   <span class="k">for</span><span class="p">(</span><span class="n">dim1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dim1</span> <span class="o">&lt;</span> <span class="n">X</span><span class="p">;</span> <span class="n">dim1</span><span class="o">++</span><span class="p">){</span>
      <span class="k">for</span><span class="p">(</span><span class="n">dim2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dim2</span> <span class="o">&lt;</span> <span class="n">Y</span><span class="p">;</span> <span class="n">dim2</span><span class="o">++</span><span class="p">){</span>
         <span class="n">free</span><span class="p">(</span><span class="n">tabla</span><span class="p">[</span><span class="n">dim1</span><span class="p">][</span><span class="n">dim2</span><span class="p">]);</span>
      <span class="p">}</span>
      <span class="n">free</span><span class="p">(</span><span class="n">tabla</span><span class="p">[</span><span class="n">dim1</span><span class="p">]);</span>
   <span class="p">}</span>
   <span class="n">free</span><span class="p">(</span><span class="n">tabla</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rellenarTabla3D</span><span class="p">(</span><span class="n">TTabla3D</span> <span class="n">tabla</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">,</span> <span class="n">dim3</span><span class="p">;</span>

   <span class="k">for</span><span class="p">(</span><span class="n">dim1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dim1</span> <span class="o">&lt;</span> <span class="n">X</span><span class="p">;</span> <span class="n">dim1</span><span class="o">++</span><span class="p">){</span>
      <span class="k">for</span><span class="p">(</span><span class="n">dim2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dim2</span> <span class="o">&lt;</span> <span class="n">Y</span><span class="p">;</span> <span class="n">dim2</span><span class="o">++</span><span class="p">){</span>
         <span class="k">for</span><span class="p">(</span><span class="n">dim3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dim3</span> <span class="o">&lt;</span> <span class="n">Z</span><span class="p">;</span> <span class="n">dim3</span><span class="o">++</span><span class="p">){</span>
            <span class="n">tabla</span><span class="p">[</span><span class="n">dim1</span><span class="p">][</span><span class="n">dim2</span><span class="p">][</span><span class="n">dim3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
         <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>La función <code>crearTabla3D</code> también se puede hacer pasando la <code>tabla3D</code> por referencia para poder reservar la memoria dinámicamente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">crear2Tabla3D</span><span class="p">(</span><span class="n">TTabla3D</span><span class="o">*</span><span class="p">);</span>
<span class="p">...</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="p">...</span>
   <span class="n">crear2Tabla3D</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tabla3D</span><span class="p">);</span>
   <span class="p">...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">crear2Tabla3D</span><span class="p">(</span><span class="n">TTabla3D</span> <span class="o">*</span><span class="n">tabla3D</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">,</span> <span class="n">dim3</span><span class="p">;</span>

   <span class="o">*</span><span class="n">tabla3D</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">***</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="o">**</span><span class="p">)</span> <span class="o">*</span> <span class="n">X</span><span class="p">);</span>

   <span class="k">for</span><span class="p">(</span><span class="n">dim1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dim1</span> <span class="o">&lt;</span> <span class="n">X</span><span class="p">;</span> <span class="n">dim1</span><span class="o">++</span><span class="p">){</span>
      <span class="p">(</span><span class="o">*</span><span class="n">tabla3D</span><span class="p">)[</span><span class="n">dim1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">Y</span><span class="p">);</span>
      <span class="k">for</span><span class="p">(</span><span class="n">dim2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dim2</span> <span class="o">&lt;</span> <span class="n">Y</span><span class="p">;</span> <span class="n">dim2</span><span class="o">++</span><span class="p">){</span>
         <span class="p">(</span><span class="o">*</span><span class="n">tabla3D</span><span class="p">)[</span><span class="n">dim1</span><span class="p">][</span><span class="n">dim2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">Z</span><span class="p">);</span>
         <span class="k">for</span><span class="p">(</span><span class="n">dim3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dim3</span> <span class="o">&lt;</span> <span class="n">Z</span><span class="p">;</span> <span class="n">dim3</span><span class="o">++</span><span class="p">){</span>
            <span class="p">(</span><span class="o">*</span><span class="n">tabla3D</span><span class="p">)[</span><span class="n">dim1</span><span class="p">][</span><span class="n">dim2</span><span class="p">][</span><span class="n">dim3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/*inicialización*/</span>
         <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h2 id="bibliografia">Bibliografía<a class="headerlink" href="#bibliografia" title="Permanent link">&para;</a></h2>
<ul>
<li>Capítulos 12.1 a 12.4 y 13.1 a 13.8 de "Programación en C, metodología, algoritmos y estructuras de datos", Luis Joyanes, Ignacio Zahonero</li>
</ul>
<hr />
<p>Programación 1, Grado de Robótica, curso 2019-20<br />
© Departamento Ciencia de la Computación e Inteligencia Artificial, Universidad de Alicante<br />
Cristina Pomares Puig</p>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.245445c6.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
    
  </body>
</html>