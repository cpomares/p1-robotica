{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Sitio web con los apuntes de teor\u00eda y pr\u00e1cticas de la asignatura Programaci\u00f3n 1 del Grado de Ingenier\u00eda Rob\u00f3tica de la Universidad de Alicante. Despliega el men\u00fa de la izquierda para consultar el contenido de la teor\u00eda y las pr\u00e1cticas.","title":"Home"},{"location":"Practicas/practica00/practica00.html","text":"Pr\u00e1ctica 0: Entorno Linux y herramientas \u00b6 Objetivos de esta pr\u00e1ctica \u00b6 Conocer y comprender las herramientas necesarias para la realizaci\u00f3n de un programa Aprender a manejar las herramientas y el entorno seleccionado para las pr\u00e1cticas Sistema Operativo: Linux Editor de textos: Geany Compilador: gcc Compilar y ejecutar un primer programa Depurar los fallos encontrados Realizar y probar un programa \u00b6 Para realizar y probar un programa, debemos implementar el programa usando un editor de textos Compilar el programa para obtener un ejecutable, usando un compilador Ejecutar el programa (ejecutable) desde el sistema operativo Existen numerosos IDEs, o entornos integrados de desarrollo, que facilitan la tarea del desarrollador, tales como Eclipse, NetBeans, Visual Studio, IntelIiJ, etc En las pr\u00e1cticas, usaremos Geany como alternativa ligera y de licencia GPL entre el resto de opciones Sistema operativo Linux \u00b6 Las pr\u00e1cticas se desarrollar\u00e1n bajo el Sistema Operativo Linux Es posible usarlo a trav\u00e9s de una \"m\u00e1quina virtual\", permite emular un Sistema Operativo. Por ejemplo, para lanzar Windows desde Linux o viceversa Es importante conocer los comandos b\u00e1sicos para usar el terminal, as\u00ed como algunos conceptos base Diferencias entre may\u00fasculas y min\u00fasculas (case sensitive) Separador de carpetas en una ruta: / (en lugar de \\) Terminal de Linux \u00b6 Lanzar la terminal Desde el icono \u201cTerminal\u201d Combinaci\u00f3n de teclas \u201cCtrl+Alt+T\u201d Prompt: s\u00edmbolo $ Indica que el terminal esta listo para recibir comandos Sistema de ficheros: Raiz: / Carpeta de usuario: /home/username \u00f3 ~ Algunos comandos del terminal de Linux \u00b6 ls \u00b6 Muestra el contenido del directorio actual (nombres de ficheros y directorios) Se puede usar con modificadores, por ejemplo, ls -l muestra m\u00e1s detalles cd \u00b6 Para cambiar de directorio: cd nombreDirectorio Si no se indica nombre de directorio, nos movemos al /home del usuario cd .. subir un nivel en la jerarqu\u00eda de directorios pwd \u00b6 Muestra el nombre de la ruta actuaL mkdir \u00b6 Para crear directorios nuevos: mkdir directorio rm \u00b6 Para borrar ficheros: rm prueba.c rmdir \u00b6 Para borrar directorios que est\u00e9n vac\u00edos: rmdir directorio Si no est\u00e1n vac\u00edos: rmdir -r directorio cp \u00b6 Copia ficheros entre distintos directorios del disco duro: cp fichero.c practica0/. mv \u00b6 Renombra ficheros: mv fichero.c nuevoNombre.c clear \u00b6 Borra la pantalla man \u00b6 Muestra ayuda de un comando de linux: man comando Para mostrar ayuda de una funci\u00f3n del lenguaje C: man 3 funcionC find \u00b6 Buscar ficheros o directorios: find -name <opciones_busqueda> sudo \u00b6 Lanzar un comando como superusuario: sudo comando Instalaci\u00f3n de programas en Linux \u00b6 Existen repositorios de aplicaciones similares a \"Google Play\" 1 apt install < nombre_aplicacion > Es necesario lanzarla como root 1 2 sudo apt install geany sudo apt install gcc Editor de textos Geany \u00b6 Gesti\u00f3n de ficheros y edici\u00f3n est\u00e1ndar Nuevo, guardar como, buscar, reemplazar Editor de textos \u201cenriquecido\u201d Palabras clave aparecen con un color resaltado Opciones para programar Construir \u2192 Compilar | Construir | Ejecutar Sobre el fichero actual que contiene el programa Vista inferior Mensajes de salida, errores, vista de terminal, etc. Construir \u2192 Compilar Equivalente al comando gcc -c programa.c Genera un programa en c\u00f3digo objeto programa.o Construir \u2192 Construir Equivalente al comando gcc -o programa programa.c Compilar y enlazar Generar\u00e1 un ejecutable llamado programa (sin extensi\u00f3n) Construir \u2192 Ejecutar Equivalente a la ejecuci\u00f3n desde consola ./ejecutable Nuestro primer programa \u00b6 Antes de empezar, crea una carpeta en el sistema para alojar todos los ficheros 1 2 mkdir practica0 cd practica0 Accede a Moodle donde se encuentran los ficheros necesarios para realizar esta pr\u00e1ctica Descarga el fichero firstProgram.c en la carpeta practica0 Abrirlo desde Geany: Compilar y estudiar los ficheros generados Construir y estudiar los ficheros generados Ejecutar Eliminar todos los ficheros salvo el .c original Compilar, enlazar y ejecutar desde l\u00ednea de comandos (terminal) \u00b6 Abrir de nuevo el terminal y realiza las siguientes acciones: Compilar \u00fanicamente: 1 gcc - c firstProgram . c Compilar y enlazar generando ejecutable: 1 gcc - o ejecutable firstProgram . c Ejecutar el fichero generado: 1 . / ejectuable Descubriendo errores \u00b6 Descarga en la carpeta el fichero firstProgramErrorA.c y firstProgramErrorB.c Para cada fichero: Abre el fichero desde Geany y estudia las diferencias con respecto al programa original Intenta compilar (a\u00f1adir la opci\u00f3n -Wall nos ayuda). F\u00edjate que el Geany utiliza esta opci\u00f3n al compilar (observa la ventana donde muestra el resultado de la compilaci\u00f3n). Despu\u00e9s, desde l\u00ednea de comandos compila con la opci\u00f3n -Wall y sin dicha opci\u00f3n, y entiende para qu\u00e9 sirve. Estudia la salida obtenida por el compilador o el programa si la compilaci\u00f3n termin\u00f3 con \u00e9xito Encuentra el error y corr\u00edgelo Depuraci\u00f3n de programas \u00b6 Dos tipos de errores: Sint\u00e1cticos: los detecta el compilador. Se solucionan f\u00e1cilmente L\u00f3gicos: se producen en el dise\u00f1o del programa o en la implementaci\u00f3n sin que suponga un error de sintaxis. MUY DIF\u00cdCILES DE SOLUCIONAR Herramienta para la detecci\u00f3n de errores: Depurador o debugger gdb Programa externo. Trabaja con el ejecutable A\u00f1adimos la opci\u00f3n -g al compilar con gcc para incluir informaci\u00f3n de depurado en el ejecutable Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2020-21 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Antonio Bot\u00eda, Cristina Pomares","title":"Pr\u00e1ctica 0: Entorno Linux y herramientas"},{"location":"Practicas/practica00/practica00.html#practica-0-entorno-linux-y-herramientas","text":"","title":"Pr\u00e1ctica 0: Entorno Linux y herramientas"},{"location":"Practicas/practica00/practica00.html#objetivos-de-esta-practica","text":"Conocer y comprender las herramientas necesarias para la realizaci\u00f3n de un programa Aprender a manejar las herramientas y el entorno seleccionado para las pr\u00e1cticas Sistema Operativo: Linux Editor de textos: Geany Compilador: gcc Compilar y ejecutar un primer programa Depurar los fallos encontrados","title":"Objetivos de esta pr\u00e1ctica"},{"location":"Practicas/practica00/practica00.html#realizar-y-probar-un-programa","text":"Para realizar y probar un programa, debemos implementar el programa usando un editor de textos Compilar el programa para obtener un ejecutable, usando un compilador Ejecutar el programa (ejecutable) desde el sistema operativo Existen numerosos IDEs, o entornos integrados de desarrollo, que facilitan la tarea del desarrollador, tales como Eclipse, NetBeans, Visual Studio, IntelIiJ, etc En las pr\u00e1cticas, usaremos Geany como alternativa ligera y de licencia GPL entre el resto de opciones","title":"Realizar y probar un programa"},{"location":"Practicas/practica00/practica00.html#sistema-operativo-linux","text":"Las pr\u00e1cticas se desarrollar\u00e1n bajo el Sistema Operativo Linux Es posible usarlo a trav\u00e9s de una \"m\u00e1quina virtual\", permite emular un Sistema Operativo. Por ejemplo, para lanzar Windows desde Linux o viceversa Es importante conocer los comandos b\u00e1sicos para usar el terminal, as\u00ed como algunos conceptos base Diferencias entre may\u00fasculas y min\u00fasculas (case sensitive) Separador de carpetas en una ruta: / (en lugar de \\)","title":"Sistema operativo Linux"},{"location":"Practicas/practica00/practica00.html#terminal-de-linux","text":"Lanzar la terminal Desde el icono \u201cTerminal\u201d Combinaci\u00f3n de teclas \u201cCtrl+Alt+T\u201d Prompt: s\u00edmbolo $ Indica que el terminal esta listo para recibir comandos Sistema de ficheros: Raiz: / Carpeta de usuario: /home/username \u00f3 ~","title":"Terminal de Linux"},{"location":"Practicas/practica00/practica00.html#algunos-comandos-del-terminal-de-linux","text":"","title":"Algunos comandos del terminal de Linux"},{"location":"Practicas/practica00/practica00.html#ls","text":"Muestra el contenido del directorio actual (nombres de ficheros y directorios) Se puede usar con modificadores, por ejemplo, ls -l muestra m\u00e1s detalles","title":"ls"},{"location":"Practicas/practica00/practica00.html#cd","text":"Para cambiar de directorio: cd nombreDirectorio Si no se indica nombre de directorio, nos movemos al /home del usuario cd .. subir un nivel en la jerarqu\u00eda de directorios","title":"cd"},{"location":"Practicas/practica00/practica00.html#pwd","text":"Muestra el nombre de la ruta actuaL","title":"pwd"},{"location":"Practicas/practica00/practica00.html#mkdir","text":"Para crear directorios nuevos: mkdir directorio","title":"mkdir"},{"location":"Practicas/practica00/practica00.html#rm","text":"Para borrar ficheros: rm prueba.c","title":"rm"},{"location":"Practicas/practica00/practica00.html#rmdir","text":"Para borrar directorios que est\u00e9n vac\u00edos: rmdir directorio Si no est\u00e1n vac\u00edos: rmdir -r directorio","title":"rmdir"},{"location":"Practicas/practica00/practica00.html#cp","text":"Copia ficheros entre distintos directorios del disco duro: cp fichero.c practica0/.","title":"cp"},{"location":"Practicas/practica00/practica00.html#mv","text":"Renombra ficheros: mv fichero.c nuevoNombre.c","title":"mv"},{"location":"Practicas/practica00/practica00.html#clear","text":"Borra la pantalla","title":"clear"},{"location":"Practicas/practica00/practica00.html#man","text":"Muestra ayuda de un comando de linux: man comando Para mostrar ayuda de una funci\u00f3n del lenguaje C: man 3 funcionC","title":"man"},{"location":"Practicas/practica00/practica00.html#find","text":"Buscar ficheros o directorios: find -name <opciones_busqueda>","title":"find"},{"location":"Practicas/practica00/practica00.html#sudo","text":"Lanzar un comando como superusuario: sudo comando","title":"sudo"},{"location":"Practicas/practica00/practica00.html#instalacion-de-programas-en-linux","text":"Existen repositorios de aplicaciones similares a \"Google Play\" 1 apt install < nombre_aplicacion > Es necesario lanzarla como root 1 2 sudo apt install geany sudo apt install gcc","title":"Instalaci\u00f3n de programas en Linux"},{"location":"Practicas/practica00/practica00.html#editor-de-textos-geany","text":"Gesti\u00f3n de ficheros y edici\u00f3n est\u00e1ndar Nuevo, guardar como, buscar, reemplazar Editor de textos \u201cenriquecido\u201d Palabras clave aparecen con un color resaltado Opciones para programar Construir \u2192 Compilar | Construir | Ejecutar Sobre el fichero actual que contiene el programa Vista inferior Mensajes de salida, errores, vista de terminal, etc. Construir \u2192 Compilar Equivalente al comando gcc -c programa.c Genera un programa en c\u00f3digo objeto programa.o Construir \u2192 Construir Equivalente al comando gcc -o programa programa.c Compilar y enlazar Generar\u00e1 un ejecutable llamado programa (sin extensi\u00f3n) Construir \u2192 Ejecutar Equivalente a la ejecuci\u00f3n desde consola ./ejecutable","title":"Editor de textos Geany"},{"location":"Practicas/practica00/practica00.html#nuestro-primer-programa","text":"Antes de empezar, crea una carpeta en el sistema para alojar todos los ficheros 1 2 mkdir practica0 cd practica0 Accede a Moodle donde se encuentran los ficheros necesarios para realizar esta pr\u00e1ctica Descarga el fichero firstProgram.c en la carpeta practica0 Abrirlo desde Geany: Compilar y estudiar los ficheros generados Construir y estudiar los ficheros generados Ejecutar Eliminar todos los ficheros salvo el .c original","title":"Nuestro primer programa"},{"location":"Practicas/practica00/practica00.html#compilar-enlazar-y-ejecutar-desde-linea-de-comandos-terminal","text":"Abrir de nuevo el terminal y realiza las siguientes acciones: Compilar \u00fanicamente: 1 gcc - c firstProgram . c Compilar y enlazar generando ejecutable: 1 gcc - o ejecutable firstProgram . c Ejecutar el fichero generado: 1 . / ejectuable","title":"Compilar, enlazar y ejecutar desde  l\u00ednea de comandos (terminal)"},{"location":"Practicas/practica00/practica00.html#descubriendo-errores","text":"Descarga en la carpeta el fichero firstProgramErrorA.c y firstProgramErrorB.c Para cada fichero: Abre el fichero desde Geany y estudia las diferencias con respecto al programa original Intenta compilar (a\u00f1adir la opci\u00f3n -Wall nos ayuda). F\u00edjate que el Geany utiliza esta opci\u00f3n al compilar (observa la ventana donde muestra el resultado de la compilaci\u00f3n). Despu\u00e9s, desde l\u00ednea de comandos compila con la opci\u00f3n -Wall y sin dicha opci\u00f3n, y entiende para qu\u00e9 sirve. Estudia la salida obtenida por el compilador o el programa si la compilaci\u00f3n termin\u00f3 con \u00e9xito Encuentra el error y corr\u00edgelo","title":"Descubriendo errores"},{"location":"Practicas/practica00/practica00.html#depuracion-de-programas","text":"Dos tipos de errores: Sint\u00e1cticos: los detecta el compilador. Se solucionan f\u00e1cilmente L\u00f3gicos: se producen en el dise\u00f1o del programa o en la implementaci\u00f3n sin que suponga un error de sintaxis. MUY DIF\u00cdCILES DE SOLUCIONAR Herramienta para la detecci\u00f3n de errores: Depurador o debugger gdb Programa externo. Trabaja con el ejecutable A\u00f1adimos la opci\u00f3n -g al compilar con gcc para incluir informaci\u00f3n de depurado en el ejecutable Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2020-21 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Antonio Bot\u00eda, Cristina Pomares","title":"Depuraci\u00f3n de programas"},{"location":"Teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html","text":"Programaci\u00f3n 1. Grado de Rob\u00f3tica. Curso 2020-2021 \u00b6 Toda la informaci\u00f3n est\u00e1 disponible en el sitio Moodle de P1 y en la gu\u00eda docente de P1 . Datos acad\u00e9micos de la asignatura \u00b6 Departamento de Ciencia de la Computaci\u00f3n e Inteligencia Artificial 6 cr\u00e9ditos ECTS : 1 clase de teor\u00eda de 2 h. y 1 clase de pr\u00e1cticas de 2 h. a la semana Profesores : Antonio Bot\u00eda ( e-mail ): Grupos de pr\u00e1cticas: 1 y 4. Cristina Pomares ( e-mail ): Grupo de teor\u00eda 1 y grupos de pr\u00e1cticas: 2 y 3. Recursos de la asignatura \u00b6 Ficha de la asignatura Apuntes de la asignatura (teor\u00eda y pr\u00e1cticas) Sitio Moodle contiene los apuntes, transparencias, pr\u00e1cticas y otros materiales docentes Foro de consultas y anuncios en el sitio Moodle Objetivos y competencias \u00b6 Objetivos : Dominar los principios de la programaci\u00f3n procedural. Resolver problemas de programaci\u00f3n b\u00e1sica aplicando adecuadamente los tipos de datos elementales, los tipos de datos estructurados y las estructuras de control. Asimilar el concepto programaci\u00f3n modular y saber aplicarlo en la resoluci\u00f3n de problemas. Conocer el concepto de recursividad, aplic\u00e1ndolo a problemas sencillos. Comprender el concepto de fichero y saber utilizarlos. Ser capaz de utilizar herramientas de programaci\u00f3n para editar, compilar, ejecutar y verificar un programa. Analizar problemas susceptibles de resoluci\u00f3n por un ordenador y dise\u00f1ar algoritmos que los solucionen. Implementar algoritmos mediante t\u00e9cnicas de programaci\u00f3n estructurada y modular. Saber realizar programas de ordenador que capturen y env\u00eden informaci\u00f3n a un sistema rob\u00f3tico. Competencias : Interpretar el funcionamiento del c\u00f3digo fuente de un programa. Definir los tipos de datos necesarios para la representaci\u00f3n de la informaci\u00f3n. Dise\u00f1ar algoritmos y codificarlos con distintas t\u00e9cnicas de programaci\u00f3n, especialmente en sistemas rob\u00f3ticos. Verificar el correcto funcionamiento de un programa. Temario \u00b6 Tema 1. Introducci\u00f3n a la programaci\u00f3n : Representaci\u00f3n de la informaci\u00f3n. Concepto de programa. Fases de desarrollo de un programa. El lenguaje C. Estructura de un programa. Comentarios en un programa. Entornos de programaci\u00f3n. Tema 2. Tipos de datos simples : Concepto de dato. Constantes y variables. Sentencias de asignaci\u00f3n. Expresiones y operadores. Sentencias de entrada/salida de datos. Tema 3. Sentencias de control : Algoritmos y programas. Estructura secuencial. Estructuras de selecci\u00f3n. Estructuras de repetici\u00f3n. Tema 4. Programaci\u00f3n modular : Descomposici\u00f3n modular. Concepto de m\u00f3dulo. Comunicaci\u00f3n entre m\u00f3dulos. Funciones. Par\u00e1metros actuales y formales. Paso de par\u00e1metros por valor y por referencia. \u00c1mbito de una variable. Variables globales y locales. Efecto lateral. Funciones predefinidas Tema 5. Tipos de datos estructurados: Arrays : Concepto de dato estructurado. El tipo array. Arrays unidimensionales, bidimensionales y multidimensionales. Cadenas de caracteres Tema 6. Tipos de datos estructurados: Registros : Concepto de registro. Registros en C. Operaciones sobre registros. Arrays de registro Tema 7. Punteros y memoria din\u00e1mica : Memoria est\u00e1tica vs. din\u00e1mica. Creaci\u00f3n, inicializaci\u00f3n, asignaci\u00f3n y liberaci\u00f3n de memoria. Conversi\u00f3n de tipos. Tema 8. Entrada/salida : Declaraci\u00f3n, apertura, lectura y escritura de ficheros de texto y binarios en C. Tema 9. Recursi\u00f3n : Definici\u00f3n. Esquema b\u00e1sico. Codificaci\u00f3n en C. Caracter\u00edsticas Pr\u00e1cticas \u00b6 Durante las clases pr\u00e1cticas se realizar\u00e1n de forma individual ejercicios de programaci\u00f3n relacionados con los conceptos que se est\u00e1n estudiando en ese momento que servir\u00e1n para reforzar y profundizar en las competencias de la asignatura. Horarios \u00b6 La distribuci\u00f3n de grupos del curso 2020-2021 es la siguiente: Evaluaci\u00f3n \u00b6 Convocatoria normal (evaluaci\u00f3n continua) En la convocatoria ordinaria (enero) se realizar\u00e1 una evaluaci\u00f3n continua con las siguientes pruebas: Examen 1 : Del tema 1 al tema 5. Pondera un 50% en la nota final. No se exige nota m\u00ednima. Mi\u00e9rcoles 25 de Noviembre (fecha de examen aproximada, a la espera de que nos asignen aulas). Examen 2 : Del tema 1 al tema 9. Pondera un 50% en la nota final. No se exige nota m\u00ednima. Se realizar\u00e1 en la fecha oficial asignada al examen final de la convocatoria de enero. Todos los ex\u00e1menes de la asignatura se realizar\u00e1n por escrito e incluir\u00e1n conceptos y ejercicios relacionados con los trabajados tanto en las sesiones de teor\u00eda como de pr\u00e1cticas. La realizaci\u00f3n de las pr\u00e1cticas es imprescindible para el aprendizaje de los conceptos, t\u00e9cnicas de la asignatura y para la preparaci\u00f3n de las pruebas en las que se evaluar\u00e1n los conocimientos adquiridos. Convocatoria extraordinaria En la convocatoria extraordinaria se realizar\u00e1 un examen final escrito sobre todos los bloques tem\u00e1ticos cuya calificaci\u00f3n representar\u00e1 el 100% de la nota de la asignatura. Plagios Los trabajos te\u00f3rico/pr\u00e1cticos realizados han de ser originales. La detecci\u00f3n de copia o plagio supondr\u00e1 la calificaci\u00f3n de \"0\" en la prueba correspondiente. Se informar\u00e1 la direcci\u00f3n de Departamento y de la EPS sobre esta incidencia. La reiteraci\u00f3n en la conducta en esta u otra asignatura conllevar\u00e1 la notificaci\u00f3n al vicerrectorado correspondiente de las faltas cometidas para que estudien el caso y sancionen seg\u00fan la legislaci\u00f3n. Consejos para aprender con \u00e9xito los contenidos de la asignatura El consejo fundamental para aprobar la asignatura es trabajar todas las semanas y realizar por ti mismo los ejercicios . Los conceptos de la asignatura se van construyendo de forma progresiva y lo visto en una semana depende muchas veces de lo aprendido en semanas anteriores. La asignatura es fundamentalmente pr\u00e1ctica. Para estudiar una asignatura de programaci\u00f3n, no debes memorizar sino entender. No tiene sentido aprender de memoria los ejercicios y los ejemplos vistos en clase. Hay que trabajarlos. La \u00fanica forma de aprender es: probando, equivoc\u00e1ndose y encontrando la soluci\u00f3n por uno mismo. A la hora de enfrentarse con un problema es fundamental tambi\u00e9n usar l\u00e1piz y papel para plasmar las ideas y encontrar la soluci\u00f3n m\u00e1s sencilla antes de programarla en el ordenador. Resumiendo: trabajar todas las semanas, hacer uno mismo todos los ejercicios y no desanimarse ni descolgarse. Son muy interesantes algunos comentarios de antiguos estudiantes que han aprobado la asignatura. \u00bfQu\u00e9 hiciste para superar con \u00e9xito P1? \u00bfQu\u00e9 consejos les das a los nuevos alumnos? Practicar, practicar y practicar. Los profesores os lo repetir\u00e1n mucho, pero es la soluci\u00f3n clave para poder superar la asignatura. Tambi\u00e9n entender el por qu\u00e9 de los errores [...] Una de las claves para superar esta asignatura es ser constante y no dejar atr\u00e1s ning\u00fan concepto sin entender (ya que concepto que das en un tema en el siguiente te ayudar\u00e1 ) y sobre todo practicar y practicar, para asentar bien los conocimientos expuestos en las clases de teor\u00eda[...] No estudi\u00e9is los ejercicios de memoria. Programaci\u00f3n se aprende, no se memoriza[...] No dej\u00e9is todo para \u00faltima hora porque la clave es llevar las cosas y conceptos explicados en teor\u00eda al d\u00eda. Adem\u00e1s, tambi\u00e9n aconsejar\u00eda que practicaran ya no solo con las practicas de clase sino tambi\u00e9n con m\u00e1s ejercicios para asentar bien todo. Y por \u00faltimo, que no se frustren si al principio les cuesta o no entienden bien lo que se explica, ya que puede que muchos no hayan dado nada de programaci\u00f3n antes (como fue mi caso), pero no por ello les ser\u00e1 imposible aprobar[...] Intentad que no se os atasque en lo b\u00e1sico, porque sino luego avanzar es muy complicado. Lo recomendable aun que suene a lo t\u00edpico es llevarlo bastante al d\u00eda y practicar por ti mismo haciendo programas[...] Yo creo que es indispensable hacer las pr\u00e1cticas, pues en las clases te\u00f3ricas todo parece muy sencillo y l\u00f3gico, pero todo cambia cuando te sientas delante de la pantalla y empiezas a escribir c\u00f3digo. Lo importante para realizar de manera eficiente las pr\u00e1cticas es hacer un peque\u00f1o esquema en sucio de qu\u00e9 es lo que quieres hacer y c\u00f3mo piensas hacerlo, pues de esa forma las ideas quedan mucho m\u00e1s claras y hay menos posibilidad de equivocarse[...] Es totalmente necesario hacer las pr\u00e1cticas, porque de este modo los profesores pueden resolver las dudas en el momento, y tambi\u00e9n sirven para aprender los nuevos contenidos y repasar para el examen[...] Bibliograf\u00eda \u00b6 En Moodle se publican los apuntes de la asignatura, con ejercicios, explicaciones y ejemplos de todos los conceptos estudiados, tanto en teor\u00eda como en pr\u00e1ctica. Los apuntes de la asignatura se han confeccionado utilizando la siguiente bibliograf\u00eda, que pod\u00e9is utilizar para consultar o ampliar algunos conceptos: JOYANES, Luis; ZAHONERO, Ignacio. Programaci\u00f3n en C. Metodolog\u00eda, algoritmos y estructuras de datos. McGraw-Hill, 2a edici\u00f3n, 2005. ISBN: 8448198441 CARRETERO P\u00e9rez, Jes\u00fas. Fundamentos de programaci\u00f3n. 2007. ISBN: 9788497325509 Carballeira. Problemas resueltos de programaci\u00f3n en lenguaje C KERNIGHAN, Brian W.; RITCHIE, Dennis M. El lenguaje de programaci\u00f3n C. Pearson Educaci\u00f3n, 1991. ISBN: 968-880-205-0 Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2020-21 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares","title":"Descripci\u00f3n de la asignatura"},{"location":"Teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#programacion-1-grado-de-robotica-curso-2020-2021","text":"Toda la informaci\u00f3n est\u00e1 disponible en el sitio Moodle de P1 y en la gu\u00eda docente de P1 .","title":"Programaci\u00f3n 1. Grado de Rob\u00f3tica. Curso 2020-2021"},{"location":"Teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#datos-academicos-de-la-asignatura","text":"Departamento de Ciencia de la Computaci\u00f3n e Inteligencia Artificial 6 cr\u00e9ditos ECTS : 1 clase de teor\u00eda de 2 h. y 1 clase de pr\u00e1cticas de 2 h. a la semana Profesores : Antonio Bot\u00eda ( e-mail ): Grupos de pr\u00e1cticas: 1 y 4. Cristina Pomares ( e-mail ): Grupo de teor\u00eda 1 y grupos de pr\u00e1cticas: 2 y 3.","title":"Datos acad\u00e9micos de la asignatura"},{"location":"Teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#recursos-de-la-asignatura","text":"Ficha de la asignatura Apuntes de la asignatura (teor\u00eda y pr\u00e1cticas) Sitio Moodle contiene los apuntes, transparencias, pr\u00e1cticas y otros materiales docentes Foro de consultas y anuncios en el sitio Moodle","title":"Recursos de la asignatura"},{"location":"Teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#objetivos-y-competencias","text":"Objetivos : Dominar los principios de la programaci\u00f3n procedural. Resolver problemas de programaci\u00f3n b\u00e1sica aplicando adecuadamente los tipos de datos elementales, los tipos de datos estructurados y las estructuras de control. Asimilar el concepto programaci\u00f3n modular y saber aplicarlo en la resoluci\u00f3n de problemas. Conocer el concepto de recursividad, aplic\u00e1ndolo a problemas sencillos. Comprender el concepto de fichero y saber utilizarlos. Ser capaz de utilizar herramientas de programaci\u00f3n para editar, compilar, ejecutar y verificar un programa. Analizar problemas susceptibles de resoluci\u00f3n por un ordenador y dise\u00f1ar algoritmos que los solucionen. Implementar algoritmos mediante t\u00e9cnicas de programaci\u00f3n estructurada y modular. Saber realizar programas de ordenador que capturen y env\u00eden informaci\u00f3n a un sistema rob\u00f3tico. Competencias : Interpretar el funcionamiento del c\u00f3digo fuente de un programa. Definir los tipos de datos necesarios para la representaci\u00f3n de la informaci\u00f3n. Dise\u00f1ar algoritmos y codificarlos con distintas t\u00e9cnicas de programaci\u00f3n, especialmente en sistemas rob\u00f3ticos. Verificar el correcto funcionamiento de un programa.","title":"Objetivos y competencias"},{"location":"Teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#temario","text":"Tema 1. Introducci\u00f3n a la programaci\u00f3n : Representaci\u00f3n de la informaci\u00f3n. Concepto de programa. Fases de desarrollo de un programa. El lenguaje C. Estructura de un programa. Comentarios en un programa. Entornos de programaci\u00f3n. Tema 2. Tipos de datos simples : Concepto de dato. Constantes y variables. Sentencias de asignaci\u00f3n. Expresiones y operadores. Sentencias de entrada/salida de datos. Tema 3. Sentencias de control : Algoritmos y programas. Estructura secuencial. Estructuras de selecci\u00f3n. Estructuras de repetici\u00f3n. Tema 4. Programaci\u00f3n modular : Descomposici\u00f3n modular. Concepto de m\u00f3dulo. Comunicaci\u00f3n entre m\u00f3dulos. Funciones. Par\u00e1metros actuales y formales. Paso de par\u00e1metros por valor y por referencia. \u00c1mbito de una variable. Variables globales y locales. Efecto lateral. Funciones predefinidas Tema 5. Tipos de datos estructurados: Arrays : Concepto de dato estructurado. El tipo array. Arrays unidimensionales, bidimensionales y multidimensionales. Cadenas de caracteres Tema 6. Tipos de datos estructurados: Registros : Concepto de registro. Registros en C. Operaciones sobre registros. Arrays de registro Tema 7. Punteros y memoria din\u00e1mica : Memoria est\u00e1tica vs. din\u00e1mica. Creaci\u00f3n, inicializaci\u00f3n, asignaci\u00f3n y liberaci\u00f3n de memoria. Conversi\u00f3n de tipos. Tema 8. Entrada/salida : Declaraci\u00f3n, apertura, lectura y escritura de ficheros de texto y binarios en C. Tema 9. Recursi\u00f3n : Definici\u00f3n. Esquema b\u00e1sico. Codificaci\u00f3n en C. Caracter\u00edsticas","title":"Temario"},{"location":"Teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#practicas","text":"Durante las clases pr\u00e1cticas se realizar\u00e1n de forma individual ejercicios de programaci\u00f3n relacionados con los conceptos que se est\u00e1n estudiando en ese momento que servir\u00e1n para reforzar y profundizar en las competencias de la asignatura.","title":"Pr\u00e1cticas"},{"location":"Teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#horarios","text":"La distribuci\u00f3n de grupos del curso 2020-2021 es la siguiente:","title":"Horarios"},{"location":"Teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#evaluacion","text":"","title":"Evaluaci\u00f3n"},{"location":"Teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#bibliografia","text":"En Moodle se publican los apuntes de la asignatura, con ejercicios, explicaciones y ejemplos de todos los conceptos estudiados, tanto en teor\u00eda como en pr\u00e1ctica. Los apuntes de la asignatura se han confeccionado utilizando la siguiente bibliograf\u00eda, que pod\u00e9is utilizar para consultar o ampliar algunos conceptos: JOYANES, Luis; ZAHONERO, Ignacio. Programaci\u00f3n en C. Metodolog\u00eda, algoritmos y estructuras de datos. McGraw-Hill, 2a edici\u00f3n, 2005. ISBN: 8448198441 CARRETERO P\u00e9rez, Jes\u00fas. Fundamentos de programaci\u00f3n. 2007. ISBN: 9788497325509 Carballeira. Problemas resueltos de programaci\u00f3n en lenguaje C KERNIGHAN, Brian W.; RITCHIE, Dennis M. El lenguaje de programaci\u00f3n C. Pearson Educaci\u00f3n, 1991. ISBN: 968-880-205-0 Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2020-21 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares","title":"Bibliograf\u00eda"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html","text":"Tema 1: Introducci\u00f3n a la programaci\u00f3n \u00b6 1. Lenguajes de programaci\u00f3n \u00b6 Un lenguaje de programaci\u00f3n permite especificar procesos que se ejecutan en computadores. Un programa escrito en un determinado lenguaje nos permite definir las instrucciones que realizar\u00e1 el ordenador (o, m\u00e1s en concreto, el procesador) que lo ejecute. Por ello, para entender en profundidad qu\u00e9 es un lenguaje de programaci\u00f3n es fundamental conocer el ordenador. 1.1. El ordenador y sus componentes \u00b6 Lor ordenadores poseen los siguientes componentes: Dispositivos de entrada . Se encargan de capturar informacio\u0301n de entrada a la computadora: teclado, rato\u0301n, micro\u0301fono, etc. Dispositivos de salida . Se encargan de la salida de informacio\u0301n de la computadora: monitor, impresora, altavoces, etc. Dispositivos de almacenamiento . Se encargan de almacenar los datos para su uso posterior: disco duro, CD-ROM, etc. Unidad de Procesamiento . Realiza las operaciones con los datos Memoria principal . Es donde se almacenan temporalmente los datos con los que la CPU trabaja en cada momento. Est\u00e1 formada por circuitos electr\u00f3nicos integrados capaces de almacenar valores binarios (0 \u00f3 1) en cada celda de memoria Memoria principal: Palabra de memoria: menor conjunto de celdas de memoria que se pueden leer o escribir simult\u00e1neamente. En el ejemplo, cada palabra es de 1 byte (8 bits) Direcci\u00f3n de memoria: n\u00famero que identifica de forma un\u00edvoca cada palabra de memoria 1.2. Representaci\u00f3n de la informaci\u00f3n \u00b6 La informacio\u0301n se representa en una computadora mediante el uso de dos estados: ausencia y presencia de corriente. Esto se debe a la naturaleza ele\u0301ctrica de la misma: Esta dualidad nos permite adoptar un sistema binario para representar la informacio\u0301n. Asi\u0301, la presencia de sen\u0303al se representa por el 1 y la ausencia por el 0. Esto nos lleva al concepto de bit , que es la unidad mi\u0301nima de informacio\u0301n. Un bit puede adoptar los valores 0 o\u0301 1. Un u\u0301nico bit aporta poca cantidad de informacio\u0301n. Es por ello que los bits se agrupan de 8 en 8 formando un byte . Un byte permite representar 2^8 = 256 combinaciones diferentes. A su vez, los bytes se agrupan formando palabras , que dependiendo de cada computadora pueden ser de 8, 16, 32 o\u0301 64 bytes . 1.3. Programa \u00b6 Un programa es el conjunto ordenado de instrucciones que indican a la computadora las acciones que debe realizar para cumplir una tarea especi\u0301fica. En este sentido, con un programa especificamos al ordenador que\u0301 tiene que hacer, en el orden en el que lo tiene que hacer y los datos que ha de usar para ello. Los programas esta\u0301n escritos en un determinado lenguaje formal libre de ambigu\u0308edades, de forma que la especificacio\u0301n de lo que queremos hacer sea uni\u0301voca. Con respecto al nivel de abstraccio\u0301n de estos lenguajes, los podemos clasificar en dos grandes grupos: Lenguajes Ma\u0301quina : Como su propio nombre indica, se trata de los lenguajes \"nativos\" de la computadora, y por ello es capaz de procesarlos directamente. Sumamente costosos para el programador. Lenguajes de Alto Nivel : Se trata de lenguajes mucho ma\u0301s cercanos al lenguaje humano, con un alto nivel de abstracci\u00f3n, por lo que son ma\u0301s comprensibles y menos engorrosos de usar para el programador. Los programas construidos con estos lenguajes han de ser traducidos a lenguaje ma\u0301quina mediante el uso de un compilador para que la computadora los pueda procesar. Python, C, C++, Java, etc. 1.4. Los primeros lenguajes de programaci\u00f3n \u00b6 Los primeros computadores electr\u00f3nicos se programan directamente usando el conjunto de instrucciones del procesador, en c\u00f3digo m\u00e1quina , c\u00f3digo hexadecimal. El siguiente programa, en lenguaje ma\u0301quina, resta un nu\u0301mero de otro y el resultado lo almacena en una posicio\u0301n de memoria: El primer lenguaje de un nivel algo m\u00e1s elevado que el c\u00f3digo m\u00e1quina es el ensamblador . Programas que empiezan a ayudar a los programadores: ensambladores. Hay una relaci\u00f3n casi directa entre la notaci\u00f3n en ensamblador y el c\u00f3digo hexadecimal que produce el ensamblador. El programa anterior en ensamblador seri\u0301a: 1 2 3 4 5 6 7 CAR A RES B ALM C STOP C : 0 A : 7 B : 2 El lenguaje ensamblador constituye un gran avance en lo que a facilidad de comprensio\u0301n se requiere a la hora de programar. De todas formas, este lenguaje sigue teniendo varios inconvenientes: Por un lado, cada computadora posee un lenguaje ensamblador distinto, por lo que para utilizar un programa en otra computadora distinta habri\u0301a que rescribirlo. Por otro lado, el lenguaje sigue siendo demasiado cercano al lenguaje ma\u0301quina, lo que dificulta su comprensio\u0301n y por tanto encarece el desarrollo de programas de gran extensio\u0301n. Los lenguajes de alto nivel se caracterizan por no ser dependientes de ma\u0301quina. Mediante la compilacio\u0301n de un programa escrito en lenguaje de alto nivel podremos ejecutarlo en cualquier ma\u0301quina. Para ello, necesitaremos un compilador de ese lenguaje para cada ma\u0301quina en la que queramos ejecutar nuestro programa. Otra caracteri\u0301stica de estos lenguajes es su sintaxis es m\u00e1s cercana al lenguaje natural del programador y proporciona distintas herramientas de abstracci\u00f3n que facilitan la programaci\u00f3n. 1.5. Los primeros lenguajes de alto nivel \u00b6 Los primeros lenguajes de alto nivel se desarrollaron a finales de la d\u00e9cada de los 50: FORTRAN en 1956 Lisp en 1958 Ambos lenguajes planteaban dos enfoques muy distintos desde el principio y fueron la base y la influencia del desarrollo de numerosos lenguajes posteriores. Desde 1954 hasta la actualidad se han documentado m\u00e1s de 2.500 (consultar en The Language List ). Genealog\u00eda de los lenguajes de programaci\u00f3n El lenguaje C surgi\u00f3 en 1972, derivado de Fortran y Algol. Es el que vamos a estudiar en esta asignatura. El lenguaje Python surgi\u00f3 en 1991, a partir de Lisp y C. 1.6. Compiladores e int\u00e9rpretes \u00b6 En el nivel de abstracci\u00f3n m\u00e1s bajo, la ejecuci\u00f3n de un programa en un computador consiste en la ejecuci\u00f3n de un conjunto de instrucciones del c\u00f3digo m\u00e1quina del procesador. Compilaci\u00f3n La siguiente figura muestra el proceso de generaci\u00f3n y ejecuci\u00f3n de un programa compilado. Compilaci\u00f3n El proceso de compilaci\u00f3n de un programa consiste en la traducci\u00f3n del c\u00f3digo fuente original en el lenguaje de alto nivel al c\u00f3digo m\u00e1quina espec\u00edfico del procesador en el que va a ejecutarse el programa. El c\u00f3digo m\u00e1quina resultante s\u00f3lo corre en el procesador para el que se ha generado. Por ejemplo, un programa C compilado para un procesador Intel no puede ejecutarse en un procesador ARM, como los Ax de Apple . Ejemplos: C, C++ Diferentes momentos en la vida de un programa: tiempo de compilaci\u00f3n y tiempo de ejecuci\u00f3n Mayor eficiencia Interpretaci\u00f3n Interpretaci\u00f3n Ejemplos: Lisp, Python, Ruby No hay diferencia entre el tiempo de compilaci\u00f3n y el tiempo de ejecuci\u00f3n Mayor flexibilidad Los lenguajes interpretados suelen proporcionar un shell o int\u00e9rprete. Se trata de un entorno interactivo en el que podemos definir y evaluar expresiones. Este entorno se denomina en los c\u00edrculos de programaci\u00f3n funcional un REPL ( Read , Eval , Print , Loop ) y ya se utiliz\u00f3 en los primeros a\u00f1os de implementaci\u00f3n del Lisp. El uso del REPL promueve una programaci\u00f3n interactiva en la que continuamente evaluamos y comprobamos el c\u00f3digo que desarrollamos. Enfoques mixtos Existen tambi\u00e9n enfoques mixtos, como el usado por el lenguaje de programaci\u00f3n Java, en el que se realizan ambos procesos: por un lado, el compilador ( javac ) traduce el c\u00f3digo fuente original a un c\u00f3digo intermedio binario (multiplataforma), que es interpretado posteriormente por el int\u00e9rprete ( java ). Enfoque mixto (Java) Ejemplos: Java, Scala 2. Lenguaje C \u00b6 C es el lenguaje principal que vamos a estudiar en la asignatura, pero vamos a ver tambi\u00e9n algunos ejemplos en Python. C presenta ciertas caracter\u00edsticas que permiten ejercer un elevado control sobre la eficiencia de los programas, tanto en la velocidad de ejecuci\u00f3n como en el consumo de memoria, pero a un precio importante: tenemos que proporcionar informaci\u00f3n expl\u00edcita sobre gran cantidad de detalles, por lo que generalmente resultan programas m\u00e1s largos y complicados que sus equivalentes en otros lenguajes m\u00e1s modernos, aumentando as\u00ed la probabilidad de que cometamos errores. C es un lenguaje compilado: antes de ejecutar un programa escrito por nosotros, suministramos su c\u00f3digo fuente (en un fichero con extensi\u00f3n .c) a un compilador de C. El compilador lee y analiza todo el programa. Si el programa est\u00e1 correctamente escrito seg\u00fan la definici\u00f3n del lenguaje, el compilador genera un nuevo fichero con su traducci\u00f3n a c\u00f3digo de m\u00e1quina (llamado programa objeto), y si no, muestra los errores que ha detectado. Para ejecutar el programa utilizamos el nombre del fichero generado. Si no modificamos el c\u00f3digo fuente, no hace falta que lo compilemos nuevamente para volver a ejecutar el programa: basta con volver a ejecutar el fichero generado por el compilador. La principal ventaja de compilar los programas es que se gana en velocidad de ejecuci\u00f3n, ya que cuando el programa se ejecuta est\u00e1 completamente traducido a c\u00f3digo de m\u00e1quina y se ahorra el proceso de traducci\u00f3n simult\u00e1nea que conlleva interpretar un programa. Pero, adem\u00e1s, como se traduce a c\u00f3digo m\u00e1quina en una fase independiente de la fase de ejecuci\u00f3n, el programa traductor puede dedicar m\u00e1s tiempo a intentar encontrar la mejor traducci\u00f3n posible, la que proporcione el programa de c\u00f3digo m\u00e1quina m\u00e1s r\u00e1pido (o que consuma menos memoria). 2.1. Desarrollo de programas en lenguaje C \u00b6 Cuando se implementa un programa, en primer lugar editamos el c\u00f3digo fuente con un editor. Estos archivos contienen la implementaci\u00f3n del programa en un determinado lenguaje, pero no se pueden ejecutar directamente. Para ello necesitamos compilar los programas oara obtener el c\u00f3digo objeto , que es un c\u00f3digo en binario intermedio que puede enlazarse con otros m\u00f3ulos ya compilados o con bibliotecas para obtener un c\u00f3digo ejecutable . Este \u00faltimo es un fichero que se puede ejecutar directamente. Este proceso es un ciclo, de forma que si despu\u00e9s de ejecutar el programa hemos encontrado errores, volvemos a editar el programa, compilarlo y ejecutarlo. Compilador : un programa que lee un c\u00f3digo fuente y lo traduce a c\u00f3digo objeto (ensamblador o binario). Enlazador : combina archivos objeto y bibliotecas de forma que se puedan ejecutar en una sola unidad. Ejemplo de programa en C: 1 2 3 4 5 6 7 8 #include <stdio.h> int main () { printf ( \"Hola mundo!! \\n \" ); return 0 ; } Vamos a analizar este primer programa: La primera l\u00ednea #include <stdio.h> se debe incluir al principio de cada programa. Incluye las funciones de entrada y salida, por ejemplo la instrucci\u00f3n printf . La l\u00ednea int main() indica la funci\u00f3n principal main , es un nombre especial que indica d\u00f3nde empieza el programa su ejecuci\u00f3n. Los par\u00e9ntesis tanto de main como de printf indican que ambas son funciones, y dentro de los par\u00e9ntesis ir\u00e1n los argumentos de las mismas (si los tienen). El argumento de printf es la cadena de caracteres \"Hola mundo!!\\n\" . La instrucci\u00f3n printf es una funci\u00f3n que imprime su argumento por pantalla, en este caso \"Hola mundo\" . Los \u00faltimos dos caracteres de la cadena `\\n' indican el car\u00e1cter newline o salto de l\u00ednea. Todas las instrucciones en C terminan en un ; . La \u00faltima sentencia return 0; indica que se termina la ejecuci\u00f3n de main , y devuelve al sistema el valor 0. El cero es un valor que se usa para indicar que el programa ha terminado correctamente (sin errores). La devoluci\u00f3n de un n\u00famero distinto de cero indican distintos errores (por ejemplo que no se encuentra un fichero). Vamos a compilar y ejecutar nuestro primer programa. Son tres pasos: A partir del fichero de texto con nuestro programa con el co\u0301digo fuente en lenguaje C se realiza una fase de preprocesado en la que se eliminan comentarios y se satisfacen directivas # gcc -\u00adE holamundo.c Una vez preprocesado se genera un fichero con co\u0301digo objeto en el paso de compilacio\u0301n gcc -\u00adc holaMundo.c . Nos genera holaMundo.o El fichero objeto se debe enlazar con las libreri\u0301as para generar el ejecutable en el paso de enlazado. Esto se puede realizar con una instruccio\u0301n: gcc holaMundo.c \u00ad-o holaMundo Su forma de uso m\u00e1s b\u00e1sica es \u00e9sta (agrupamos los pasos anteriores en una \u00fanica instrucci\u00f3n): gcc -o holamundo holamundo.c La opci\u00f3n -o es abreviatura de output , y a ella le sigue el nombre del fichero que contendr\u00e1 la traducci\u00f3n a c\u00f3digo m\u00e1quina del programa. Este fichero s\u00f3lo se genera si el programa C est\u00e1 correctamente escrito y no tiene errores de compilaci\u00f3n. Ahora ejecutamos el fichero ejecutable: ./holamundo y el resultado es la salida por pantalla: Hola mundo!! Diferencias entre C y Python C es un lenguaje imperativo. Python es multiparadigma (imperativo, orientado a objetos y funcional). C es un lenguaje compilado. Python es interpretado. En C, el programador tiene que hacer la gesti\u00f3n de memoria (reservar, liberar, etc). Python tiene recolector de basura autom\u00e1tico para la gesti\u00f3n de memoria. C es fuertemente tipado (obligatorio declarar el tipo de las variables). Python es d\u00e9bilmente tipado. La sintaxis de C es m\u00e1s compleja. La sintaxis de Python es m\u00e1s sencilla y sus programas son m\u00e1s f\u00e1ciles de escribir y depurar. 2.2. Aprender a programar \u00b6 A programar se aprende programando . En esta asignatura os dar\u00e9is cuenta que no sirve de nada memorizar programas, ni mirar ejercicios resueltos o soluciones a las pr\u00e1cticas planteadas. Deb\u00e9is empezar desde el principio a hacer peque\u00f1os programas y modificaciones de los que hagamos o planteemos en clase. Pelearos con el c\u00f3digo, que os salgan errores, resolverlos, etc. Es la \u00fanica forma de aprender. Una vez hay\u00e1is implementado una soluci\u00f3n a un problema, entonces es el momento de mirar otra soluci\u00f3n para ver si pod\u00e9is mejorarlo, pero primero deb\u00e9is haberlo resuelto vosotros o al menos intentado resolver. Un programa de computadora es s\u00f3lo una recopilaci\u00f3n de las instrucciones necesarias para resolver un problema espec\u00edfico. El m\u00e9todo utilizado para resolver el problema se conoce como algoritmo. Por ejemplo, si queremos implementar un programa que comprueba si un n\u00famero es impar, el conjunto de instrucciones que resuelve el problema es el programa . El m\u00e9todo que se utiliza para comprobar si el n\u00famero es par o impar es el algoritmo . Normalmente, para desarrollar un programa para resolver un problema particular, primero hay que pensar en el algoritmo y luego desarrollar un programa que implementa ese algoritmo. Por lo tanto, el algoritmo para resolver el problema par / impar podr\u00eda expresarse de la siguiente manera: Primero, dividir el n\u00famero por dos. Si el resto de la divisi\u00f3n es cero, el n\u00famero es par; de lo contrario, el n\u00famero es impar. Caracter\u00edsticas deseables de un programa Integridad : Correcci\u00f3n de los c\u00e1lculos Claridad : Facilidad de lectura del programa en conjunto, con \u00e9nfasis en la l\u00f3gica subyacente. Sencillez : La claridad y la correcci\u00f3n de un programa se suelen ver favorecidos con hacer las cosas de forma tan sencilla como sea posible, consistente con los objetivos del programa en su conjunto Eficiencia : relacionado con la velocidad de ejecuci\u00f3n y la utilizaci\u00f3n eficiente de la memoria Modularidad : Casi todos los programas se pueden dividir en peque\u00f1as subtareas. Es una buena pr\u00e1ctica de programaci\u00f3n implementar cada una de estas subtareas como un m\u00f3dulo. En C estos m\u00f3dulos son las funciones. El dise\u00f1o modular aumenta la correcci\u00f3n y la claridad, y facilita los posibles cambios futuros del programa Generalidad : Intentaremos que el programa sea lo m\u00e1s gen\u00e9rico posible Todas estas caracter\u00edsticas las tendremos en cuenta en la evaluaci\u00f3n de vuestros programas en la asignatura. Pasos para desarrollar un programa Es fundamental comprender bien el problema antes de pensar en la solucio\u0301n. Antes de ponerse a escribir el programa es necesario tener claro co\u0301mo resolverlo, pensar en ello utilizando l\u00e1piz y papel: Entender el problema Disen\u0303ar la solucio\u0301n Implementar el programa Verificar y probar el programa Optimizar Entender el problema Para entender el problema debemos pensar y analizarlo. Debemos plantearnos las siguientes cuestiones: Datos de entrada Datos de salida \u00bfQue\u0301 hay que resolver? \u00bfCo\u0301mo se puede resolver? Ejemplo: Se desea calcular la nota de una asignatura de un alumno teniendo en cuenta la nota de los exa\u0301menes realizados en una determinada convocatoria. En Enero, la nota final se obtiene con el 15% de la nota de un primer examen con ordenador, el 35% de la nota de un segundo examen con ordenador y el 50% restante con la nota de un examen escrito, excepto si la nota del examen escrito o la del segundo examen con ordenador es menor que 4, en cuyo caso la nota final sera\u0301 la mi\u0301nima de las dos. En Julio, la nota final se obtendra\u0301 como 50% nota del examen escrito, 50% nota del examen con ordenador, excepto si cualquiera de estas dos notas es menor que 4, en cuyo caso la nota final sera\u0301 la mi\u0301nima de las dos. Dise\u00f1ar la soluci\u00f3n Detectar los pasos a seguir para solucionar el problema Estructurar el programa Plasmar esa solucio\u0301n de alguna manera Algoritmo: Dime de que\u0301 convocatoria quieres saber tu nota final Si es la convocatoria de Enero entonces Dime la nota de los 2 exa\u0301menes con ordenador y del examen escrito Si la nota del examen escrito < 4 o nota examen ordenador 2 < 4 Entonces TU NOTA FINAL ES = mi\u0301nimo (nota ex. escrito, nota ex. ord. 2) Sino TU NOTA FINAL ES =0,15 Ordenador_1+0,35 Ordenador_2+0,5*Escrito Si es la convocatoria de Julio Entonces Dime las notas del examen escrito y del examen con ordenador Si la nota del examen escrito < 4 o nota examen ordenador < 4 Entonces TU NOTA FINAL ES = mi\u0301nimo (nota ex. escrito, nota ex. ord.) Sino TU NOTA FINAL ES = 0,5 Ordenador+0,5 Escrito Implementar el programa Desarrollar en un lenguaje de programacio\u0301n los pasos a seguir para resolver el problema Importante: la solucio\u0301n debe ser (lo suficientemente) o\u0301ptima. Se pueden encontrar distintas soluciones para resolver el mismo problema Este paso implica un proceso ci\u0301clico donde se programa (implementa) la solucio\u0301n (total o parcial), se prueba, se detectan errores y se vuelve a programar para resolverlos. Normalmente un programa no funciona a la primera. Programa para calcular la nota: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include <stdio.h> int main () { char convocatoria ; float ordenador_1 , ordenador_2 , examen_escrito , nota_final ; printf ( \"Dime la convocatoria(E,J):\" ); scanf ( \"%c\" , & convocatoria ); if ( convocatoria == 'E' ) { printf ( \"Dime la nota del primer examen con ordenador:\" ); scanf ( \"%f\" , & ordenador_1 ); printf ( \"Dime la nota del segundo examen con ordenador:\" ); scanf ( \"%f\" , & ordenador_2 ); printf ( \"Dime la nota del examen escrito:\" ); scanf ( \"%f\" , & examen_escrito ); if ( examen_escrito < 4 || ordenador_2 < 4 ) // minimo: funcio\u0301n que calcula el nu\u0301mero ma\u0301s pequen\u0303o entre 2 nu\u0301meros nota_final = minimo ( examen_escrito , ordenador_2 ); else nota_final = 0.15 * ordenador_1 + 0.35 * ordenador_2 + 0.5 * examen_escrito ; } else if ( convocatoria == 'J' ) { printf ( \"Dime la nota del examen escrito:\" ); scanf ( \"%f\" , & examen_escrito ); printf ( \"Dime la nota del examen con ordenador:\" ); scanf ( \"%f\" , & ordenador_2 ); if ( examen_escrito < 4 || ordenador_2 < 4 ) // minimo: funcio\u0301n que calcula el nu\u0301mero ma\u0301s pequen\u0303o entre 2 nu\u0301meros nota_final = minimo ( examen_escrito , ordenador_2 ); else nota_final = 0.5 * ordenador_2 + 0.5 * examen_escrito ; } printf ( \"TU NOTA FINAL ES %f \\n \" , nota_final ); return 0 ; } Probar el programa Comprobar que el resultado obtenido es el adecuado. Para ello se deben realizar pruebas exhaustivas sobre nuestro programa y testear que los resultados obtenidos son los que esperamos Si no, volver al paso anterior Optimizaci\u00f3n Despu\u00e9s de tener un programa correcto y validado, es conveniente estudiar si se puede mejorar la soluci\u00f3n para que el programa sea m\u00e1s eficiente, m\u00e1s legible y menos redundante. Documentaci\u00f3n La documentacio\u0301n es un parte fundamental en el desarrollo de co\u0301digo. En C los comentarios son: 1 2 3 /* uno o varios comentarios */ /* Pueden ser multili\u0301nea */ El preprocesador elimina el texto del comentario. No abusar de ellos: 1 if ( x == 5 ) /* Si x es igual a 5 */ Usar lenguaje apropiado. Si tenemos funciones, comentar lo que hace justo antes de la definici\u00f3n de la funcio\u0301n: 1 2 /* Realiza la suma ponderada de los valores pasados por para\u0301metro */ double sumap ( double a , double b ) { La principal funcio\u0301n de los comentarios es el mantenimiento: tanto por ti como para otros programadores 2.3 Normas de estilo para programar en C \u00b6 Nota : En este apartado vamos a hablar de t\u00e9rminos que iremos explicando poco a poco en la asignatura. La idea es recopilarlo para que os sirva de gu\u00eda y de consulta. Los programas, a lo largo del tiempo, se van quedando obsoletos, por ejemplo, actualizaci\u00f3n del software de un robot para una determinada tarea. Es muy normal tener que modificar un programa porque debamos actualizarlo o porque decidamos incluirle nuevas posibilidades que antes no estaban previstas. Por otra parte, tambi\u00e9n es frecuente que uno deba modificar un programa escrito por otro programador, encontr\u00e1ndonos con problemas de legibilidad. Para poder modificarlo, primero hay que comprender su funcionamiento, y para facilitar esta tarea el programa debe estar escrito siguiendo unas normas b\u00e1sicas. Adem\u00e1s, el lenguaje C se presta a hacer programas complejos y dif\u00edciles de comprender. En C se pueden encapsular \u00f3rdenes y operadores, de tal forma que, aunque consigamos mayor eficiencia su comprensi\u00f3n sea todo un reto. No existen un conjunto de reglas fijas para programar con legibilidad. Lo que s\u00ed existen son un conjunto de reglas generales: Identificadores significativos Constantes simb\u00f3licas Comentarios Estructura del programa Identaci\u00f3n o sangrado Identificadores significativos Un identificador es un nombre asociado a un objeto de programa, que puede ser una variable, funci\u00f3n, constante, tipo de datos... El nombre de cada identificador debe expresar lo m\u00e1s claramente posible al objeto que identifica. Normalmente los identificadores deben empezar por una letra, no pueden contener espacios y suelen tener una longitud m\u00e1xima que puede variar, pero que no deber\u00eda superar los 10-20 caracteres para evitar lecturas muy pesadas. Un identificador debe indicar lo m\u00e1s breve y claramente posible el objeto al que referencia. Por ejemplo, si una variable contiene la lectura del sensor de visi\u00f3n de un robot, la variable se puede llamar sensorVision . Es muy normal usar variables como i, j o k para nombres de \u00edndices de bucles (for, while...), lo cual es aceptable siempre que la variable sirva s\u00f3lo para el bucle y no tenga un significado especial. En determinados casos, dentro de una funci\u00f3n o programa peque\u00f1o, se pueden usar este tipo de variables, si no crean problemas de comprensi\u00f3n, pero esto no es muy recomendable. Para los identificadores de funci\u00f3n se suelen usar las formas de los verbos en infinitivo, seguido de alg\u00fan sustantivo, para indicar claramente lo que hace. Por ejemplo, una funci\u00f3n podr\u00eda llamarse evitarObstaculo , y ser\u00eda m\u00e1s comprensible que si le hubi\u00e9ramos llamado evitar . Constantes simb\u00f3licas En un programa es muy normal usar constantes (num\u00e9ricas, cadenas...). Si estas constantes las usamos directamente en el programa, el programa funcionar\u00e1, pero es m\u00e1s recomendable usar constantes simb\u00f3licas, de forma que las definimos al principio del programa y luego las usamos cuando haga falta. As\u00ed, conseguimos principalmente dos ventajas: Los programas se hacen m\u00e1s legibles: Es m\u00e1s legible usar la constante simb\u00f3lica PI que usar 3.14 en su lugar: 1 volumen_esfera = 4 / 3. * PI * pow ( radio , 3 ); Los programas ser\u00e1n m\u00e1s f\u00e1ciles de modificar: Si en un momento dado necesitamos usar PI con m\u00e1s decimales (3.141592) s\u00f3lo tenemos que cambiar la definici\u00f3n, y no tenemos que cambiar todas las ocurrencias de 3.14 por 3.141592 que ser\u00eda m\u00e1s costoso y podemos olvidarnos alguna. En C, las constantes simb\u00f3licas se suelen poner usando una \u00f3rden al preprocesador de C, quedando definidas desde el lugar en que se definen hasta el final del fichero (o hasta que expresamente se indique). Su formato general es: 1 #define CONSTANTE valor Se encarga de cambiar todas las ocurrencias de CONSTANTE por el valor indicado en la segunda palabra (valor). Este cambio lo realiza el preprocesador de C, antes de empezar la compilaci\u00f3n. Por convenio, las constantes se suelen poner completamente en may\u00fasculas y las variables no, de forma que leyendo el programa podamos saber r\u00e1pidamente qu\u00e9 es cada cosa. En general, se deben usar constantes simb\u00f3licas en constantes que aparezcan m\u00e1s de una vez en el programa referidas a un mismo elemento que pueda variar ocasionalmente. Comentarios Sirven para aumentar la claridad de un programa, ayudan para la documentaci\u00f3n y bien utilizados nos pueden ahorrar mucho tiempo. Los comentarios deben ser breves y concisos. Se deben poner comentarios cuando se crean necesarios, y sobre todo: Al principio del programa o de cada fichero del programa que permita seguir un poco la historia de cada programa, indicando: Nombre del programa, objetivo, par\u00e1metros (si los tiene), condiciones de ejecuci\u00f3n, m\u00f3dulos que lo componen, autor o autores, fecha de finalizaci\u00f3n, \u00faltimas modificaciones realizadas y sus fechas... y cualquier otra eventualidad que el programador quiera dejar constancia. En cada sentencia o bloque (bucle, if, switch...) que revista cierta complejidad, de forma que el comentario indique qu\u00e9 se realiza o c\u00f3mo funciona. Al principio de cada funci\u00f3n cuyo nombre no explique suficientemente su cometido. Se debe poner no s\u00f3lo lo que hace sino la utilidad de cada par\u00e1metro, el valor que devuelve (si lo hubiera) y, si fuera oportuno, los requisitos necesarios para que dicha funci\u00f3n opere correctamente. En la declaraci\u00f3n de variables y constantes cuyo identificador no sea suficiente para comprender su utilidad. En los cierres de bloques con '}', para indicar a qu\u00e9 sentencias de control de flujo pertenecen, principalmente cuando existe mucho anidamiento de sentencias y/o los bloques contienen muchas l\u00edneas de c\u00f3digo. No olvidemos que los comentarios son textos para las personas, por lo que debemos cuidar el estilo, acentos y signos de puntuaci\u00f3n. Estructura del programa Un programa debe ser claro, estar bien organizado y ser f\u00e1cil de leer y entender Para aumentar la claridad no se deben escribir l\u00edneas muy largas que se salgan de la pantalla y funciones con muchas l\u00edneas de c\u00f3digo (especialmente la funci\u00f3n principal). Una funci\u00f3n demasiado grande demuestra, en general, una programaci\u00f3n descuidada y un an\u00e1lisis del problema poco estudiado. Estructura t\u00edpica de un programa C, es el que usaremos en esta asignatura: Comentarios de presentaci\u00f3n Inclusi\u00f3n de bibliotecas del sistema. Ejemplo: #include <stdio.h> Bibliotecas propias de la aplicaci\u00f3n Constantes simb\u00f3licas y definiciones de macros, con #define Definici\u00f3n de tipos, con typedef Declaraci\u00f3n de funciones Implementaci\u00f3n de funciones Este orden no es estricto y pueden cambiarse algunos puntos por otros, pero debemos ser coherentes y usar el mismo orden en todos nuestros programas Identaci\u00f3n o sangrado La indentaci\u00f3n o sangrado consiste en tabular hacia la derecha todas las sentencias de una misma funci\u00f3n o bloque, de forma que se vea r\u00e1pidamente cuales pertenecen al bloque y cuales no. Algunos estudios indican que el indentado debe hacerse con 3 \u00f3 4 espacios. Usar m\u00e1s espacios no aumenta la claridad y puede originar que las l\u00edneas se salgan de la pantalla, complicando su lectura. La indentaci\u00f3n es muy importante para que el programador no pierda la estructura del programa debido a los posibles anidamientos. Normalmente, la llave de comienzo de una estructura de control { se pone al final de la linea y la que lo cierra } justo debajo de donde comienza (como veremos m\u00e1s adelante). Ejemplo: 1 2 3 4 5 6 7 8 9 10 if ( condici\u00f3n ) { sentencia1 ; sentencia2 ; ... } else { sentencia1 ; sentencia2 ; ... } 1 2 3 4 int main () { printf ( \"Ejemplo de identaci\u00f3n \\n \" ); return 0 ; } 2.4. Consejos para la realizaci\u00f3n de las pr\u00e1cticas de programaci\u00f3n \u00b6 Leer bien el enunciado de lo que te piden. Pensar antes de escribir el c\u00f3digo. Coger l\u00e1piz y papel y estructurar los pasos que se desean implementar (algoritmo). Detenerse ante cualquier mensaje de error o warning y solucionarlo antes de continuar. Ir paso a paso. Nunca escribas una gran porci\u00f3n de c\u00f3digo sin haberla probado poco a poco. Escribir comentarios a medida que escribes c\u00f3digo. Preguntar al profesor lo que no entiendas. IMPORTANTE : No programas para el ordenador, programas para ti. Programar no es escribir c\u00f3digo y olvidarlo, sino mantenerlo. Puedes echarle un vistazo a este divertido enlace donde explican qu\u00e9 no debes hacer cuando implementas un programa. Bibliograf\u00eda \u00b6 Cap\u00edtulo 1 y del 3.1 al 3.4 de \"Programaci\u00f3n en C, metodolog\u00eda, algoritmos y estructuras de datos\", Luis Joyanes, Ignacio Zahonero Cap\u00edtulo 1.4 \"Programming Language Pragmatics\", Michael L. Scott, Compilation and Interpretation Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares Puig","title":"Tema 1: Introducci\u00f3n a la  programaci\u00f3n"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#tema-1-introduccion-a-la-programacion","text":"","title":"Tema 1: Introducci\u00f3n a la  programaci\u00f3n"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#1-lenguajes-de-programacion","text":"Un lenguaje de programaci\u00f3n permite especificar procesos que se ejecutan en computadores. Un programa escrito en un determinado lenguaje nos permite definir las instrucciones que realizar\u00e1 el ordenador (o, m\u00e1s en concreto, el procesador) que lo ejecute. Por ello, para entender en profundidad qu\u00e9 es un lenguaje de programaci\u00f3n es fundamental conocer el ordenador.","title":"1. Lenguajes de programaci\u00f3n"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#11-el-ordenador-y-sus-componentes","text":"Lor ordenadores poseen los siguientes componentes: Dispositivos de entrada . Se encargan de capturar informacio\u0301n de entrada a la computadora: teclado, rato\u0301n, micro\u0301fono, etc. Dispositivos de salida . Se encargan de la salida de informacio\u0301n de la computadora: monitor, impresora, altavoces, etc. Dispositivos de almacenamiento . Se encargan de almacenar los datos para su uso posterior: disco duro, CD-ROM, etc. Unidad de Procesamiento . Realiza las operaciones con los datos Memoria principal . Es donde se almacenan temporalmente los datos con los que la CPU trabaja en cada momento. Est\u00e1 formada por circuitos electr\u00f3nicos integrados capaces de almacenar valores binarios (0 \u00f3 1) en cada celda de memoria Memoria principal: Palabra de memoria: menor conjunto de celdas de memoria que se pueden leer o escribir simult\u00e1neamente. En el ejemplo, cada palabra es de 1 byte (8 bits) Direcci\u00f3n de memoria: n\u00famero que identifica de forma un\u00edvoca cada palabra de memoria","title":"1.1. El ordenador y sus componentes"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#12-representacion-de-la-informacion","text":"La informacio\u0301n se representa en una computadora mediante el uso de dos estados: ausencia y presencia de corriente. Esto se debe a la naturaleza ele\u0301ctrica de la misma: Esta dualidad nos permite adoptar un sistema binario para representar la informacio\u0301n. Asi\u0301, la presencia de sen\u0303al se representa por el 1 y la ausencia por el 0. Esto nos lleva al concepto de bit , que es la unidad mi\u0301nima de informacio\u0301n. Un bit puede adoptar los valores 0 o\u0301 1. Un u\u0301nico bit aporta poca cantidad de informacio\u0301n. Es por ello que los bits se agrupan de 8 en 8 formando un byte . Un byte permite representar 2^8 = 256 combinaciones diferentes. A su vez, los bytes se agrupan formando palabras , que dependiendo de cada computadora pueden ser de 8, 16, 32 o\u0301 64 bytes .","title":"1.2. Representaci\u00f3n de la informaci\u00f3n"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#13-programa","text":"Un programa es el conjunto ordenado de instrucciones que indican a la computadora las acciones que debe realizar para cumplir una tarea especi\u0301fica. En este sentido, con un programa especificamos al ordenador que\u0301 tiene que hacer, en el orden en el que lo tiene que hacer y los datos que ha de usar para ello. Los programas esta\u0301n escritos en un determinado lenguaje formal libre de ambigu\u0308edades, de forma que la especificacio\u0301n de lo que queremos hacer sea uni\u0301voca. Con respecto al nivel de abstraccio\u0301n de estos lenguajes, los podemos clasificar en dos grandes grupos: Lenguajes Ma\u0301quina : Como su propio nombre indica, se trata de los lenguajes \"nativos\" de la computadora, y por ello es capaz de procesarlos directamente. Sumamente costosos para el programador. Lenguajes de Alto Nivel : Se trata de lenguajes mucho ma\u0301s cercanos al lenguaje humano, con un alto nivel de abstracci\u00f3n, por lo que son ma\u0301s comprensibles y menos engorrosos de usar para el programador. Los programas construidos con estos lenguajes han de ser traducidos a lenguaje ma\u0301quina mediante el uso de un compilador para que la computadora los pueda procesar. Python, C, C++, Java, etc.","title":"1.3. Programa"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#14-los-primeros-lenguajes-de-programacion","text":"Los primeros computadores electr\u00f3nicos se programan directamente usando el conjunto de instrucciones del procesador, en c\u00f3digo m\u00e1quina , c\u00f3digo hexadecimal. El siguiente programa, en lenguaje ma\u0301quina, resta un nu\u0301mero de otro y el resultado lo almacena en una posicio\u0301n de memoria: El primer lenguaje de un nivel algo m\u00e1s elevado que el c\u00f3digo m\u00e1quina es el ensamblador . Programas que empiezan a ayudar a los programadores: ensambladores. Hay una relaci\u00f3n casi directa entre la notaci\u00f3n en ensamblador y el c\u00f3digo hexadecimal que produce el ensamblador. El programa anterior en ensamblador seri\u0301a: 1 2 3 4 5 6 7 CAR A RES B ALM C STOP C : 0 A : 7 B : 2 El lenguaje ensamblador constituye un gran avance en lo que a facilidad de comprensio\u0301n se requiere a la hora de programar. De todas formas, este lenguaje sigue teniendo varios inconvenientes: Por un lado, cada computadora posee un lenguaje ensamblador distinto, por lo que para utilizar un programa en otra computadora distinta habri\u0301a que rescribirlo. Por otro lado, el lenguaje sigue siendo demasiado cercano al lenguaje ma\u0301quina, lo que dificulta su comprensio\u0301n y por tanto encarece el desarrollo de programas de gran extensio\u0301n. Los lenguajes de alto nivel se caracterizan por no ser dependientes de ma\u0301quina. Mediante la compilacio\u0301n de un programa escrito en lenguaje de alto nivel podremos ejecutarlo en cualquier ma\u0301quina. Para ello, necesitaremos un compilador de ese lenguaje para cada ma\u0301quina en la que queramos ejecutar nuestro programa. Otra caracteri\u0301stica de estos lenguajes es su sintaxis es m\u00e1s cercana al lenguaje natural del programador y proporciona distintas herramientas de abstracci\u00f3n que facilitan la programaci\u00f3n.","title":"1.4. Los primeros lenguajes de programaci\u00f3n"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#15-los-primeros-lenguajes-de-alto-nivel","text":"Los primeros lenguajes de alto nivel se desarrollaron a finales de la d\u00e9cada de los 50: FORTRAN en 1956 Lisp en 1958 Ambos lenguajes planteaban dos enfoques muy distintos desde el principio y fueron la base y la influencia del desarrollo de numerosos lenguajes posteriores. Desde 1954 hasta la actualidad se han documentado m\u00e1s de 2.500 (consultar en The Language List ).","title":"1.5. Los primeros lenguajes de alto nivel"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#16-compiladores-e-interpretes","text":"En el nivel de abstracci\u00f3n m\u00e1s bajo, la ejecuci\u00f3n de un programa en un computador consiste en la ejecuci\u00f3n de un conjunto de instrucciones del c\u00f3digo m\u00e1quina del procesador.","title":"1.6. Compiladores e int\u00e9rpretes"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#2-lenguaje-c","text":"C es el lenguaje principal que vamos a estudiar en la asignatura, pero vamos a ver tambi\u00e9n algunos ejemplos en Python. C presenta ciertas caracter\u00edsticas que permiten ejercer un elevado control sobre la eficiencia de los programas, tanto en la velocidad de ejecuci\u00f3n como en el consumo de memoria, pero a un precio importante: tenemos que proporcionar informaci\u00f3n expl\u00edcita sobre gran cantidad de detalles, por lo que generalmente resultan programas m\u00e1s largos y complicados que sus equivalentes en otros lenguajes m\u00e1s modernos, aumentando as\u00ed la probabilidad de que cometamos errores. C es un lenguaje compilado: antes de ejecutar un programa escrito por nosotros, suministramos su c\u00f3digo fuente (en un fichero con extensi\u00f3n .c) a un compilador de C. El compilador lee y analiza todo el programa. Si el programa est\u00e1 correctamente escrito seg\u00fan la definici\u00f3n del lenguaje, el compilador genera un nuevo fichero con su traducci\u00f3n a c\u00f3digo de m\u00e1quina (llamado programa objeto), y si no, muestra los errores que ha detectado. Para ejecutar el programa utilizamos el nombre del fichero generado. Si no modificamos el c\u00f3digo fuente, no hace falta que lo compilemos nuevamente para volver a ejecutar el programa: basta con volver a ejecutar el fichero generado por el compilador. La principal ventaja de compilar los programas es que se gana en velocidad de ejecuci\u00f3n, ya que cuando el programa se ejecuta est\u00e1 completamente traducido a c\u00f3digo de m\u00e1quina y se ahorra el proceso de traducci\u00f3n simult\u00e1nea que conlleva interpretar un programa. Pero, adem\u00e1s, como se traduce a c\u00f3digo m\u00e1quina en una fase independiente de la fase de ejecuci\u00f3n, el programa traductor puede dedicar m\u00e1s tiempo a intentar encontrar la mejor traducci\u00f3n posible, la que proporcione el programa de c\u00f3digo m\u00e1quina m\u00e1s r\u00e1pido (o que consuma menos memoria).","title":"2. Lenguaje C"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#21-desarrollo-de-programas-en-lenguaje-c","text":"Cuando se implementa un programa, en primer lugar editamos el c\u00f3digo fuente con un editor. Estos archivos contienen la implementaci\u00f3n del programa en un determinado lenguaje, pero no se pueden ejecutar directamente. Para ello necesitamos compilar los programas oara obtener el c\u00f3digo objeto , que es un c\u00f3digo en binario intermedio que puede enlazarse con otros m\u00f3ulos ya compilados o con bibliotecas para obtener un c\u00f3digo ejecutable . Este \u00faltimo es un fichero que se puede ejecutar directamente. Este proceso es un ciclo, de forma que si despu\u00e9s de ejecutar el programa hemos encontrado errores, volvemos a editar el programa, compilarlo y ejecutarlo. Compilador : un programa que lee un c\u00f3digo fuente y lo traduce a c\u00f3digo objeto (ensamblador o binario). Enlazador : combina archivos objeto y bibliotecas de forma que se puedan ejecutar en una sola unidad. Ejemplo de programa en C: 1 2 3 4 5 6 7 8 #include <stdio.h> int main () { printf ( \"Hola mundo!! \\n \" ); return 0 ; } Vamos a analizar este primer programa: La primera l\u00ednea #include <stdio.h> se debe incluir al principio de cada programa. Incluye las funciones de entrada y salida, por ejemplo la instrucci\u00f3n printf . La l\u00ednea int main() indica la funci\u00f3n principal main , es un nombre especial que indica d\u00f3nde empieza el programa su ejecuci\u00f3n. Los par\u00e9ntesis tanto de main como de printf indican que ambas son funciones, y dentro de los par\u00e9ntesis ir\u00e1n los argumentos de las mismas (si los tienen). El argumento de printf es la cadena de caracteres \"Hola mundo!!\\n\" . La instrucci\u00f3n printf es una funci\u00f3n que imprime su argumento por pantalla, en este caso \"Hola mundo\" . Los \u00faltimos dos caracteres de la cadena `\\n' indican el car\u00e1cter newline o salto de l\u00ednea. Todas las instrucciones en C terminan en un ; . La \u00faltima sentencia return 0; indica que se termina la ejecuci\u00f3n de main , y devuelve al sistema el valor 0. El cero es un valor que se usa para indicar que el programa ha terminado correctamente (sin errores). La devoluci\u00f3n de un n\u00famero distinto de cero indican distintos errores (por ejemplo que no se encuentra un fichero). Vamos a compilar y ejecutar nuestro primer programa. Son tres pasos: A partir del fichero de texto con nuestro programa con el co\u0301digo fuente en lenguaje C se realiza una fase de preprocesado en la que se eliminan comentarios y se satisfacen directivas # gcc -\u00adE holamundo.c Una vez preprocesado se genera un fichero con co\u0301digo objeto en el paso de compilacio\u0301n gcc -\u00adc holaMundo.c . Nos genera holaMundo.o El fichero objeto se debe enlazar con las libreri\u0301as para generar el ejecutable en el paso de enlazado. Esto se puede realizar con una instruccio\u0301n: gcc holaMundo.c \u00ad-o holaMundo Su forma de uso m\u00e1s b\u00e1sica es \u00e9sta (agrupamos los pasos anteriores en una \u00fanica instrucci\u00f3n): gcc -o holamundo holamundo.c La opci\u00f3n -o es abreviatura de output , y a ella le sigue el nombre del fichero que contendr\u00e1 la traducci\u00f3n a c\u00f3digo m\u00e1quina del programa. Este fichero s\u00f3lo se genera si el programa C est\u00e1 correctamente escrito y no tiene errores de compilaci\u00f3n. Ahora ejecutamos el fichero ejecutable: ./holamundo y el resultado es la salida por pantalla: Hola mundo!!","title":"2.1. Desarrollo de programas en lenguaje C"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#22-aprender-a-programar","text":"A programar se aprende programando . En esta asignatura os dar\u00e9is cuenta que no sirve de nada memorizar programas, ni mirar ejercicios resueltos o soluciones a las pr\u00e1cticas planteadas. Deb\u00e9is empezar desde el principio a hacer peque\u00f1os programas y modificaciones de los que hagamos o planteemos en clase. Pelearos con el c\u00f3digo, que os salgan errores, resolverlos, etc. Es la \u00fanica forma de aprender. Una vez hay\u00e1is implementado una soluci\u00f3n a un problema, entonces es el momento de mirar otra soluci\u00f3n para ver si pod\u00e9is mejorarlo, pero primero deb\u00e9is haberlo resuelto vosotros o al menos intentado resolver. Un programa de computadora es s\u00f3lo una recopilaci\u00f3n de las instrucciones necesarias para resolver un problema espec\u00edfico. El m\u00e9todo utilizado para resolver el problema se conoce como algoritmo. Por ejemplo, si queremos implementar un programa que comprueba si un n\u00famero es impar, el conjunto de instrucciones que resuelve el problema es el programa . El m\u00e9todo que se utiliza para comprobar si el n\u00famero es par o impar es el algoritmo . Normalmente, para desarrollar un programa para resolver un problema particular, primero hay que pensar en el algoritmo y luego desarrollar un programa que implementa ese algoritmo. Por lo tanto, el algoritmo para resolver el problema par / impar podr\u00eda expresarse de la siguiente manera: Primero, dividir el n\u00famero por dos. Si el resto de la divisi\u00f3n es cero, el n\u00famero es par; de lo contrario, el n\u00famero es impar.","title":"2.2. Aprender a programar"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#23-normas-de-estilo-para-programar-en-c","text":"Nota : En este apartado vamos a hablar de t\u00e9rminos que iremos explicando poco a poco en la asignatura. La idea es recopilarlo para que os sirva de gu\u00eda y de consulta. Los programas, a lo largo del tiempo, se van quedando obsoletos, por ejemplo, actualizaci\u00f3n del software de un robot para una determinada tarea. Es muy normal tener que modificar un programa porque debamos actualizarlo o porque decidamos incluirle nuevas posibilidades que antes no estaban previstas. Por otra parte, tambi\u00e9n es frecuente que uno deba modificar un programa escrito por otro programador, encontr\u00e1ndonos con problemas de legibilidad. Para poder modificarlo, primero hay que comprender su funcionamiento, y para facilitar esta tarea el programa debe estar escrito siguiendo unas normas b\u00e1sicas. Adem\u00e1s, el lenguaje C se presta a hacer programas complejos y dif\u00edciles de comprender. En C se pueden encapsular \u00f3rdenes y operadores, de tal forma que, aunque consigamos mayor eficiencia su comprensi\u00f3n sea todo un reto. No existen un conjunto de reglas fijas para programar con legibilidad. Lo que s\u00ed existen son un conjunto de reglas generales: Identificadores significativos Constantes simb\u00f3licas Comentarios Estructura del programa Identaci\u00f3n o sangrado","title":"2.3 Normas de estilo para programar en C"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#24-consejos-para-la-realizacion-de-las-practicas-de-programacion","text":"Leer bien el enunciado de lo que te piden. Pensar antes de escribir el c\u00f3digo. Coger l\u00e1piz y papel y estructurar los pasos que se desean implementar (algoritmo). Detenerse ante cualquier mensaje de error o warning y solucionarlo antes de continuar. Ir paso a paso. Nunca escribas una gran porci\u00f3n de c\u00f3digo sin haberla probado poco a poco. Escribir comentarios a medida que escribes c\u00f3digo. Preguntar al profesor lo que no entiendas. IMPORTANTE : No programas para el ordenador, programas para ti. Programar no es escribir c\u00f3digo y olvidarlo, sino mantenerlo. Puedes echarle un vistazo a este divertido enlace donde explican qu\u00e9 no debes hacer cuando implementas un programa.","title":"2.4. Consejos para la realizaci\u00f3n de las pr\u00e1cticas de programaci\u00f3n"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#bibliografia","text":"Cap\u00edtulo 1 y del 3.1 al 3.4 de \"Programaci\u00f3n en C, metodolog\u00eda, algoritmos y estructuras de datos\", Luis Joyanes, Ignacio Zahonero Cap\u00edtulo 1.4 \"Programming Language Pragmatics\", Michael L. Scott, Compilation and Interpretation Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares Puig","title":"Bibliograf\u00eda"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html","text":"Tema 2: Tipos de datos simples \u00b6 1. Tipos de datos \u00b6 Los elementos b\u00e1sicos de los que consta un programa son: los datos las instrucciones que los procesan Los datos son los elementos que manipulan los programas. Para almacenar datos necesitamos zonas de memoria del ordenador. La memoria del ordenador est\u00e1 dividida en casillas numeradas en las que se guardan los datos. Los lenguajes de programaci\u00f3n nos permiten asignar nombres simb\u00f3licos a estas celdillas y controlar qu\u00e9 zonas de memoria est\u00e1n libres y ocupadas. El programador \u00fanicamente tiene que indicarle al ordenador el nombre de las zonas de memoria donde se quiere almacenar la informaci\u00f3n y de qu\u00e9 tipo es son los datos. A estas zonas de memoria les llamaremos variables . En un programa podemos distinguir entre: datos de entrada / salida: usados como punto de partida o resultado datos internos / auxiliares: usados por el programa para obtener el resultado Por ejemplo, en un programa que calcula la longitud de una circunferencia ( Dia\u0301metro * PI ) Dato de entrada: radio de la circunferencia Dato de salida: longitud de la circunferencia Datos internos: di\u00e1metro de la circunferencia, que toma como valor 2*radio de la circunferencia El lenguaje C es fuertemente tipado , eso significa que tenemos que asignar expl\u00edcitamente un tipo a cada dato. El tipo de un dato es el conjunto de valores que puede tomar durante el programa. La asignaci\u00f3n de tipos a los datos tiene cuatro objetivos principales: Determinar el rango de objetos que puede representar el dato. Conocer qu\u00e9 operaciones se pueden realizar con ellos Detectar errores en las operaciones Determinar c\u00f3mo ejecutar operaciones La clasificaci\u00f3n de los datos se hace teniendo en cuenta dos aspectos: Tama\u00f1o que ocupa en memoria fijo o variable: tipos est\u00e1ticos o din\u00e1micos N\u00famero de elementos que representan: tipos simples o estructurados Tipos est\u00e1ticos Ocupan un tama\u00f1o fijo en memoria, es decir, su tama\u00f1o no puede variar durante la ejecuci\u00f3n de un programa. Una vez declarada una variable de un tipo determinado, a \u00e9sta se le asigna un trozo de memoria fijo, y ese trozo no se podr\u00e1 aumentar ni disminuir. Tipos din\u00e1micos Tambi\u00e9n llamados punteros , los veremos m\u00e1s adelante. Un puntero no define un tipo determinado, sino que apunta a una direcci\u00f3n de memoria. Podemos reservar un tama\u00f1o determinado de memoria, ampliarlo, reducirlo y liberarlo. Tipos simples S\u00f3lo representan un dato, son los tipos b\u00e1sicos: entero, car\u00e1cter, real, etc. Tipos estructurados Est\u00e1n formados por un conjunto de elementos (tipos simples u otros estructurados). Los veremos en pr\u00f3ximos temas 2. Identificadores \u00b6 Un identificador es un nombre que se asigna a los distintos elementos de un programa: variables, funciones, etc. En lenguaje C son v\u00e1lidos los caracteres alfab\u00e9ticos en may\u00fasculas, min\u00fasculas, d\u00edgitos num\u00e9ricos (0..9) y el subrayado (_), aunque no pueden empezar por un n\u00famero. Las may\u00fasculas y min\u00fasculas se consideran caracteres distintos, el identificador hola es distinto a Hola . Ejemplo de identificadores v\u00e1lidos: 1 2 X Y12 sum_1 _temperature names area tax_rate TABLE Ejemplo de identificadores no v\u00e1lidos: 1 2 3 4 5 6 4 th /* El primer car\u00e1cter debe ser una letra o (_) */ \"x\" /* Car\u00e1cter no v\u00e1lido (\") */ num - orden /* Car\u00e1cter no v\u00e1lido (-) */ error flag /* Car\u00e1cter no v\u00e1lido (espacio) */ numero % 1 /* Car\u00e1cter no v\u00e1lido (%) */ numero $ 2 /* Car\u00e1cter no v\u00e1lido ($) */ Ejercicio : Indica qu\u00e9 identificadores son v\u00e1lidos en C: 1 2 3 casa mi - casa mi * casa micasa1 _MES MES_1 MES % 1 mes $ 1 a980 890 a _890 $ a890 Soluci\u00f3n: Son inv\u00e1lidos mi-casa mi*casa MES%1 mes$1 $a89 890a Las palabras reservadas son identificadores que tienen un significado especial para el compilador. Las palabras reservadas no se pueden usar como identificadores. Todas las palabras reservadas en C se escriben en min\u00fasculas. Palabras reservadas en C: 1 2 3 4 5 6 7 8 9 auto else long typedef break enum register union case extern return unsigned char float short void const for signed volatile continue goto sizeof while default if static _Bool do inline struct _Complex double int switch _Imaginary 3. Variables y constantes \u00b6 3.1. Variables \u00b6 Las variables son espacios reservados en la memoria que, como su nombre indica, pueden cambiar de contenido a lo largo de la ejecuci\u00f3n de un programa. Una variable corresponde a un \u00e1rea reservada en la memoria principal del ordenador. Para que nuestro c\u00f3digo sea m\u00e1s entendible y claro, el identificador de la variable debe ser mnemot\u00e9cnico, es decir que debe reflejar el uso dentro del programa de la misma El tama\u00f1o de la zona de memoria, en bytes, depender\u00e1 del tipo de dato que se almacene en la variable. Todas las variables en C deben definirse antes de su uso. En una misma l\u00ednea se pueden declarar varias variables del mismo tipo. Sintaxis: 1 < tipo_de_datos > < nombre1 > [, < nombre2 > ,...]; Ejemplo: 1 2 3 4 int temperaturaHorno ; // variable tipo int long numeroTelefono ; // variable tipo long float interes ; // variable tipo float double nota1 , nota2 ; // variables tipo double 3.2. Constantes \u00b6 Una constante representa un valor determinado que no cambia a lo largo del programa. Constantes con #define En C se definen mediante macros a trav\u00e9s de la directiva #define mediante la sintaxis: 1 #define <nombre> <valor> La palabra reservada define indica que la constante tiene un valor fijo durante toda la ejecuci\u00f3n del programa. El preprocesador debe sustituir las ocurrencias de nombre por su valor . Se suelen escribir en may\u00fasculas. Ejemplo: 1 2 3 4 #define PI 3.141516 #define VELOCIDAD_LUZ 300000 #define MENSAJE \"pulse intro\" #define VERDADERO 1 Constantes con const Otra forma de definir constantes es mediante la instrucci\u00f3n const . Sintaxis: 1 const tipo identificador = valor ; const : palabra clave usado para crear constantes tipo : palabra clave que determina el tipo de la variable: char, short, int, float, double identificador : nombre asignado a la variable, a eleccio\u0301n del desarrollador valor : valor compatible con el tipo de la variable Ejemplo: 1 const double cambioEuroPesetas = 166.386 ; Diferencias entre #define y const : #define afecta durante el proceso de pre-procesado, antes de la compilacio\u0301n (donde p.e., se eliminan los comentarios). const permite indicar de forma expli\u0301cita el tipo de la constante Variables y constantes en Python En C (lenguaje imperativo) hemos visto que las variables se pueden entender como \"cajas\" o zonas de memoria en las que se guardan los datos. Pero en Python (lenguaje orientado a objetos) las variables son \"etiquetas\" que permiten hacer referencia a los datos (objetos). En C hemos visto que para definir una variable es necesario que antes de utilizar esa variable se defina el tipo de informaci\u00f3n que va a contener (C es un lenguaje fuertemente tipado). En Python (lenguaje d\u00e9bilmente tipado), es el int\u00e9rprete del lenguaje el que decide el tipo de variable a utilizar en el momento que se guarda la informaci\u00f3n. Definimos variables en Python: 1 2 3 >>> a = 3 >>> nombre = \"hola\" >>> precio = 30.95 4. Tipos de datos simples \u00b6 En C hay 8 tipos de datos simples o elementales, a partir de los cuales se construyen todos los dem\u00e1s. Estos tipos sirven para hacer operaciones aritm\u00e9ticas (num\u00e9ricos enteros o reales), representaci\u00f3n de caracteres (caracteres) y valores l\u00f3gicos (booleanos). Vamos a ver los tipos de datos simples, sus operadores asociados y el tama\u00f1o que ocupan en memoria. 4.1. Enteros \u00b6 Los tipos de datos que permiten representar n\u00fameros enteros en C son: 1 2 3 short int long Permiten representar n\u00fameros positivos y negativos sin partes decimales. Podemos utilizar el modificador previo unsigned para indicar que se trata de un n\u00famero positivo (sin signo). Tama\u00f1o de los n\u00fameros enteros En el tama\u00f1o de los datos simples de C se suelen utilizar bytes (8 bits). Con 8 bits podemos representar hasta 2 8 = 256 combinaciones Tipo Bytes Valor m\u00ednimo Valor m\u00e1ximo short 2: 2 8 * 2 8 =2 16 -32.767 +32.767 unsigned short 2: 2 16 0 +65.535 int 4: 2 32 -2.147.483.647 +2.147.483.647 unsigned int 4: 2 32 0 +4.294.967.295 long 8: 2 64 -9.223.372.036.854.775.808 +9.223.372.036.854.775.808 Una forma de comprobar el tama\u00f1o que ocupa cada tipo en memoria es usar el operador sizeof . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* Este programa muestra para cada uno de los tipos de * datos b\u00e1sicos enteros de C el tama\u00f1o que ocupa en * bytes. */ #include <stdio.h> int main () { printf ( \"Un int ocupa %d bytes \\n \" , sizeof ( int )); printf ( \"Un unsigned int ocupa %d bytes \\n \" , sizeof ( unsigned int )); printf ( \"Un short ocupa %d bytes \\n \" , sizeof ( short )); printf ( \"Un unsigned short ocupa %d bytes \\n \" , sizeof ( unsigned short )); printf ( \"Un long ocupa %d bytes \\n \" , sizeof ( long )); printf ( \"Un unsigned long ocupa %d bytes \\n \" , sizeof ( unsigned long )); return 0 ; } Si se asigna a una variable de un tipo un valor que est\u00e1 fuera de su rango, no se obtiene ning\u00fan error ni aviso. Ese es uno de los problemas de C, su permisividad con los tipos. Hay que ser cuidadoso. 4.2. Reales \u00b6 Hay dos tipos n\u00fameros reales o n\u00fameros en coma flotante en C: 1 2 float double La representacio\u0301n interna de estos nu\u0301meros es diferente (uso de coma flotante), ya que los valores ma\u0301ximos y mi\u0301nimos no se obtienen so\u0301lo con los bytes. Adema\u0301s del rango (valores mi\u0301nimos y ma\u0301ximos), importa la precisio\u0301n (nu\u0301mero de cifras decimales): Tipo Bytes Valor m\u00ednimo Valor m\u00e1ximo Precisi\u00f3n float 4 -10 38 +10 38 7 cifras decimales double 8 -10 308 +10 308 15 cifras decimales Operaciones con n\u00fameros enteros y reales Operadores aritm\u00e9ticos. Operador Significado = Asignaci\u00f3n * Multiplicaci\u00f3n / Divisi\u00f3n % Resto de divisi\u00f3n entera (mod) + Suma - Resta 1 2 3 4 5 // Ejemplo operador m\u00f3dulo % int a = 6 ; a % 3 ; //\u2192 devuelve 0 a % 4 ; //\u2192 devuelve 2 Cuando la divisi\u00f3n se realiza entre enteros, el resultado se trunca al entero m\u00e1s pr\u00f3ximo por debajo. Por ejemplo, el resultado de 23/5 es 4 (se llama divisi\u00f3n entera). Sin embargo en la divisi\u00f3n real (alguno de los operandos es un n\u00famero real) no se trunca el resultado. 23/4 da 5.75 4.3. Car\u00e1cter \u00b6 El tipo car\u00e1cter char permite representar valores consistentes en un \u00fanico car\u00e1cter, como 'a', 'z', 'B', '%', '5', etc. Los caracteres v\u00e1lidos son los que est\u00e1n incluidos en la tabla del est\u00e1ndar ASCII extendido. El est\u00e1ndar incluye 256 caracteres, por lo que se necesitan 8 bits (1 byte) para representar un car\u00e1cter en C. 4.4. L\u00f3gico \u00b6 A diferencia de otros lenguajes, C no tiene un tipo booleano nativo. Necesitamos a\u00f1adir la cabecera: 1 #include <stdbool.h> Se maneja como nu\u0301mero de 1 byte (un bit seri\u0301a suficiente). Va\u0301lido para operaciones lo\u0301gicas. Operaciones con booleanos Operadores l\u00f3gicos. Operador Significado && AND l\u00f3gico || OR l\u00f3gico ! NOT l\u00f3gico 1 2 3 4 5 6 // Ejemplo bool a = true , b = false ; a && b ; // devuelve false a || b ; // devuelve true ! a ; // devuelve false Operadores relacionales: el resultado es un booleano Operador Significado < <= menor o menor/igual > >= mayor o mayor/igual == comparaci\u00f3n != distinto 1 2 3 4 5 6 // Ejemplo int a = 3 , b = 2 ; a > b ; // devuelve true a != b // devuelve true a == b ; // devuelve false Gu\u00eda operaciones l\u00f3gicas: 1 2 3 4 5 6 7 8 9 10 11 /* Algunas operaciones l\u00f3gicas */ int main () { printf ( \"Operaciones l\u00f3gicas:\" ); printf ( \"!true es %d \\n \" , ! true ); printf ( \"!false es %d \\n \" , ! false ); printf ( \"true AND false es %d \\n \" , true && false ); printf ( \"false OR true es %d \\n \" , false || true ); return 0 ; } Ejemplo del tama\u00f1o de tipos de datos simples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* Programa que muestra los tama\u00f1os de cada tipo */ #include <stdio.h> #include <limits.h> int main () { printf ( \" \\n n\u00famero de bits por char: %d\" , CHAR_BIT ); printf ( \" \\n m\u00ednimo valor para un signed char: %d\" , SCHAR_MIN ); printf ( \" \\n m\u00e1ximo valor para un signed char %d\" , SCHAR_MAX ); printf ( \" \\n m\u00ednimo valor para un signed short %d\" , SHRT_MIN ); printf ( \" \\n m\u00e1ximo valor para un signed short %d\" , SHRT_MAX ); printf ( \" \\n m\u00e1ximo valor para un unsigned short %d\" , USHRT_MAX ); printf ( \" \\n m\u00ednimo valor para un int %d\" , INT_MIN ); printf ( \" \\n m\u00e1ximo valor para un int %d\" , INT_MAX ); printf ( \" \\n m\u00ednimo valor para un long %ld\" , LONG_MIN ); printf ( \" \\n m\u00e1ximo valor para un long %ld\" , LONG_MAX ); return 0 ; } Precedencia de los operadores Precedencia Operador Asociatividad 0 ()[] -> . izq. a derecha 1 sizeof (tipo) ! ~ ++ -- signo* & derecha a izq. 2 * / % izq. a derecha 3 + - izq. a derecha 4 > izq. a derecha 5 >= izq. a derecha 6 == != izq. a derecha 7 && izq. a derecha 8 = += -= *= etc derecha a izq. 4.5. Enumerados \u00b6 Un tipo enumerado permite definir un conjunto de constantes simb\u00f3licas con valor entero. Limita los posibles valores a los expresados expli\u0301citamente a trave\u0301s de una lista. Cada valor de la enumeracio\u0301n se asocia internamente a un nu\u0301mero entero, comenzando por 0 y aumentando de 1 en 1. 1 enum calificacion { suspenso , aprobado , notable , sobresaliente , matricula }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Programa que hace operaciones con d\u00edas de la semana int main () { enum DiasSemana { lunes , martes , miercoles , jueves , viernes , sabado , domingo }; enum DiasSemana dia ; // variable tipo enum dia = lunes ; printf ( \"Primer d\u00eda de la semana: %d \\n \" , dia ); //0 dia = martes ; printf ( \"Segundo d\u00eda de la semana: %d \\n \" , dia ); //1 dia = miercoles ; printf ( \"Tercer d\u00eda de la semana: %d \\n \" , dia ); //2 dia = jueves ; printf ( \"Cuarto d\u00eda de la semana: %d \\n \" , dia ); //3 dia = viernes ; printf ( \"Quinto d\u00eda de la semana: %d \\n \" , dia ); //4 dia = sabado ; printf ( \"Sexto d\u00eda de la semana: %d \\n \" , dia ); //5 dia = domingo ; printf ( \"Ultimo d\u00eda de la semana: %d \\n \" , dia ); //6 return 0 ; } Tambi\u00e9n podemos asignar un valor distinto a cada elemento de la enumeraci\u00f3n: 1 enum Respuesta { No = - 1 , Si = 1 }; Otro ejemplo: 1 2 3 4 enum paloPoker { pica , corazon , trebol , diamante }; enum paloPoker paloCarta ; //variable tipo enum paloCarta = corazon ; paloCarta = espada ; // Error! espada no definida en enum 5. Definici\u00f3n de tipos con typedef \u00b6 C permite que el programador defina sus propios tipos de datos mediante la palabra clave typedef . Esta palabra puede tener distintos usos, los iremos viendo conforme vayamos aprendiendo los distintos tipos de datos. Su funci\u00f3n es asignar un nombre alternativo (alias) a tipos existentes, a menudo cuando su declaraci\u00f3n normal es aparatosa, o potencialmente confusa. La sintaxis es: 1 typedef declaraci\u00f3n ; Ejemplo b\u00e1sico con int : 1 2 int notas ; notas = 100 ; Le damos un alias a int : 1 2 3 typedef int nota_alumno_t ; nota_alumno_t notas ; notas = 100 ; Ambas secciones de c\u00f3digo hacen lo mismo: crean un tipo int (notas) y le dan un valor de 100. La segunda secci\u00f3n es m\u00e1s legible. Es m\u00e1s \u00fatil usarlo con definiciones de tipos m\u00e1s complejas, como enum : 1 2 3 typedef enum { pica , corazon , trebol , diamante } TPaloPoker ; TPaloPoker paloCarta ; //variable tipo TPaloPoker paloCarta = corazon ; 6. Sentencias de entrada / salida \u00b6 Las sentencias de entrada permiten asociar a las variables valores aportados por el usuario. Por ejemplo, un programa que pida al usuario un precio en euros para convertirlo a pesetas. Las veremos m\u00e1s adelante. Las sentencias de salida permiten mostrar datos al usuario, incluyendo el valor de las variables. Por ejemplo, mostrar el precio una vez convertido a pesetas. 6.1. Salida: printf \u00b6 Permite imprimir en la pantalla en un formato determinado: cadenas de caracteres que se mostrara\u0301n conforme se hayan introducido variables que mostrara\u0301n su valor en base a un tipo indicado Las cadena de caracteres puede incluir valores especiales para introducir saltos de linea usando \\n Sintaxis 1 printf ( cadena de control , val1 , val2 , ..., valN ); La cadena de control debe ir entre comillas dobles. Ejemplo: \u201cHola mundo\u201d Si queremos mostrar el valor de una variable o valor, haremos uso de especificadores de formato (marcas) dentro de la cadena de control. Por cada marca debemos an\u0303adir una variable o valor. La marca determina co\u0301mo visualizar la variable (nu\u0301mero, base del numero, cifras decimales, etc). El valor puede ser el resultado de una operacio\u0301n Los c\u00f3digos de formato o marcas se definen usando %tipo . Los m\u00e1s comunes son: Formato Significa %d %i entero %c car\u00e1cter %f real %ld long %u unsigned %e real notaci\u00f3n cient\u00edfica Precisi\u00f3n Si a\u00f1adimos un .numero entre el % y el f podemos ajustar la cantidad de decimales que queremos mostrar: 1 printf ( \"La nota media es: %.3f\" , nota ); // 3 decimales Ejemplos: 1 2 3 4 5 6 7 int operandoA = 2 ; float operandoB = 5.4 ; printf ( \"La suma de %d + %f es: %f \\n \" , operandoA , operandoB , operandoA + operandoB ); // La suma de 2 + 5.400000 es: 7.400000 printf ( \"La suma de %d + %f es: %e \\n \" , operandoA , operandoB , operandoA + operandoB ); // La suma de 2 + 5.400000 es: 7.400000e+00 1 2 3 4 5 6 7 8 9 char inicial = 'g' ; printf ( \"El apellido ma\u0301s comu\u0301n es %carcia \\n \" , inicial ); // El apellido ma\u0301s comu\u0301n es garcia printf ( \"El apellido ma\u0301s comu\u0301n es \\n\\n %carcia \\n \" , inicial ); // El apellido ma\u0301s comu\u0301n es // garcia Ejemplo con tipo char: 1 2 3 4 5 6 7 char valorImprimir = 65 ; printf ( \"El valor de valorImprimir es: %c \\n \" , valorImprimir ); // El valor de valorImprimir es: A char valorImprimir = 'A' ; printf ( \"El valor de valorImprimir es: %d \\n \" , valorImprimir ); // El valor de valorImprimir es: 65 6.2. Entrada: scanf \u00b6 La sentencia scanf nos permite leer un dato que ha introducido el usuario desde teclado y almacenarlo en una variable. Se utilizan una serie de marcas, de forma ana\u0301loga a printf , para dar formato a la entrada en base a los tipos base. Sintaxis Su sintaxis es similar a printf : 1 scanf ( cadena de control , & var1 , & var2 , ..., & varN ); La cadena de control debe ir entre comillas dobles e incluir tantas marcas como valores queramos solicitar al usuario. Cada marca consta de un % y una letra indicando el tipo esperado. Ejemplo: \"%d %c\" : Esperamos que el usuario introduzca un entero y un cara\u0301cter simple Cada variable debe ir precedida de & , usado para el manejo de punteros (se vera\u0301 en futuros temas) La ejecucio\u0301n se detendra\u0301 cuando que el usuario haya introducido valores paras las N variables solicitadas Respecto a las marcas, utilizaremos los tipos usados con printf excepto en el tipo double que debemos usar %lf y el %u para enumerados. El resto se mantienen: %c para char , %d para int y %f para float . Ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <stdio.h> int main () { char letra ; char siguiente ; printf ( \"Introduce una letra: \" ); scanf ( \"%c\" , & letra ); printf ( \"El valor de letra es %c \\n \" , letra ); siguiente = letra + 1 ; printf ( \"La siguiente letra es %c \\n \" , siguiente ); return 0 ; } Ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // C\u00e1lculo el \u00edndice de masa corporal IMC de una persona double peso , imc ; int altura ; char nom , ap1 , ap2 ; printf ( \"Introduce tus iniciales \\n \" ); scanf ( \"%c %c %c\" , & nom , & ap1 , & ap2 ); printf ( \"Introduce tu altura en centi\u0301metros \\n \" ); scanf ( \"%d\" , & altura ); printf ( \"Introduce tu peso en kilos \\n \" ); scanf ( \"%lf\" , & peso ); printf ( \"Peso: %g kilogramos y Altura: %d,%d metros \\n \" , peso , ( altura / 100 ), altura % 100 ); imc = peso / (( altura / 100.0 ) * ( altura / 100.0 )); printf ( \"El IMC de %c%c%c es %g \\n \" , nom , ap1 , ap2 , imc ); Tenemos que tener cuidado cuando leamos caracteres utilizando scanf . Fijaros en el siguiente c\u00f3digo. \u00bfQu\u00e9 sucede? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main () { char c ; printf ( \"letra 1: \\n \" ); scanf ( \"%c\" , & c ); printf ( \"c = %c \\n \" , c ); printf ( \"letra 2: \\n \" ); scanf ( \"%c\" , & c ); printf ( \"c = %c \\n \" , c ); printf ( \"letra 3: \\n \" ); scanf ( \"%c\" , & c ); printf ( \"c = %c \\n \" , c ); return 0 ; } Si observamos la salida por pantalla, obtenemos: 1 2 3 4 5 6 7 8 letra 1 : s c = s letra 2 : c = letra 3 : a c = a \u00bfQu\u00e9 ha sucedido con la segunda entrada? Se ha saltado. \u00bfPor qu\u00e9? El scanf funciona mediante un buffer. Cuando tecleamos cualquier valor en el teclado y pulsamos 'intro', el \\n tambi\u00e9n es un car\u00e1cter ASCII y se queda almacenado en el buffer. De forma que si lo que leemos a continuaci\u00f3n es otro car\u00e1cter, se recoge el \\n que estaba en el buffer y se salta a la siguiente instrucci\u00f3n. Esto no sucede si lo que leemos es un entero u otro tipo de dato. Para solucionarlo, tenemos que quitar del buffer el \\n antes de leer cualquier car\u00e1cter. La forma m\u00e1s sencilla consiste en poner un \\n en el scanf antes del %c (s\u00f3lo cuando se lean caracteres): 1 scanf ( \" \\n %c\" , & c ); Tipos de datos en Python \u00b6 Ya vimos en el tema anterior que Python es un lenguaje d\u00e9bilmente tipado. Eso significa que cuando definimos una variable no tenemos que indicar de qu\u00e9 tipo es el dato que va almacenar, porque el int\u00e9rprete lo puede inferir, pero internamente s\u00ed que se trabaja con tipos datos. En Python, para saber de qu\u00e9 tipo es una variable tenemos la instrucci\u00f3n type . Los tipos de datos que encontramos en Python son muy similares a los de C (pero siempre son objetos): enteros, decimales, complejos, cadenas, etc. Tambi\u00e9n incluye otros como tuplas, listas, diccionarios, etc. Bibliograf\u00eda \u00b6 Cap\u00edtulos 3.7 a 3.12 de \"Programaci\u00f3n en C, metodolog\u00eda, algoritmos y estructuras de datos\", Luis Joyanes, Ignacio Zahonero Cap\u00edtulos 4.1 a 4.4, 4.8 y 4.9 de \"Fundamentos de Programaci\u00f3n\", Jes\u00fas Carretero y otros Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares Puig","title":"Tema 2: Tipos de datos simples"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#tema-2-tipos-de-datos-simples","text":"","title":"Tema 2: Tipos de datos simples"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#1-tipos-de-datos","text":"Los elementos b\u00e1sicos de los que consta un programa son: los datos las instrucciones que los procesan Los datos son los elementos que manipulan los programas. Para almacenar datos necesitamos zonas de memoria del ordenador. La memoria del ordenador est\u00e1 dividida en casillas numeradas en las que se guardan los datos. Los lenguajes de programaci\u00f3n nos permiten asignar nombres simb\u00f3licos a estas celdillas y controlar qu\u00e9 zonas de memoria est\u00e1n libres y ocupadas. El programador \u00fanicamente tiene que indicarle al ordenador el nombre de las zonas de memoria donde se quiere almacenar la informaci\u00f3n y de qu\u00e9 tipo es son los datos. A estas zonas de memoria les llamaremos variables . En un programa podemos distinguir entre: datos de entrada / salida: usados como punto de partida o resultado datos internos / auxiliares: usados por el programa para obtener el resultado Por ejemplo, en un programa que calcula la longitud de una circunferencia ( Dia\u0301metro * PI ) Dato de entrada: radio de la circunferencia Dato de salida: longitud de la circunferencia Datos internos: di\u00e1metro de la circunferencia, que toma como valor 2*radio de la circunferencia El lenguaje C es fuertemente tipado , eso significa que tenemos que asignar expl\u00edcitamente un tipo a cada dato. El tipo de un dato es el conjunto de valores que puede tomar durante el programa. La asignaci\u00f3n de tipos a los datos tiene cuatro objetivos principales: Determinar el rango de objetos que puede representar el dato. Conocer qu\u00e9 operaciones se pueden realizar con ellos Detectar errores en las operaciones Determinar c\u00f3mo ejecutar operaciones La clasificaci\u00f3n de los datos se hace teniendo en cuenta dos aspectos: Tama\u00f1o que ocupa en memoria fijo o variable: tipos est\u00e1ticos o din\u00e1micos N\u00famero de elementos que representan: tipos simples o estructurados Tipos est\u00e1ticos Ocupan un tama\u00f1o fijo en memoria, es decir, su tama\u00f1o no puede variar durante la ejecuci\u00f3n de un programa. Una vez declarada una variable de un tipo determinado, a \u00e9sta se le asigna un trozo de memoria fijo, y ese trozo no se podr\u00e1 aumentar ni disminuir. Tipos din\u00e1micos Tambi\u00e9n llamados punteros , los veremos m\u00e1s adelante. Un puntero no define un tipo determinado, sino que apunta a una direcci\u00f3n de memoria. Podemos reservar un tama\u00f1o determinado de memoria, ampliarlo, reducirlo y liberarlo. Tipos simples S\u00f3lo representan un dato, son los tipos b\u00e1sicos: entero, car\u00e1cter, real, etc. Tipos estructurados Est\u00e1n formados por un conjunto de elementos (tipos simples u otros estructurados). Los veremos en pr\u00f3ximos temas","title":"1. Tipos de datos"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#2-identificadores","text":"Un identificador es un nombre que se asigna a los distintos elementos de un programa: variables, funciones, etc. En lenguaje C son v\u00e1lidos los caracteres alfab\u00e9ticos en may\u00fasculas, min\u00fasculas, d\u00edgitos num\u00e9ricos (0..9) y el subrayado (_), aunque no pueden empezar por un n\u00famero. Las may\u00fasculas y min\u00fasculas se consideran caracteres distintos, el identificador hola es distinto a Hola . Ejemplo de identificadores v\u00e1lidos: 1 2 X Y12 sum_1 _temperature names area tax_rate TABLE Ejemplo de identificadores no v\u00e1lidos: 1 2 3 4 5 6 4 th /* El primer car\u00e1cter debe ser una letra o (_) */ \"x\" /* Car\u00e1cter no v\u00e1lido (\") */ num - orden /* Car\u00e1cter no v\u00e1lido (-) */ error flag /* Car\u00e1cter no v\u00e1lido (espacio) */ numero % 1 /* Car\u00e1cter no v\u00e1lido (%) */ numero $ 2 /* Car\u00e1cter no v\u00e1lido ($) */ Ejercicio : Indica qu\u00e9 identificadores son v\u00e1lidos en C: 1 2 3 casa mi - casa mi * casa micasa1 _MES MES_1 MES % 1 mes $ 1 a980 890 a _890 $ a890 Soluci\u00f3n: Son inv\u00e1lidos mi-casa mi*casa MES%1 mes$1 $a89 890a Las palabras reservadas son identificadores que tienen un significado especial para el compilador. Las palabras reservadas no se pueden usar como identificadores. Todas las palabras reservadas en C se escriben en min\u00fasculas. Palabras reservadas en C: 1 2 3 4 5 6 7 8 9 auto else long typedef break enum register union case extern return unsigned char float short void const for signed volatile continue goto sizeof while default if static _Bool do inline struct _Complex double int switch _Imaginary","title":"2. Identificadores"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#3-variables-y-constantes","text":"","title":"3. Variables y constantes"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#31-variables","text":"Las variables son espacios reservados en la memoria que, como su nombre indica, pueden cambiar de contenido a lo largo de la ejecuci\u00f3n de un programa. Una variable corresponde a un \u00e1rea reservada en la memoria principal del ordenador. Para que nuestro c\u00f3digo sea m\u00e1s entendible y claro, el identificador de la variable debe ser mnemot\u00e9cnico, es decir que debe reflejar el uso dentro del programa de la misma El tama\u00f1o de la zona de memoria, en bytes, depender\u00e1 del tipo de dato que se almacene en la variable. Todas las variables en C deben definirse antes de su uso. En una misma l\u00ednea se pueden declarar varias variables del mismo tipo. Sintaxis: 1 < tipo_de_datos > < nombre1 > [, < nombre2 > ,...]; Ejemplo: 1 2 3 4 int temperaturaHorno ; // variable tipo int long numeroTelefono ; // variable tipo long float interes ; // variable tipo float double nota1 , nota2 ; // variables tipo double","title":"3.1. Variables"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#4-tipos-de-datos-simples","text":"En C hay 8 tipos de datos simples o elementales, a partir de los cuales se construyen todos los dem\u00e1s. Estos tipos sirven para hacer operaciones aritm\u00e9ticas (num\u00e9ricos enteros o reales), representaci\u00f3n de caracteres (caracteres) y valores l\u00f3gicos (booleanos). Vamos a ver los tipos de datos simples, sus operadores asociados y el tama\u00f1o que ocupan en memoria.","title":"4. Tipos de datos simples"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#41-enteros","text":"Los tipos de datos que permiten representar n\u00fameros enteros en C son: 1 2 3 short int long Permiten representar n\u00fameros positivos y negativos sin partes decimales. Podemos utilizar el modificador previo unsigned para indicar que se trata de un n\u00famero positivo (sin signo).","title":"4.1. Enteros"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#42-reales","text":"Hay dos tipos n\u00fameros reales o n\u00fameros en coma flotante en C: 1 2 float double La representacio\u0301n interna de estos nu\u0301meros es diferente (uso de coma flotante), ya que los valores ma\u0301ximos y mi\u0301nimos no se obtienen so\u0301lo con los bytes. Adema\u0301s del rango (valores mi\u0301nimos y ma\u0301ximos), importa la precisio\u0301n (nu\u0301mero de cifras decimales): Tipo Bytes Valor m\u00ednimo Valor m\u00e1ximo Precisi\u00f3n float 4 -10 38 +10 38 7 cifras decimales double 8 -10 308 +10 308 15 cifras decimales","title":"4.2. Reales"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#43-caracter","text":"El tipo car\u00e1cter char permite representar valores consistentes en un \u00fanico car\u00e1cter, como 'a', 'z', 'B', '%', '5', etc. Los caracteres v\u00e1lidos son los que est\u00e1n incluidos en la tabla del est\u00e1ndar ASCII extendido. El est\u00e1ndar incluye 256 caracteres, por lo que se necesitan 8 bits (1 byte) para representar un car\u00e1cter en C.","title":"4.3. Car\u00e1cter"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#44-logico","text":"A diferencia de otros lenguajes, C no tiene un tipo booleano nativo. Necesitamos a\u00f1adir la cabecera: 1 #include <stdbool.h> Se maneja como nu\u0301mero de 1 byte (un bit seri\u0301a suficiente). Va\u0301lido para operaciones lo\u0301gicas.","title":"4.4. L\u00f3gico"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#45-enumerados","text":"Un tipo enumerado permite definir un conjunto de constantes simb\u00f3licas con valor entero. Limita los posibles valores a los expresados expli\u0301citamente a trave\u0301s de una lista. Cada valor de la enumeracio\u0301n se asocia internamente a un nu\u0301mero entero, comenzando por 0 y aumentando de 1 en 1. 1 enum calificacion { suspenso , aprobado , notable , sobresaliente , matricula }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Programa que hace operaciones con d\u00edas de la semana int main () { enum DiasSemana { lunes , martes , miercoles , jueves , viernes , sabado , domingo }; enum DiasSemana dia ; // variable tipo enum dia = lunes ; printf ( \"Primer d\u00eda de la semana: %d \\n \" , dia ); //0 dia = martes ; printf ( \"Segundo d\u00eda de la semana: %d \\n \" , dia ); //1 dia = miercoles ; printf ( \"Tercer d\u00eda de la semana: %d \\n \" , dia ); //2 dia = jueves ; printf ( \"Cuarto d\u00eda de la semana: %d \\n \" , dia ); //3 dia = viernes ; printf ( \"Quinto d\u00eda de la semana: %d \\n \" , dia ); //4 dia = sabado ; printf ( \"Sexto d\u00eda de la semana: %d \\n \" , dia ); //5 dia = domingo ; printf ( \"Ultimo d\u00eda de la semana: %d \\n \" , dia ); //6 return 0 ; } Tambi\u00e9n podemos asignar un valor distinto a cada elemento de la enumeraci\u00f3n: 1 enum Respuesta { No = - 1 , Si = 1 }; Otro ejemplo: 1 2 3 4 enum paloPoker { pica , corazon , trebol , diamante }; enum paloPoker paloCarta ; //variable tipo enum paloCarta = corazon ; paloCarta = espada ; // Error! espada no definida en enum","title":"4.5. Enumerados"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#5-definicion-de-tipos-con-typedef","text":"C permite que el programador defina sus propios tipos de datos mediante la palabra clave typedef . Esta palabra puede tener distintos usos, los iremos viendo conforme vayamos aprendiendo los distintos tipos de datos. Su funci\u00f3n es asignar un nombre alternativo (alias) a tipos existentes, a menudo cuando su declaraci\u00f3n normal es aparatosa, o potencialmente confusa. La sintaxis es: 1 typedef declaraci\u00f3n ; Ejemplo b\u00e1sico con int : 1 2 int notas ; notas = 100 ; Le damos un alias a int : 1 2 3 typedef int nota_alumno_t ; nota_alumno_t notas ; notas = 100 ; Ambas secciones de c\u00f3digo hacen lo mismo: crean un tipo int (notas) y le dan un valor de 100. La segunda secci\u00f3n es m\u00e1s legible. Es m\u00e1s \u00fatil usarlo con definiciones de tipos m\u00e1s complejas, como enum : 1 2 3 typedef enum { pica , corazon , trebol , diamante } TPaloPoker ; TPaloPoker paloCarta ; //variable tipo TPaloPoker paloCarta = corazon ;","title":"5. Definici\u00f3n de tipos con typedef"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#6-sentencias-de-entrada-salida","text":"Las sentencias de entrada permiten asociar a las variables valores aportados por el usuario. Por ejemplo, un programa que pida al usuario un precio en euros para convertirlo a pesetas. Las veremos m\u00e1s adelante. Las sentencias de salida permiten mostrar datos al usuario, incluyendo el valor de las variables. Por ejemplo, mostrar el precio una vez convertido a pesetas.","title":"6. Sentencias de entrada / salida"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#61-salida-printf","text":"Permite imprimir en la pantalla en un formato determinado: cadenas de caracteres que se mostrara\u0301n conforme se hayan introducido variables que mostrara\u0301n su valor en base a un tipo indicado Las cadena de caracteres puede incluir valores especiales para introducir saltos de linea usando \\n","title":"6.1. Salida: printf"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#62-entrada-scanf","text":"La sentencia scanf nos permite leer un dato que ha introducido el usuario desde teclado y almacenarlo en una variable. Se utilizan una serie de marcas, de forma ana\u0301loga a printf , para dar formato a la entrada en base a los tipos base.","title":"6.2. Entrada: scanf"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#tipos-de-datos-en-python","text":"Ya vimos en el tema anterior que Python es un lenguaje d\u00e9bilmente tipado. Eso significa que cuando definimos una variable no tenemos que indicar de qu\u00e9 tipo es el dato que va almacenar, porque el int\u00e9rprete lo puede inferir, pero internamente s\u00ed que se trabaja con tipos datos. En Python, para saber de qu\u00e9 tipo es una variable tenemos la instrucci\u00f3n type . Los tipos de datos que encontramos en Python son muy similares a los de C (pero siempre son objetos): enteros, decimales, complejos, cadenas, etc. Tambi\u00e9n incluye otros como tuplas, listas, diccionarios, etc.","title":"Tipos de datos en Python"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#bibliografia","text":"Cap\u00edtulos 3.7 a 3.12 de \"Programaci\u00f3n en C, metodolog\u00eda, algoritmos y estructuras de datos\", Luis Joyanes, Ignacio Zahonero Cap\u00edtulos 4.1 a 4.4, 4.8 y 4.9 de \"Fundamentos de Programaci\u00f3n\", Jes\u00fas Carretero y otros Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares Puig","title":"Bibliograf\u00eda"}]}