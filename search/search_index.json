{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Sitio web con los apuntes de teor\u00eda y pr\u00e1cticas de la asignatura Programaci\u00f3n 1 del Grado de Ingenier\u00eda Rob\u00f3tica de la Universidad de Alicante. Despliega el men\u00fa de la izquierda para consultar los apuntes. Otros enlaces: Ficha de la asignatura Plataforma docente Moodle Repositorio GitHub de estos apuntes","title":"Home"},{"location":"Practicas/practica00/practica00.html","text":"Pr\u00e1ctica 0: Entorno Linux y herramientas \u00b6 Objetivos de esta pr\u00e1ctica \u00b6 Conocer y comprender las herramientas necesarias para la realizaci\u00f3n de un programa Aprender a manejar las herramientas y el entorno seleccionado para las pr\u00e1cticas Sistema Operativo: Linux Editor de textos: Geany Compilador: gcc Compilar y ejecutar un primer programa Depurar los fallos encontrados Realizar y probar un programa \u00b6 Para realizar y probar un programa, debemos implementar el programa usando un editor de textos Compilar el programa para obtener un ejecutable, usando un compilador Ejecutar el programa (ejecutable) desde el sistema operativo Existen numerosos IDEs, o entornos integrados de desarrollo, que facilitan la tarea del desarrollador, tales como Eclipse, NetBeans, Visual Studio, IntelIiJ, etc En las pr\u00e1cticas, usaremos Geany como alternativa ligera y de licencia GPL entre el resto de opciones Sistema operativo Linux \u00b6 Las pr\u00e1cticas se desarrollar\u00e1n bajo el Sistema Operativo Linux Es posible usarlo a trav\u00e9s de una \"m\u00e1quina virtual\", permite emular un Sistema Operativo. Por ejemplo, para lanzar Windows desde Linux o viceversa Es importante conocer los comandos b\u00e1sicos para usar el terminal, as\u00ed como algunos conceptos base Diferencias entre may\u00fasculas y min\u00fasculas (case sensitive) Separador de carpetas en una ruta: / (en lugar de \\) Terminal de Linux \u00b6 Lanzar la terminal Desde el icono \u201cTerminal\u201d Combinaci\u00f3n de teclas \u201cCtrl+Alt+T\u201d Prompt: s\u00edmbolo $ Indica que el terminal esta listo para recibir comandos Sistema de ficheros: Raiz: / Carpeta de usuario: /home/username \u00f3 ~ Algunos comandos del terminal de Linux \u00b6 ls \u00b6 Muestra el contenido del directorio actual (nombres de ficheros y directorios) Se puede usar con modificadores, por ejemplo, ls -l muestra m\u00e1s detalles cd \u00b6 Para cambiar de directorio: cd nombreDirectorio Si no se indica nombre de directorio, nos movemos al /home del usuario cd .. subir un nivel en la jerarqu\u00eda de directorios pwd \u00b6 Muestra el nombre de la ruta actuaL mkdir \u00b6 Para crear directorios nuevos: mkdir directorio rm \u00b6 Para borrar ficheros: rm prueba.c rmdir \u00b6 Para borrar directorios que est\u00e9n vac\u00edos: rmdir directorio Si no est\u00e1n vac\u00edos: rmdir -r directorio cp \u00b6 Copia ficheros entre distintos directorios del disco duro: cp fichero.c practica0/. mv \u00b6 Renombra ficheros: mv fichero.c nuevoNombre.c clear \u00b6 Borra la pantalla man \u00b6 Muestra ayuda de un comando de linux: man comando Para mostrar ayuda de una funci\u00f3n del lenguaje C: man 3 funcionC find \u00b6 Buscar ficheros o directorios: find -name <opciones_busqueda> sudo \u00b6 Lanzar un comando como superusuario: sudo comando Instalaci\u00f3n de programas en Linux \u00b6 Existen repositorios de aplicaciones similares a \"Google Play\" 1 apt install < nombre_aplicacion > Es necesario lanzarla como root 1 2 sudo apt install geany sudo apt install gcc Editor de textos Geany \u00b6 Gesti\u00f3n de ficheros y edici\u00f3n est\u00e1ndar Nuevo, guardar como, buscar, reemplazar Editor de textos \u201cenriquecido\u201d Palabras clave aparecen con un color resaltado Opciones para programar Construir \u2192 Compilar | Construir | Ejecutar Sobre el fichero actual que contiene el programa Vista inferior Mensajes de salida, errores, vista de terminal, etc. Construir \u2192 Compilar Equivalente al comando gcc -c programa.c Genera un programa en c\u00f3digo objeto programa.o Construir \u2192 Construir Equivalente al comando gcc -o programa programa.c Compilar y enlazar Generar\u00e1 un ejecutable llamado programa (sin extensi\u00f3n) Construir \u2192 Ejecutar Equivalente a la ejecuci\u00f3n desde consola ./ejecutable Nuestro primer programa \u00b6 Antes de empezar, crea una carpeta en el sistema para alojar todos los ficheros 1 2 mkdir practica0 cd practica0 Accede a Moodle donde se encuentran los ficheros necesarios para realizar esta pr\u00e1ctica Descarga el fichero firstProgram.c en la carpeta practica0 Abrirlo desde Geany: Compilar y estudiar los ficheros generados Construir y estudiar los ficheros generados Ejecutar Eliminar todos los ficheros salvo el .c original Compilar, enlazar y ejecutar desde l\u00ednea de comandos (terminal) \u00b6 Abrir de nuevo el terminal y realiza las siguientes acciones: Compilar \u00fanicamente: 1 gcc - c firstProgram . c Compilar y enlazar generando ejecutable: 1 gcc - o ejecutable firstProgram . c Ejecutar el fichero generado: 1 . / ejectuable Descubriendo errores \u00b6 Descarga en la carpeta el fichero firstProgramErrorA.c y firstProgramErrorB.c Para cada fichero: Abre el fichero desde Geany y estudia las diferencias con respecto al programa original Intenta compilar (a\u00f1adir la opci\u00f3n -Wall nos ayuda). F\u00edjate que el Geany utiliza esta opci\u00f3n al compilar (observa la ventana donde muestra el resultado de la compilaci\u00f3n). Despu\u00e9s, desde l\u00ednea de comandos compila con la opci\u00f3n -Wall y sin dicha opci\u00f3n, y entiende para qu\u00e9 sirve. Estudia la salida obtenida por el compilador o el programa si la compilaci\u00f3n termin\u00f3 con \u00e9xito Encuentra el error y corr\u00edgelo Depuraci\u00f3n de programas \u00b6 Dos tipos de errores: Sint\u00e1cticos: los detecta el compilador. Se solucionan f\u00e1cilmente L\u00f3gicos: se producen en el dise\u00f1o del programa o en la implementaci\u00f3n sin que suponga un error de sintaxis. MUY DIF\u00cdCILES DE SOLUCIONAR Herramienta para la detecci\u00f3n de errores: Depurador o debugger gdb Programa externo. Trabaja con el ejecutable A\u00f1adimos la opci\u00f3n -g al compilar con gcc para incluir informaci\u00f3n de depurado en el ejecutable Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Antonio Bot\u00eda, Cristina Pomares","title":"Pr\u00e1ctica 0: Entorno Linux y herramientas"},{"location":"Practicas/practica00/practica00.html#practica-0-entorno-linux-y-herramientas","text":"","title":"Pr\u00e1ctica 0: Entorno Linux y herramientas"},{"location":"Practicas/practica00/practica00.html#objetivos-de-esta-practica","text":"Conocer y comprender las herramientas necesarias para la realizaci\u00f3n de un programa Aprender a manejar las herramientas y el entorno seleccionado para las pr\u00e1cticas Sistema Operativo: Linux Editor de textos: Geany Compilador: gcc Compilar y ejecutar un primer programa Depurar los fallos encontrados","title":"Objetivos de esta pr\u00e1ctica"},{"location":"Practicas/practica00/practica00.html#realizar-y-probar-un-programa","text":"Para realizar y probar un programa, debemos implementar el programa usando un editor de textos Compilar el programa para obtener un ejecutable, usando un compilador Ejecutar el programa (ejecutable) desde el sistema operativo Existen numerosos IDEs, o entornos integrados de desarrollo, que facilitan la tarea del desarrollador, tales como Eclipse, NetBeans, Visual Studio, IntelIiJ, etc En las pr\u00e1cticas, usaremos Geany como alternativa ligera y de licencia GPL entre el resto de opciones","title":"Realizar y probar un programa"},{"location":"Practicas/practica00/practica00.html#sistema-operativo-linux","text":"Las pr\u00e1cticas se desarrollar\u00e1n bajo el Sistema Operativo Linux Es posible usarlo a trav\u00e9s de una \"m\u00e1quina virtual\", permite emular un Sistema Operativo. Por ejemplo, para lanzar Windows desde Linux o viceversa Es importante conocer los comandos b\u00e1sicos para usar el terminal, as\u00ed como algunos conceptos base Diferencias entre may\u00fasculas y min\u00fasculas (case sensitive) Separador de carpetas en una ruta: / (en lugar de \\)","title":"Sistema operativo Linux"},{"location":"Practicas/practica00/practica00.html#terminal-de-linux","text":"Lanzar la terminal Desde el icono \u201cTerminal\u201d Combinaci\u00f3n de teclas \u201cCtrl+Alt+T\u201d Prompt: s\u00edmbolo $ Indica que el terminal esta listo para recibir comandos Sistema de ficheros: Raiz: / Carpeta de usuario: /home/username \u00f3 ~","title":"Terminal de Linux"},{"location":"Practicas/practica00/practica00.html#algunos-comandos-del-terminal-de-linux","text":"","title":"Algunos comandos del terminal de Linux"},{"location":"Practicas/practica00/practica00.html#ls","text":"Muestra el contenido del directorio actual (nombres de ficheros y directorios) Se puede usar con modificadores, por ejemplo, ls -l muestra m\u00e1s detalles","title":"ls"},{"location":"Practicas/practica00/practica00.html#cd","text":"Para cambiar de directorio: cd nombreDirectorio Si no se indica nombre de directorio, nos movemos al /home del usuario cd .. subir un nivel en la jerarqu\u00eda de directorios","title":"cd"},{"location":"Practicas/practica00/practica00.html#pwd","text":"Muestra el nombre de la ruta actuaL","title":"pwd"},{"location":"Practicas/practica00/practica00.html#mkdir","text":"Para crear directorios nuevos: mkdir directorio","title":"mkdir"},{"location":"Practicas/practica00/practica00.html#rm","text":"Para borrar ficheros: rm prueba.c","title":"rm"},{"location":"Practicas/practica00/practica00.html#rmdir","text":"Para borrar directorios que est\u00e9n vac\u00edos: rmdir directorio Si no est\u00e1n vac\u00edos: rmdir -r directorio","title":"rmdir"},{"location":"Practicas/practica00/practica00.html#cp","text":"Copia ficheros entre distintos directorios del disco duro: cp fichero.c practica0/.","title":"cp"},{"location":"Practicas/practica00/practica00.html#mv","text":"Renombra ficheros: mv fichero.c nuevoNombre.c","title":"mv"},{"location":"Practicas/practica00/practica00.html#clear","text":"Borra la pantalla","title":"clear"},{"location":"Practicas/practica00/practica00.html#man","text":"Muestra ayuda de un comando de linux: man comando Para mostrar ayuda de una funci\u00f3n del lenguaje C: man 3 funcionC","title":"man"},{"location":"Practicas/practica00/practica00.html#find","text":"Buscar ficheros o directorios: find -name <opciones_busqueda>","title":"find"},{"location":"Practicas/practica00/practica00.html#sudo","text":"Lanzar un comando como superusuario: sudo comando","title":"sudo"},{"location":"Practicas/practica00/practica00.html#instalacion-de-programas-en-linux","text":"Existen repositorios de aplicaciones similares a \"Google Play\" 1 apt install < nombre_aplicacion > Es necesario lanzarla como root 1 2 sudo apt install geany sudo apt install gcc","title":"Instalaci\u00f3n de programas en Linux"},{"location":"Practicas/practica00/practica00.html#editor-de-textos-geany","text":"Gesti\u00f3n de ficheros y edici\u00f3n est\u00e1ndar Nuevo, guardar como, buscar, reemplazar Editor de textos \u201cenriquecido\u201d Palabras clave aparecen con un color resaltado Opciones para programar Construir \u2192 Compilar | Construir | Ejecutar Sobre el fichero actual que contiene el programa Vista inferior Mensajes de salida, errores, vista de terminal, etc. Construir \u2192 Compilar Equivalente al comando gcc -c programa.c Genera un programa en c\u00f3digo objeto programa.o Construir \u2192 Construir Equivalente al comando gcc -o programa programa.c Compilar y enlazar Generar\u00e1 un ejecutable llamado programa (sin extensi\u00f3n) Construir \u2192 Ejecutar Equivalente a la ejecuci\u00f3n desde consola ./ejecutable","title":"Editor de textos Geany"},{"location":"Practicas/practica00/practica00.html#nuestro-primer-programa","text":"Antes de empezar, crea una carpeta en el sistema para alojar todos los ficheros 1 2 mkdir practica0 cd practica0 Accede a Moodle donde se encuentran los ficheros necesarios para realizar esta pr\u00e1ctica Descarga el fichero firstProgram.c en la carpeta practica0 Abrirlo desde Geany: Compilar y estudiar los ficheros generados Construir y estudiar los ficheros generados Ejecutar Eliminar todos los ficheros salvo el .c original","title":"Nuestro primer programa"},{"location":"Practicas/practica00/practica00.html#compilar-enlazar-y-ejecutar-desde-linea-de-comandos-terminal","text":"Abrir de nuevo el terminal y realiza las siguientes acciones: Compilar \u00fanicamente: 1 gcc - c firstProgram . c Compilar y enlazar generando ejecutable: 1 gcc - o ejecutable firstProgram . c Ejecutar el fichero generado: 1 . / ejectuable","title":"Compilar, enlazar y ejecutar desde  l\u00ednea de comandos (terminal)"},{"location":"Practicas/practica00/practica00.html#descubriendo-errores","text":"Descarga en la carpeta el fichero firstProgramErrorA.c y firstProgramErrorB.c Para cada fichero: Abre el fichero desde Geany y estudia las diferencias con respecto al programa original Intenta compilar (a\u00f1adir la opci\u00f3n -Wall nos ayuda). F\u00edjate que el Geany utiliza esta opci\u00f3n al compilar (observa la ventana donde muestra el resultado de la compilaci\u00f3n). Despu\u00e9s, desde l\u00ednea de comandos compila con la opci\u00f3n -Wall y sin dicha opci\u00f3n, y entiende para qu\u00e9 sirve. Estudia la salida obtenida por el compilador o el programa si la compilaci\u00f3n termin\u00f3 con \u00e9xito Encuentra el error y corr\u00edgelo","title":"Descubriendo errores"},{"location":"Practicas/practica00/practica00.html#depuracion-de-programas","text":"Dos tipos de errores: Sint\u00e1cticos: los detecta el compilador. Se solucionan f\u00e1cilmente L\u00f3gicos: se producen en el dise\u00f1o del programa o en la implementaci\u00f3n sin que suponga un error de sintaxis. MUY DIF\u00cdCILES DE SOLUCIONAR Herramienta para la detecci\u00f3n de errores: Depurador o debugger gdb Programa externo. Trabaja con el ejecutable A\u00f1adimos la opci\u00f3n -g al compilar con gcc para incluir informaci\u00f3n de depurado en el ejecutable Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Antonio Bot\u00eda, Cristina Pomares","title":"Depuraci\u00f3n de programas"},{"location":"Practicas/practica01/practica01.html","text":"Pr\u00e1ctica 1: Tipos de datos simples \u00b6 Ejercicio 1 \u00b6 El siguiente programa debe solicitar por teclado la edad, la inicial del nombre y la altura de una persona, y mostrar\u00e1 por pantalla su inicial y la suma de la edad y la altura. Completa la implementaci\u00f3n de este programa rellenando cada hueco con la sentencia adecuada. Despu\u00e9s de completarlo, comp\u00edlalo y ejec\u00fatalo para comprobar su correcto funcionamiento. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <stdio.h> int main () { ______________ ; ______________ ; ______________ ; printf ( \"Introduce tu edad: \" ); ________________________ ; printf ( \"Introduce la inicial de tu nombre: \" ); ________________________ ; printf ( \"Introduce tu altura en metros: \" ); ________________________ ; printf ( \" \\n\\n La inicial de tu nombre es: %c \\n \" , inicial ); printf ( \"La suma de tu edad y altura es: %.2f \\n \" , edad + altura ); return 0 ; } Ejercicio 2 \u00b6 Implementa un programa que solicite al usuario 3 caracteres y los muestre por pantalla en orden inverso al que han sido introducidos. Ejemplo de ejecuci\u00f3n: 1 2 3 4 Introduce 3 caracteres: a b c Los caracteres introducidos en orden inverso son: c b a Datos de entrada: 3 caracteres Casos de prueba: Datos de entrada Salida por pantalla a b c c b a 5 6 7 7 6 5 * > ? ? > * Ejercicio 3 \u00b6 Implementa un programa que solicite al usuario un n\u00famero de a\u00f1os y muestre por pantalla las horas, minutos y segundos que tienen esa cantidad de a\u00f1os. Ejemplo de ejecuci\u00f3n: 1 2 Introduce n\u00famero de a\u00f1os: 1 En 1 a\u00f1os hay 8760 horas, 525600 minutos y 31536000 segundos Dato de entrada: n\u00famero de a\u00f1os Casos de prueba: Datos de entrada Salida por pantalla 1 En 1 a\u00f1os hay 8760 horas, 525600 minutos y 31536000 segundos 20 En 20 a\u00f1os hay 175200 horas, 10512000 minutos, 630720000 segundos 100 En 100 a\u00f1os hay 876000 horas, 52560000 minutos, 3153600000 segundos Ejercicio 4 \u00b6 Implementa un programa que solicite al usuario las notas de los 3 ex\u00e1menes de la convocatoria de Enero y muestre por pantalla la nota final de la asignatura en dicha convocatoria, teniendo en cuenta que las ponderaciones de los 3 ex\u00e1menes son del 15%, 35% y 50% respectivamente. Ejemplo de ejecuci\u00f3n: 1 2 3 4 Introduce la nota del primer examen (temas 1 al 3): 4.3 Introduce la nota del segundo examen (temas 1 al 6): 5.5 Introduce la nota del tercer examen (temas 1 al 9): 5.0 La nota final en la convocatoria ordinaria de Enero es: 5.07 Datos de entrada: nota1 nota2 nota3 Casos de prueba: Datos de entrada Salida por pantalla 4.3 5.5 5.0 La nota final en la convocatoria ordinaria de Enero es: 5.07 7.0 4.0 3.5 La nota final en la convocatoria ordinaria de Enero es: 4.20 7.3 8.6 9.8 La nota final en la convocatoria ordinaria de Enero es: 9.00 Ejercicio 5 \u00b6 Escribe un programa que incluya un enumerado llamado TipoFigura con los tipos de figura circulo , cuadrado y triangulo . Despu\u00e9s imprime por pantalla el n\u00famero asignado por el enumerado a cada figura. Tienes que cambiar el n\u00famero por defecto. Ejemplo de ejecuci\u00f3n: 1 2 3 Circulo: 1 Triangulo: 2 Cuadrado: 3 Ejercicio 6 \u00b6 Escribe un programa que pida por teclado los v\u00e9rtices de un tri\u00e1ngulo y calcule e imprima por pantalla su per\u00edmetro (con dos decimales). Cada v\u00e9rtice consta de una coordenada x,y. Para leer por teclado dos datos seguidos separados por una coma, puedes utilizar el scanf de la siguiente forma: 1 scanf ( \"%d,%d\" , & x , & y ); Para calcular el per\u00edmetro, primero debes obtener los tres lados mediante el c\u00e1lculo de la distancia eucl\u00eddea entre los tres v\u00e9rtices. La f\u00f3rmula de la distancia eucl\u00eddea es: 1 distancia = sqrt (( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 )); sqrt es la funci\u00f3n que calcula la ra\u00edz cuadrada. Para utilizarla, debes incluir la librer\u00eda <math.h> a tu programa. Ejemplo de ejecuci\u00f3n: 1 2 3 4 Introduce el punto 1: 2,3 Introduce el punto 2: 4,5 Introduce el punto 3: 6,7 El per\u00edmetro del tri\u00e1ngulo cuyos lados son (2,3)--(4,5)--(6,7) es 11.31 Datos de entrada: x1,y1 x2,y2 x3,y3 Casos de prueba: Datos de entrada Salida por pantalla 2,3 4,5 6,7 El per\u00edmetro del tri\u00e1ngulo cuyos lados son (2,3)--(4,5)--(6,7) es 11.31 2,2 4,4 8,8 El per\u00edmetro del tri\u00e1ngulo cuyos lados son (2,2)--(4,4)--(8,8) es 16.97 8,4 3,5 7,6 El per\u00edmetro del tri\u00e1ngulo cuyos lados son (8,4)--(3,5)--(7,6) es 11.45 Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Antonio Bot\u00eda, Cristina Pomares","title":"Pr\u00e1ctica 1: Tipos de datos simples"},{"location":"Practicas/practica01/practica01.html#practica-1-tipos-de-datos-simples","text":"","title":"Pr\u00e1ctica 1: Tipos de datos simples"},{"location":"Practicas/practica01/practica01.html#ejercicio-1","text":"El siguiente programa debe solicitar por teclado la edad, la inicial del nombre y la altura de una persona, y mostrar\u00e1 por pantalla su inicial y la suma de la edad y la altura. Completa la implementaci\u00f3n de este programa rellenando cada hueco con la sentencia adecuada. Despu\u00e9s de completarlo, comp\u00edlalo y ejec\u00fatalo para comprobar su correcto funcionamiento. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <stdio.h> int main () { ______________ ; ______________ ; ______________ ; printf ( \"Introduce tu edad: \" ); ________________________ ; printf ( \"Introduce la inicial de tu nombre: \" ); ________________________ ; printf ( \"Introduce tu altura en metros: \" ); ________________________ ; printf ( \" \\n\\n La inicial de tu nombre es: %c \\n \" , inicial ); printf ( \"La suma de tu edad y altura es: %.2f \\n \" , edad + altura ); return 0 ; }","title":"Ejercicio 1"},{"location":"Practicas/practica01/practica01.html#ejercicio-2","text":"Implementa un programa que solicite al usuario 3 caracteres y los muestre por pantalla en orden inverso al que han sido introducidos. Ejemplo de ejecuci\u00f3n: 1 2 3 4 Introduce 3 caracteres: a b c Los caracteres introducidos en orden inverso son: c b a Datos de entrada: 3 caracteres Casos de prueba: Datos de entrada Salida por pantalla a b c c b a 5 6 7 7 6 5 * > ? ? > *","title":"Ejercicio 2"},{"location":"Practicas/practica01/practica01.html#ejercicio-3","text":"Implementa un programa que solicite al usuario un n\u00famero de a\u00f1os y muestre por pantalla las horas, minutos y segundos que tienen esa cantidad de a\u00f1os. Ejemplo de ejecuci\u00f3n: 1 2 Introduce n\u00famero de a\u00f1os: 1 En 1 a\u00f1os hay 8760 horas, 525600 minutos y 31536000 segundos Dato de entrada: n\u00famero de a\u00f1os Casos de prueba: Datos de entrada Salida por pantalla 1 En 1 a\u00f1os hay 8760 horas, 525600 minutos y 31536000 segundos 20 En 20 a\u00f1os hay 175200 horas, 10512000 minutos, 630720000 segundos 100 En 100 a\u00f1os hay 876000 horas, 52560000 minutos, 3153600000 segundos","title":"Ejercicio 3"},{"location":"Practicas/practica01/practica01.html#ejercicio-4","text":"Implementa un programa que solicite al usuario las notas de los 3 ex\u00e1menes de la convocatoria de Enero y muestre por pantalla la nota final de la asignatura en dicha convocatoria, teniendo en cuenta que las ponderaciones de los 3 ex\u00e1menes son del 15%, 35% y 50% respectivamente. Ejemplo de ejecuci\u00f3n: 1 2 3 4 Introduce la nota del primer examen (temas 1 al 3): 4.3 Introduce la nota del segundo examen (temas 1 al 6): 5.5 Introduce la nota del tercer examen (temas 1 al 9): 5.0 La nota final en la convocatoria ordinaria de Enero es: 5.07 Datos de entrada: nota1 nota2 nota3 Casos de prueba: Datos de entrada Salida por pantalla 4.3 5.5 5.0 La nota final en la convocatoria ordinaria de Enero es: 5.07 7.0 4.0 3.5 La nota final en la convocatoria ordinaria de Enero es: 4.20 7.3 8.6 9.8 La nota final en la convocatoria ordinaria de Enero es: 9.00","title":"Ejercicio 4"},{"location":"Practicas/practica01/practica01.html#ejercicio-5","text":"Escribe un programa que incluya un enumerado llamado TipoFigura con los tipos de figura circulo , cuadrado y triangulo . Despu\u00e9s imprime por pantalla el n\u00famero asignado por el enumerado a cada figura. Tienes que cambiar el n\u00famero por defecto. Ejemplo de ejecuci\u00f3n: 1 2 3 Circulo: 1 Triangulo: 2 Cuadrado: 3","title":"Ejercicio 5"},{"location":"Practicas/practica01/practica01.html#ejercicio-6","text":"Escribe un programa que pida por teclado los v\u00e9rtices de un tri\u00e1ngulo y calcule e imprima por pantalla su per\u00edmetro (con dos decimales). Cada v\u00e9rtice consta de una coordenada x,y. Para leer por teclado dos datos seguidos separados por una coma, puedes utilizar el scanf de la siguiente forma: 1 scanf ( \"%d,%d\" , & x , & y ); Para calcular el per\u00edmetro, primero debes obtener los tres lados mediante el c\u00e1lculo de la distancia eucl\u00eddea entre los tres v\u00e9rtices. La f\u00f3rmula de la distancia eucl\u00eddea es: 1 distancia = sqrt (( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 )); sqrt es la funci\u00f3n que calcula la ra\u00edz cuadrada. Para utilizarla, debes incluir la librer\u00eda <math.h> a tu programa. Ejemplo de ejecuci\u00f3n: 1 2 3 4 Introduce el punto 1: 2,3 Introduce el punto 2: 4,5 Introduce el punto 3: 6,7 El per\u00edmetro del tri\u00e1ngulo cuyos lados son (2,3)--(4,5)--(6,7) es 11.31 Datos de entrada: x1,y1 x2,y2 x3,y3 Casos de prueba: Datos de entrada Salida por pantalla 2,3 4,5 6,7 El per\u00edmetro del tri\u00e1ngulo cuyos lados son (2,3)--(4,5)--(6,7) es 11.31 2,2 4,4 8,8 El per\u00edmetro del tri\u00e1ngulo cuyos lados son (2,2)--(4,4)--(8,8) es 16.97 8,4 3,5 7,6 El per\u00edmetro del tri\u00e1ngulo cuyos lados son (8,4)--(3,5)--(7,6) es 11.45 Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Antonio Bot\u00eda, Cristina Pomares","title":"Ejercicio 6"},{"location":"Practicas/practica02/practica02.html","text":"Pr\u00e1ctica 2: Sentencias de selecci\u00f3n \u00b6 Ejercicio 1 \u00b6 Implementa un programa que solicite un car\u00e1cter e imprima un mensaje que indique qu\u00e9 tipo de car\u00e1cter es, teniendo en cuenta que el programa debe reconocer caracteres de tipo d\u00edgito, letras min\u00fasculas y letras may\u00fasculas. Ante cualquier otro tipo de car\u00e1cter, el programa indicar\u00e1 que es desconocido. Ejemplo de ejecuci\u00f3n: 1 2 Introduce un car\u00e1cter: a El car\u00e1cter introducido es una letra min\u00fascula Datos de entrada: un car\u00e1cter Casos de prueba: Datos de entrada Salida por pantalla a El car\u00e1cter introducido es una letra min\u00fascula 4 El car\u00e1cter introducido es un d\u00edgito % El car\u00e1cter introducido es desconocido F El car\u00e1cter introducido es una letra may\u00fascula Ejercicio 2 \u00b6 Escribe un programa que indique el n\u00famero de d\u00edas que tiene un mes suponiendo que el a\u00f1o no es bisiesto. El usuario debe introducir un n\u00famero de mes por teclado (0-enero, 11-diciembre) y suponemos que siempre se introduce un n\u00famero correcto. El programa debe imprimir por pantalla el n\u00famero de d\u00edas que tiene ese mes. Utiliza typedef para definir un enumerado TMeses , puedes hacerlo fuera del main de forma global. Ejemplo de ejecuci\u00f3n: 1 2 3 Introduce n\u00famero de un mes 0 (enero), 11 (diciembre): 3 El mes n\u00famero 3 tiene 31 d\u00edas Dato de entrada: n\u00famero de mes 0-11 Casos de prueba: Datos de entrada Salida por pantalla 3 El mes n\u00famero 3 tiene 30 d\u00edas 11 El mes n\u00famero 11 tiene 31 d\u00edas 1 El mes n\u00famero 1 tiene 28 d\u00edas Ejercicio 3 \u00b6 Utilizando el tipo enumerado TipoFigura del ejercicio 5 de la pr\u00e1ctica anterior, escribe un programa que solicite por teclado una de las tres figuras y calcule e imprima su \u00e1rea correspondiente. Para ellos deber\u00e1 solicitar los datos necesarios de cada figura. Utiliza typedef para definir el enumerado TipoFigura , puedes hacerlo fuera del main de forma global. Ejemplos de ejecuci\u00f3n: 1 2 3 4 5 6 7 1-Circulo 2-Triangulo 3-Cuadrado Introduce figura: 1 Introduce di\u00e1metro (ancho) del c\u00edrculo: 30 El area es: 706.86 Datos de entrada: tipo figura , ancho , [alto] C\u00edrculo , ancho Tri\u00e1ngulo , ancho , alto Cuadrado , ancho Casos de prueba: Datos de entrada Salida por pantalla 1 30 El \u00e1rea es: 706.86 2 23 30 El \u00e1rea es: 345.00 3 20 El \u00e1rea es: 400.00 Ejercicio 4 \u00b6 Implementa un programa que calcule la nota final de la asignatura. En primer lugar se debe solicitar la convocatoria, 'E' si se trata de la de Enero o 'J' si se trata de Julio. Si no se teclea ninguna de ellas, se mostrar\u00e1 un mensaje en el que se indique que es incorrecta. La nota final de la convocatoria de Enero se calcula tal y como est\u00e1 explicado en el ejercicio 4 de la pr\u00e1ctica 1.La nota final de la convocatoria de Julio consiste en un \u00fanico examen. Adem\u00e1s de la nota num\u00e9rica, deber\u00e1 aparecer su descripci\u00f3n literal equivalente, teniendo en cuenta: 0 <= nota < 5 ==> SUSPENSO 5 <= nota < 7 ==> APROBADO 7 <= nota < 9 ==> NOTABLE nota >= 9 ==> SOBRESALIENTE Ejemplo de ejecuci\u00f3n: 1 2 3 4 5 Dime la convocatoria(E,J):E Introduce la nota del primer examen (temas 1 al 3): 7.3 Introduce la nota del segundo examen (temas 1 al 6): 8.4 Introduce la nota del tercer examen (temas 1 al 9): 6.5 La nota final en la asignatura es: 7.28 NOTABLE Datos de entrada: convocatoria , nota1 , [nota2] , [nota3] Casos de prueba: Datos de entrada Salida por pantalla E 7.3 8.4 6.5 La nota final en la asignatura es: 7.28 NOTABLE J 9.3 La nota final en la asignatura es: 9.30 SOBRESALIENTE E 4.5 3.7 2.5. La nota final en la asignatura es: 3.22 SUSPENSO x La convocatoria introducida es incorrecta Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Antonio Bot\u00eda, Cristina Pomares","title":"Pr\u00e1ctica 2: Sentencias de selecci\u00f3n"},{"location":"Practicas/practica02/practica02.html#practica-2-sentencias-de-seleccion","text":"","title":"Pr\u00e1ctica 2: Sentencias de selecci\u00f3n"},{"location":"Practicas/practica02/practica02.html#ejercicio-1","text":"Implementa un programa que solicite un car\u00e1cter e imprima un mensaje que indique qu\u00e9 tipo de car\u00e1cter es, teniendo en cuenta que el programa debe reconocer caracteres de tipo d\u00edgito, letras min\u00fasculas y letras may\u00fasculas. Ante cualquier otro tipo de car\u00e1cter, el programa indicar\u00e1 que es desconocido. Ejemplo de ejecuci\u00f3n: 1 2 Introduce un car\u00e1cter: a El car\u00e1cter introducido es una letra min\u00fascula Datos de entrada: un car\u00e1cter Casos de prueba: Datos de entrada Salida por pantalla a El car\u00e1cter introducido es una letra min\u00fascula 4 El car\u00e1cter introducido es un d\u00edgito % El car\u00e1cter introducido es desconocido F El car\u00e1cter introducido es una letra may\u00fascula","title":"Ejercicio 1"},{"location":"Practicas/practica02/practica02.html#ejercicio-2","text":"Escribe un programa que indique el n\u00famero de d\u00edas que tiene un mes suponiendo que el a\u00f1o no es bisiesto. El usuario debe introducir un n\u00famero de mes por teclado (0-enero, 11-diciembre) y suponemos que siempre se introduce un n\u00famero correcto. El programa debe imprimir por pantalla el n\u00famero de d\u00edas que tiene ese mes. Utiliza typedef para definir un enumerado TMeses , puedes hacerlo fuera del main de forma global. Ejemplo de ejecuci\u00f3n: 1 2 3 Introduce n\u00famero de un mes 0 (enero), 11 (diciembre): 3 El mes n\u00famero 3 tiene 31 d\u00edas Dato de entrada: n\u00famero de mes 0-11 Casos de prueba: Datos de entrada Salida por pantalla 3 El mes n\u00famero 3 tiene 30 d\u00edas 11 El mes n\u00famero 11 tiene 31 d\u00edas 1 El mes n\u00famero 1 tiene 28 d\u00edas","title":"Ejercicio 2"},{"location":"Practicas/practica02/practica02.html#ejercicio-3","text":"Utilizando el tipo enumerado TipoFigura del ejercicio 5 de la pr\u00e1ctica anterior, escribe un programa que solicite por teclado una de las tres figuras y calcule e imprima su \u00e1rea correspondiente. Para ellos deber\u00e1 solicitar los datos necesarios de cada figura. Utiliza typedef para definir el enumerado TipoFigura , puedes hacerlo fuera del main de forma global. Ejemplos de ejecuci\u00f3n: 1 2 3 4 5 6 7 1-Circulo 2-Triangulo 3-Cuadrado Introduce figura: 1 Introduce di\u00e1metro (ancho) del c\u00edrculo: 30 El area es: 706.86 Datos de entrada: tipo figura , ancho , [alto] C\u00edrculo , ancho Tri\u00e1ngulo , ancho , alto Cuadrado , ancho Casos de prueba: Datos de entrada Salida por pantalla 1 30 El \u00e1rea es: 706.86 2 23 30 El \u00e1rea es: 345.00 3 20 El \u00e1rea es: 400.00","title":"Ejercicio 3"},{"location":"Practicas/practica02/practica02.html#ejercicio-4","text":"Implementa un programa que calcule la nota final de la asignatura. En primer lugar se debe solicitar la convocatoria, 'E' si se trata de la de Enero o 'J' si se trata de Julio. Si no se teclea ninguna de ellas, se mostrar\u00e1 un mensaje en el que se indique que es incorrecta. La nota final de la convocatoria de Enero se calcula tal y como est\u00e1 explicado en el ejercicio 4 de la pr\u00e1ctica 1.La nota final de la convocatoria de Julio consiste en un \u00fanico examen. Adem\u00e1s de la nota num\u00e9rica, deber\u00e1 aparecer su descripci\u00f3n literal equivalente, teniendo en cuenta: 0 <= nota < 5 ==> SUSPENSO 5 <= nota < 7 ==> APROBADO 7 <= nota < 9 ==> NOTABLE nota >= 9 ==> SOBRESALIENTE Ejemplo de ejecuci\u00f3n: 1 2 3 4 5 Dime la convocatoria(E,J):E Introduce la nota del primer examen (temas 1 al 3): 7.3 Introduce la nota del segundo examen (temas 1 al 6): 8.4 Introduce la nota del tercer examen (temas 1 al 9): 6.5 La nota final en la asignatura es: 7.28 NOTABLE Datos de entrada: convocatoria , nota1 , [nota2] , [nota3] Casos de prueba: Datos de entrada Salida por pantalla E 7.3 8.4 6.5 La nota final en la asignatura es: 7.28 NOTABLE J 9.3 La nota final en la asignatura es: 9.30 SOBRESALIENTE E 4.5 3.7 2.5. La nota final en la asignatura es: 3.22 SUSPENSO x La convocatoria introducida es incorrecta Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Antonio Bot\u00eda, Cristina Pomares","title":"Ejercicio 4"},{"location":"Practicas/practica03/practica03.html","text":"Pr\u00e1ctica 3: Sentencias de iteraci\u00f3n \u00b6 Ejercicio 1 \u00b6 Escribe un programa que invierta los d\u00edgitos de un entero positivo solicitado por teclado (hay que validar el dato) y lo almacene en una variable. La variable que contiene el n\u00famero invertido se mostrar\u00e1 por pantalla posteriormente. Para obtener el n\u00famero invertido, de debe empezar en el n\u00famero 0 e ir a\u00f1adi\u00e9ndole las cifras por la derecha: Obtener el \u00faltimo d\u00edgito A\u00f1adirlo al n\u00famero invertido (tener en cuenta las decenas, centenas, etc). Reducir en un d\u00edgito el n\u00famero original Se repetir\u00e1 este proceso hasta que el n\u00famero original no tenga d\u00edgitos. Pista: debes usar las operaciones /10 %10 *10 . Ejemplo de ejecuci\u00f3n: 1 2 Introduce un numero positivo:123456 El n\u00famero invertido es: 654321 Datos de entrada: n\u00famero positivo Casos de prueba: Datos de entrada Salida por pantalla -321 se vuelve a solicitar 123456 654321 21334111 11143312 1 1 Ejercicio 2 \u00b6 Implementa un programa que calcule el resultado acumulado de aplicar sucesivas operaciones aritm\u00e9ticas. El programa inicialmente solicitar\u00e1 un n\u00famero entero y a continuaci\u00f3n ir\u00e1 solicitando un operador aritm\u00e9tico y el siguiente operando, acumulando el resultado para la siguiente operaci\u00f3n. Los operadores aritm\u00e9ticos permitidos ser\u00e1n \u2018+\u2019, \u2018-\u2018, \u2018*\u2019, \u2018/\u2018. En caso de introducir un operador incorrecto, se volver\u00e1 a pedir. El programa deber\u00e1 terminar cuando el car\u00e1cter introducido como operador sea un punto \u2018.\u2019 Hay que tener en cuenta que no se puede hacer una divisi\u00f3n por cero, en cuyo caso se mostrar\u00e1 el mensaje \u201cError: divisi\u00f3n por cero\u201d y se solicitar\u00e1 la siguiente operaci\u00f3n a realizar. Ejemplo de ejecuci\u00f3n: 1 2 3 4 5 6 7 8 9 Introduce un n\u00famero: 4 Introduce operador aritm\u00e9tico ('.' para terminar): + Introduce un n\u00famero: 6 El resultado parcial acumulado es: 10 Introduce operador aritm\u00e9tico ('.' para terminar): / Introduce un n\u00famero: 5 El resultado parcial acumulado es: 2 Introduce operador aritm\u00e9tico ('.' para terminar): . El resultado final acumulado es: 2 Casos de prueba: Datos de entrada: 25 . Resultado esperado (salida por pantalla): 1 2 3 Introduce un n\u00famero: 25 Introduce operador aritm\u00e9tico ('.' para terminar): . El resultado final acumulado es: 25 Datos de entrada: 34 - 14 / 0 . Resultado esperado (salida por pantalla): 1 2 3 4 5 6 7 8 9 10 11 Introduce un n\u00famero: 34 Introduce operador aritm\u00e9tico ('.' para terminar): - Introduce un n\u00famero: 14 El resultado parcial acumulado es: 20 Introduce operador aritm\u00e9tico ('.' para terminar): % Introduce operador aritm\u00e9tico ('.' para terminar): / Introduce un n\u00famero: 0 Error: divisi\u00f3n por cero El resultado parcial acumulado es: 20 Introduce operador aritm\u00e9tico ('.' para terminar): . El resultado final acumulado es: 20 Ejercicio 3 \u00b6 Escribe un programa que pida un n\u00famero positivo e impar (hay que validar el dato), y en base a \u00e9l imprima la figura que se indica en el ejemplo. El n\u00famero m\u00e1ximo de columnas siempre es fijo: 4. Ejemplo de ejecuci\u00f3n: 1 2 3 4 5 6 7 8 Introduce un n\u00famero: 7 1 1 2 1 2 3 1 2 3 4 1 2 3 1 2 1 Datos de entrada: n\u00famero impar Casos de prueba: Datos de entrada: 5 Resultado esperado (salida por pantalla): 1 2 3 4 5 6 Introduce un n\u00famero: 5 1 1 2 1 2 3 1 2 1 Datos de entrada: 9 Resultado esperado (salida por pantalla): 1 2 3 4 5 6 7 8 9 10 Introduce un n\u00famero: 9 1 1 2 1 2 3 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 1 2 1 Ejercicio 4 \u00b6 Implementa un programa que dibuje en pantalla el n\u00famero 10 con un alto y ancho especificado. Inicialmente se pedir\u00e1 el alto y ancho cuyos valores deben est\u00e1n incluidos en los intervalos [15..30] y [8..20] respectivamente. Se validar\u00e1n dichos valores introducidos y cuando sean correctos, se proceder\u00e1 a dibujar el n\u00famero 10. Utilizaremos \u2018#\u2019 como car\u00e1cter de relleno, y \u2018.\u2019 como car\u00e1cter de fondo (en vez de usar el car\u00e1cter blanco \u2018 \u2018). Los dos d\u00edgitos estar\u00e1n espaciados por 5 caracteres. Para dibujar la diagonal del n\u00famero 1, usaremos la mitad del ancho especificado. Ejemplo de ejecuci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Introduce alto [15..30] y ancho [8..20] de los n\u00fameros: 15 10 ....#.....########## ...##.....#........# ..#.#.....#........# .#..#.....#........# #...#.....#........# ....#.....#........# ....#.....#........# ....#.....#........# ....#.....#........# ....#.....#........# ....#.....#........# ....#.....#........# ....#.....#........# ....#.....#........# ....#.....########## Datos de entrada: dos n\u00fameros enteros Casos de prueba: Datos de entrada: 20 5 20 8 Resultado esperado (salida por pantalla): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Introduce alto [15..30] y ancho [8..20] de los n\u00fameros: 20 5 Introduce alto [15..30] y ancho [8..20] de los n\u00fameros: 20 8 ...#.....######## ..##.....#......# .#.#.....#......# #..#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....######## Datos de entrada: 15 20 Resultado esperado (salida por pantalla): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Introduce alto [15..30] y ancho [8..20] de los n\u00fameros: 15 20 .........#.....#################### ........##.....#..................# .......#.#.....#..................# ......#..#.....#..................# .....#...#.....#..................# ....#....#.....#..................# ...#.....#.....#..................# ..#......#.....#..................# .#.......#.....#..................# #........#.....#..................# .........#.....#..................# .........#.....#..................# .........#.....#..................# .........#.....#..................# .........#.....#################### Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Antonio Bot\u00eda, Cristina Pomares","title":"Pr\u00e1ctica 3: Sentencias de interaci\u00f3n"},{"location":"Practicas/practica03/practica03.html#practica-3-sentencias-de-iteracion","text":"","title":"Pr\u00e1ctica 3: Sentencias de iteraci\u00f3n"},{"location":"Practicas/practica03/practica03.html#ejercicio-1","text":"Escribe un programa que invierta los d\u00edgitos de un entero positivo solicitado por teclado (hay que validar el dato) y lo almacene en una variable. La variable que contiene el n\u00famero invertido se mostrar\u00e1 por pantalla posteriormente. Para obtener el n\u00famero invertido, de debe empezar en el n\u00famero 0 e ir a\u00f1adi\u00e9ndole las cifras por la derecha: Obtener el \u00faltimo d\u00edgito A\u00f1adirlo al n\u00famero invertido (tener en cuenta las decenas, centenas, etc). Reducir en un d\u00edgito el n\u00famero original Se repetir\u00e1 este proceso hasta que el n\u00famero original no tenga d\u00edgitos. Pista: debes usar las operaciones /10 %10 *10 . Ejemplo de ejecuci\u00f3n: 1 2 Introduce un numero positivo:123456 El n\u00famero invertido es: 654321 Datos de entrada: n\u00famero positivo Casos de prueba: Datos de entrada Salida por pantalla -321 se vuelve a solicitar 123456 654321 21334111 11143312 1 1","title":"Ejercicio 1"},{"location":"Practicas/practica03/practica03.html#ejercicio-2","text":"Implementa un programa que calcule el resultado acumulado de aplicar sucesivas operaciones aritm\u00e9ticas. El programa inicialmente solicitar\u00e1 un n\u00famero entero y a continuaci\u00f3n ir\u00e1 solicitando un operador aritm\u00e9tico y el siguiente operando, acumulando el resultado para la siguiente operaci\u00f3n. Los operadores aritm\u00e9ticos permitidos ser\u00e1n \u2018+\u2019, \u2018-\u2018, \u2018*\u2019, \u2018/\u2018. En caso de introducir un operador incorrecto, se volver\u00e1 a pedir. El programa deber\u00e1 terminar cuando el car\u00e1cter introducido como operador sea un punto \u2018.\u2019 Hay que tener en cuenta que no se puede hacer una divisi\u00f3n por cero, en cuyo caso se mostrar\u00e1 el mensaje \u201cError: divisi\u00f3n por cero\u201d y se solicitar\u00e1 la siguiente operaci\u00f3n a realizar. Ejemplo de ejecuci\u00f3n: 1 2 3 4 5 6 7 8 9 Introduce un n\u00famero: 4 Introduce operador aritm\u00e9tico ('.' para terminar): + Introduce un n\u00famero: 6 El resultado parcial acumulado es: 10 Introduce operador aritm\u00e9tico ('.' para terminar): / Introduce un n\u00famero: 5 El resultado parcial acumulado es: 2 Introduce operador aritm\u00e9tico ('.' para terminar): . El resultado final acumulado es: 2 Casos de prueba: Datos de entrada: 25 . Resultado esperado (salida por pantalla): 1 2 3 Introduce un n\u00famero: 25 Introduce operador aritm\u00e9tico ('.' para terminar): . El resultado final acumulado es: 25 Datos de entrada: 34 - 14 / 0 . Resultado esperado (salida por pantalla): 1 2 3 4 5 6 7 8 9 10 11 Introduce un n\u00famero: 34 Introduce operador aritm\u00e9tico ('.' para terminar): - Introduce un n\u00famero: 14 El resultado parcial acumulado es: 20 Introduce operador aritm\u00e9tico ('.' para terminar): % Introduce operador aritm\u00e9tico ('.' para terminar): / Introduce un n\u00famero: 0 Error: divisi\u00f3n por cero El resultado parcial acumulado es: 20 Introduce operador aritm\u00e9tico ('.' para terminar): . El resultado final acumulado es: 20","title":"Ejercicio 2"},{"location":"Practicas/practica03/practica03.html#ejercicio-3","text":"Escribe un programa que pida un n\u00famero positivo e impar (hay que validar el dato), y en base a \u00e9l imprima la figura que se indica en el ejemplo. El n\u00famero m\u00e1ximo de columnas siempre es fijo: 4. Ejemplo de ejecuci\u00f3n: 1 2 3 4 5 6 7 8 Introduce un n\u00famero: 7 1 1 2 1 2 3 1 2 3 4 1 2 3 1 2 1 Datos de entrada: n\u00famero impar Casos de prueba: Datos de entrada: 5 Resultado esperado (salida por pantalla): 1 2 3 4 5 6 Introduce un n\u00famero: 5 1 1 2 1 2 3 1 2 1 Datos de entrada: 9 Resultado esperado (salida por pantalla): 1 2 3 4 5 6 7 8 9 10 Introduce un n\u00famero: 9 1 1 2 1 2 3 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 1 2 1","title":"Ejercicio 3"},{"location":"Practicas/practica03/practica03.html#ejercicio-4","text":"Implementa un programa que dibuje en pantalla el n\u00famero 10 con un alto y ancho especificado. Inicialmente se pedir\u00e1 el alto y ancho cuyos valores deben est\u00e1n incluidos en los intervalos [15..30] y [8..20] respectivamente. Se validar\u00e1n dichos valores introducidos y cuando sean correctos, se proceder\u00e1 a dibujar el n\u00famero 10. Utilizaremos \u2018#\u2019 como car\u00e1cter de relleno, y \u2018.\u2019 como car\u00e1cter de fondo (en vez de usar el car\u00e1cter blanco \u2018 \u2018). Los dos d\u00edgitos estar\u00e1n espaciados por 5 caracteres. Para dibujar la diagonal del n\u00famero 1, usaremos la mitad del ancho especificado. Ejemplo de ejecuci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Introduce alto [15..30] y ancho [8..20] de los n\u00fameros: 15 10 ....#.....########## ...##.....#........# ..#.#.....#........# .#..#.....#........# #...#.....#........# ....#.....#........# ....#.....#........# ....#.....#........# ....#.....#........# ....#.....#........# ....#.....#........# ....#.....#........# ....#.....#........# ....#.....#........# ....#.....########## Datos de entrada: dos n\u00fameros enteros Casos de prueba: Datos de entrada: 20 5 20 8 Resultado esperado (salida por pantalla): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Introduce alto [15..30] y ancho [8..20] de los n\u00fameros: 20 5 Introduce alto [15..30] y ancho [8..20] de los n\u00fameros: 20 8 ...#.....######## ..##.....#......# .#.#.....#......# #..#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....#......# ...#.....######## Datos de entrada: 15 20 Resultado esperado (salida por pantalla): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Introduce alto [15..30] y ancho [8..20] de los n\u00fameros: 15 20 .........#.....#################### ........##.....#..................# .......#.#.....#..................# ......#..#.....#..................# .....#...#.....#..................# ....#....#.....#..................# ...#.....#.....#..................# ..#......#.....#..................# .#.......#.....#..................# #........#.....#..................# .........#.....#..................# .........#.....#..................# .........#.....#..................# .........#.....#..................# .........#.....#################### Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Antonio Bot\u00eda, Cristina Pomares","title":"Ejercicio 4"},{"location":"Teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html","text":"Programaci\u00f3n 1. Grado de Rob\u00f3tica. Curso 2019-2020 \u00b6 Toda la informaci\u00f3n est\u00e1 disponible en el sitio Moodle de P1 y en la ficha del campus virtual . Datos acad\u00e9micos de la asignatura \u00b6 Departamento de Ciencia de la Computaci\u00f3n e Inteligencia Artificial 6 cr\u00e9ditos ECTS : 1 clase de teor\u00eda de 2 h. y 1 clase de pr\u00e1cticas de 2 h. a la semana Profesores : Antonio Bot\u00eda ( e-mail ): Grupos de pr\u00e1cticas: 2 y 3. Cristina Pomares ( e-mail ): Grupo de teor\u00eda: 1. Grupos de pr\u00e1cticas: 1 y 4. Recursos de la asignatura \u00b6 Sitio Moodle contiene los apuntes, transparencias, pr\u00e1cticas y otros materiales docentes Foro de consultas y anuncios en el sitio Moodle Objetivos y competencias \u00b6 Objetivos : Dominar los principios de la programaci\u00f3n procedural. Resolver problemas de programaci\u00f3n b\u00e1sica aplicando adecuadamente los tipos de datos elementales, los tipos de datos estructurados y las estructuras de control. Asimilar el concepto programaci\u00f3n modular y saber aplicarlo en la resoluci\u00f3n de problemas. Conocer el concepto de recursividad, aplic\u00e1ndolo a problemas sencillos. Comprender el concepto de fichero y saber utilizarlos. Ser capaz de utilizar herramientas de programaci\u00f3n para editar, compilar, ejecutar y verificar un programa. Analizar problemas susceptibles de resoluci\u00f3n por un ordenador y dise\u00f1ar algoritmos que los solucionen. Implementar algoritmos mediante t\u00e9cnicas de programaci\u00f3n estructurada y modular. Saber realizar programas de ordenador que capturen y env\u00eden informaci\u00f3n a un sistema rob\u00f3tico. Competencias : Interpretar el funcionamiento del c\u00f3digo fuente de un programa. Definir los tipos de datos necesarios para la representaci\u00f3n de la informaci\u00f3n. Dise\u00f1ar algoritmos y codificarlos con distintas t\u00e9cnicas de programaci\u00f3n, especialmente en sistemas rob\u00f3ticos. Verificar el correcto funcionamiento de un programa. Temario \u00b6 Tema 1. Introducci\u00f3n a la programaci\u00f3n : Representaci\u00f3n de la informaci\u00f3n. Concepto de programa. Fases de desarrollo de un programa. El lenguaje C. Estructura de un programa. Comentarios en un programa. Entornos de programaci\u00f3n. Tema 2. Tipos de datos simples : Concepto de dato. Constantes y variables. Sentencias de asignaci\u00f3n. Expresiones y operadores. Sentencias de entrada/salida de datos. Tema 3. Sentencias de control : Algoritmos y programas. Estructura secuencial. Estructuras de selecci\u00f3n. Estructuras de repetici\u00f3n. Tema 4. Programaci\u00f3n modular : Descomposici\u00f3n modular. Concepto de m\u00f3dulo. Comunicaci\u00f3n entre m\u00f3dulos. Funciones. Par\u00e1metros actuales y formales. Paso de par\u00e1metros por valor y por referencia. \u00c1mbito de una variable. Variables globales y locales. Efecto lateral. Funciones predefinidas Tema 5. Tipos de datos estructurados: Arrays : Concepto de dato estructurado. El tipo array. Arrays unidimensionales, bidimensionales y multidimensionales. Cadenas de caracteres Tema 6. Punteros y memoria din\u00e1mica : Memoria est\u00e1tica vs. din\u00e1mica. Creaci\u00f3n, inicializaci\u00f3n, asignaci\u00f3n y liberaci\u00f3n de memoria. Conversi\u00f3n de tipos. Tema 7. Tipos de datos estructurados: Registros : Concepto de registro. Registros en C. Operaciones sobre registros. Arrays de registro Tema 8. Entrada/salida : Declaraci\u00f3n, apertura, lectura y escritura de ficheros de texto y binarios en C. Tema 9. Recursi\u00f3n : Definici\u00f3n. Esquema b\u00e1sico. Codificaci\u00f3n en C. Caracter\u00edsticas Pr\u00e1cticas \u00b6 Durante las clases pr\u00e1cticas se realizar\u00e1n de forma individual ejercicios de programaci\u00f3n relacionados con los conceptos que se est\u00e1n estudiando en ese momento que servir\u00e1n para reforzar y profundizar en las competencias de la asignatura. Horarios \u00b6 La distribuci\u00f3n de grupos del curso 2019-20 es la siguiente: Evaluaci\u00f3n \u00b6 Convocatoria normal (evaluaci\u00f3n continua) En la convocatoria ordinaria (enero) se realizar\u00e1 una evaluaci\u00f3n continua con las siguientes pruebas: Examen 1 : Del tema 1 al tema 3. Pondera un 15% en la nota final. No se exige nota m\u00ednima. Jueves 10 octubre, 16h-18h Examen 2 : Del tema 1 al tema 6. Pondera un 35% en la nota final. No se exige nota m\u00ednima. Mi\u00e9rcoles 27 noviembre, 11h-13h Examen 3 : Del tema 1 al tema 9. Pondera un 50% en la nota final. No se exige nota m\u00ednima. Se realizar\u00e1 en la fecha oficial asignada al examen final de la convocatoria de enero. Todos los ex\u00e1menes de la asignatura se realizar\u00e1n por escrito e incluir\u00e1n conceptos y ejercicios relacionados con los trabajados tanto en las sesiones de teor\u00eda como de pr\u00e1cticas. Las entregas de las pr\u00e1cticas no ponderar\u00e1n para la calificaci\u00f3n final, pero su realizaci\u00f3n es imprescindible para el aprendizaje de los conceptos, t\u00e9cnicas de la asignatura y para la preparaci\u00f3n de las pruebas en las que se evaluar\u00e1n los conocimientos adquiridos. Convocatoria extraordinaria En la convocatoria extraordinaria se realizar\u00e1 un examen final escrito sobre todos los bloques tem\u00e1ticos cuya calificaci\u00f3n representar\u00e1 el 100% de la nota de la asignatura. Plagios Los trabajos te\u00f3rico/pr\u00e1cticos realizados han de ser originales. La detecci\u00f3n de copia o plagio supondr\u00e1 la calificaci\u00f3n de \"0\" en la prueba correspondiente. Se informar\u00e1 la direcci\u00f3n de Departamento y de la EPS sobre esta incidencia. La reiteraci\u00f3n en la conducta en esta u otra asignatura conllevar\u00e1 la notificaci\u00f3n al vicerrectorado correspondiente de las faltas cometidas para que estudien el caso y sancionen seg\u00fan la legislaci\u00f3n (Reglamento de disciplina acad\u00e9mica de los Centros oficiales de Ense\u00f1anza Superior y de Ense\u00f1anza T\u00e9cnica dependientes del Ministerio de Educaci\u00f3n Nacional BOE 12/10/1954). Bibliograf\u00eda \u00b6 En Moodle se publican los apuntes de la asignatura, con ejercicios, explicaciones y ejemplos de todos los conceptos estudiados, tanto en teor\u00eda como en pr\u00e1ctica. Los apuntes de la asignatura se han confeccionado utilizando la siguiente bibliograf\u00eda, que pod\u00e9is utilizar para consultar o ampliar algunos conceptos: JOYANES, Luis; ZAHONERO, Ignacio. Programaci\u00f3n en C. Metodolog\u00eda, algoritmos y estructuras de datos. McGraw-Hill, 2a edici\u00f3n, 2005. ISBN: 8448198441 CARRETERO P\u00e9rez, Jes\u00fas. Fundamentos de programaci\u00f3n. 2007. ISBN: 9788497325509 KERNIGHAN, Brian W.; RITCHIE, Dennis M. El lenguaje de programaci\u00f3n C. Pearson Educaci\u00f3n, 1991. ISBN: 968-880-205-0 Carballeira. Problemas resueltos de programaci\u00f3n en lenguaje C Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares","title":"Descripci\u00f3n de la asignatura"},{"location":"Teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#programacion-1-grado-de-robotica-curso-2019-2020","text":"Toda la informaci\u00f3n est\u00e1 disponible en el sitio Moodle de P1 y en la ficha del campus virtual .","title":"Programaci\u00f3n 1. Grado de Rob\u00f3tica. Curso 2019-2020"},{"location":"Teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#datos-academicos-de-la-asignatura","text":"Departamento de Ciencia de la Computaci\u00f3n e Inteligencia Artificial 6 cr\u00e9ditos ECTS : 1 clase de teor\u00eda de 2 h. y 1 clase de pr\u00e1cticas de 2 h. a la semana Profesores : Antonio Bot\u00eda ( e-mail ): Grupos de pr\u00e1cticas: 2 y 3. Cristina Pomares ( e-mail ): Grupo de teor\u00eda: 1. Grupos de pr\u00e1cticas: 1 y 4.","title":"Datos acad\u00e9micos de la asignatura"},{"location":"Teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#recursos-de-la-asignatura","text":"Sitio Moodle contiene los apuntes, transparencias, pr\u00e1cticas y otros materiales docentes Foro de consultas y anuncios en el sitio Moodle","title":"Recursos de la asignatura"},{"location":"Teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#objetivos-y-competencias","text":"Objetivos : Dominar los principios de la programaci\u00f3n procedural. Resolver problemas de programaci\u00f3n b\u00e1sica aplicando adecuadamente los tipos de datos elementales, los tipos de datos estructurados y las estructuras de control. Asimilar el concepto programaci\u00f3n modular y saber aplicarlo en la resoluci\u00f3n de problemas. Conocer el concepto de recursividad, aplic\u00e1ndolo a problemas sencillos. Comprender el concepto de fichero y saber utilizarlos. Ser capaz de utilizar herramientas de programaci\u00f3n para editar, compilar, ejecutar y verificar un programa. Analizar problemas susceptibles de resoluci\u00f3n por un ordenador y dise\u00f1ar algoritmos que los solucionen. Implementar algoritmos mediante t\u00e9cnicas de programaci\u00f3n estructurada y modular. Saber realizar programas de ordenador que capturen y env\u00eden informaci\u00f3n a un sistema rob\u00f3tico. Competencias : Interpretar el funcionamiento del c\u00f3digo fuente de un programa. Definir los tipos de datos necesarios para la representaci\u00f3n de la informaci\u00f3n. Dise\u00f1ar algoritmos y codificarlos con distintas t\u00e9cnicas de programaci\u00f3n, especialmente en sistemas rob\u00f3ticos. Verificar el correcto funcionamiento de un programa.","title":"Objetivos y competencias"},{"location":"Teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#temario","text":"Tema 1. Introducci\u00f3n a la programaci\u00f3n : Representaci\u00f3n de la informaci\u00f3n. Concepto de programa. Fases de desarrollo de un programa. El lenguaje C. Estructura de un programa. Comentarios en un programa. Entornos de programaci\u00f3n. Tema 2. Tipos de datos simples : Concepto de dato. Constantes y variables. Sentencias de asignaci\u00f3n. Expresiones y operadores. Sentencias de entrada/salida de datos. Tema 3. Sentencias de control : Algoritmos y programas. Estructura secuencial. Estructuras de selecci\u00f3n. Estructuras de repetici\u00f3n. Tema 4. Programaci\u00f3n modular : Descomposici\u00f3n modular. Concepto de m\u00f3dulo. Comunicaci\u00f3n entre m\u00f3dulos. Funciones. Par\u00e1metros actuales y formales. Paso de par\u00e1metros por valor y por referencia. \u00c1mbito de una variable. Variables globales y locales. Efecto lateral. Funciones predefinidas Tema 5. Tipos de datos estructurados: Arrays : Concepto de dato estructurado. El tipo array. Arrays unidimensionales, bidimensionales y multidimensionales. Cadenas de caracteres Tema 6. Punteros y memoria din\u00e1mica : Memoria est\u00e1tica vs. din\u00e1mica. Creaci\u00f3n, inicializaci\u00f3n, asignaci\u00f3n y liberaci\u00f3n de memoria. Conversi\u00f3n de tipos. Tema 7. Tipos de datos estructurados: Registros : Concepto de registro. Registros en C. Operaciones sobre registros. Arrays de registro Tema 8. Entrada/salida : Declaraci\u00f3n, apertura, lectura y escritura de ficheros de texto y binarios en C. Tema 9. Recursi\u00f3n : Definici\u00f3n. Esquema b\u00e1sico. Codificaci\u00f3n en C. Caracter\u00edsticas","title":"Temario"},{"location":"Teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#practicas","text":"Durante las clases pr\u00e1cticas se realizar\u00e1n de forma individual ejercicios de programaci\u00f3n relacionados con los conceptos que se est\u00e1n estudiando en ese momento que servir\u00e1n para reforzar y profundizar en las competencias de la asignatura.","title":"Pr\u00e1cticas"},{"location":"Teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#horarios","text":"La distribuci\u00f3n de grupos del curso 2019-20 es la siguiente:","title":"Horarios"},{"location":"Teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#evaluacion","text":"","title":"Evaluaci\u00f3n"},{"location":"Teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#bibliografia","text":"En Moodle se publican los apuntes de la asignatura, con ejercicios, explicaciones y ejemplos de todos los conceptos estudiados, tanto en teor\u00eda como en pr\u00e1ctica. Los apuntes de la asignatura se han confeccionado utilizando la siguiente bibliograf\u00eda, que pod\u00e9is utilizar para consultar o ampliar algunos conceptos: JOYANES, Luis; ZAHONERO, Ignacio. Programaci\u00f3n en C. Metodolog\u00eda, algoritmos y estructuras de datos. McGraw-Hill, 2a edici\u00f3n, 2005. ISBN: 8448198441 CARRETERO P\u00e9rez, Jes\u00fas. Fundamentos de programaci\u00f3n. 2007. ISBN: 9788497325509 KERNIGHAN, Brian W.; RITCHIE, Dennis M. El lenguaje de programaci\u00f3n C. Pearson Educaci\u00f3n, 1991. ISBN: 968-880-205-0 Carballeira. Problemas resueltos de programaci\u00f3n en lenguaje C Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares","title":"Bibliograf\u00eda"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html","text":"Tema 1: Introducci\u00f3n a la programaci\u00f3n \u00b6 1. Lenguajes de programaci\u00f3n \u00b6 Un lenguaje de programaci\u00f3n permite especificar procesos que se ejecutan en computadores. Un programa escrito en un determinado lenguaje nos permite definir las instrucciones que realizar\u00e1 el ordenador (o, m\u00e1s en concreto, el procesador) que lo ejecute. Por ello, para entender en profundidad qu\u00e9 es un lenguaje de programaci\u00f3n es fundamental conocer el ordenador. 1.1. El ordenador y sus componentes \u00b6 Lor ordenadores poseen los siguientes componentes: Dispositivos de entrada . Se encargan de capturar informacio\u0301n de entrada a la computadora: teclado, rato\u0301n, micro\u0301fono, etc. Dispositivos de salida . Se encargan de la salida de informacio\u0301n de la computadora: monitor, impresora, altavoces, etc. Dispositivos de almacenamiento . Se encargan de almacenar los datos para su uso posterior: disco duro, CD-ROM, etc. Unidad de Procesamiento . Realiza las operaciones con los datos Memoria principal . Es donde se almacenan temporalmente los datos con los que la CPU trabaja en cada momento. Est\u00e1 formada por circuitos electr\u00f3nicos integrados capaces de almacenar valores binarios (0 \u00f3 1) en cada celda de memoria Memoria principal: Palabra de memoria: menor conjunto de celdas de memoria que se pueden leer o escribir simult\u00e1neamente. En el ejemplo, cada palabra es de 1 byte (8 bits) Direcci\u00f3n de memoria: n\u00famero que identifica de forma un\u00edvoca cada palabra de memoria 1.2. Representaci\u00f3n de la informaci\u00f3n \u00b6 La informacio\u0301n se representa en una computadora mediante el uso de dos estados: ausencia y presencia de corriente. Esto se debe a la naturaleza ele\u0301ctrica de la misma: Esta dualidad nos permite adoptar un sistema binario para representar la informacio\u0301n. Asi\u0301, la presencia de sen\u0303al se representa por el 1 y la ausencia por el 0. Esto nos lleva al concepto de bit , que es la unidad mi\u0301nima de informacio\u0301n. Un bit puede adoptar los valores 0 o\u0301 1. Un u\u0301nico bit aporta poca cantidad de informacio\u0301n. Es por ello que los bits se agrupan de 8 en 8 formando un byte . Un byte permite representar 2^8 = 256 combinaciones diferentes. A su vez, los bytes se agrupan formando palabras , que dependiendo de cada computadora pueden ser de 8, 16, 32 o\u0301 64 bytes . 1.3. Programa \u00b6 Un programa es el conjunto ordenado de instrucciones que indican a la computadora las acciones que debe realizar para cumplir una tarea especi\u0301fica. En este sentido, con un programa especificamos al ordenador que\u0301 tiene que hacer, en el orden en el que lo tiene que hacer y los datos que ha de usar para ello. Los programas esta\u0301n escritos en un determinado lenguaje formal libre de ambigu\u0308edades, de forma que la especificacio\u0301n de lo que queremos hacer sea uni\u0301voca. Con respecto al nivel de abstraccio\u0301n de estos lenguajes, los podemos clasificar en dos grandes grupos: Lenguajes Ma\u0301quina : Como su propio nombre indica, se trata de los lenguajes \"nativos\" de la computadora, y por ello es capaz de procesarlos directamente. Sumamente costosos para el programador. Lenguajes de Alto Nivel : Se trata de lenguajes mucho ma\u0301s cercanos al lenguaje humano, con un alto nivel de abstracci\u00f3n, por lo que son ma\u0301s comprensibles y menos engorrosos de usar para el programador. Los programas construidos con estos lenguajes han de ser traducidos a lenguaje ma\u0301quina mediante el uso de un compilador para que la computadora los pueda procesar. Python, C, C++, Java, etc. 1.4. Los primeros lenguajes de programaci\u00f3n \u00b6 Los primeros computadores electr\u00f3nicos se programan directamente usando el conjunto de instrucciones del procesador, en c\u00f3digo m\u00e1quina , c\u00f3digo hexadecimal. El siguiente programa, en lenguaje ma\u0301quina, resta un nu\u0301mero de otro y el resultado lo almacena en una posicio\u0301n de memoria: El primer lenguaje de un nivel algo m\u00e1s elevado que el c\u00f3digo m\u00e1quina es el ensamblador . Programas que empiezan a ayudar a los programadores: ensambladores. Hay una relaci\u00f3n casi directa entre la notaci\u00f3n en ensamblador y el c\u00f3digo hexadecimal que produce el ensamblador. El programa anterior en ensamblador seri\u0301a: 1 2 3 4 5 6 7 CAR A RES B ALM C STOP C : 0 A : 7 B : 2 El lenguaje ensamblador constituye un gran avance en lo que a facilidad de comprensio\u0301n se requiere a la hora de programar. De todas formas, este lenguaje sigue teniendo varios inconvenientes: Por un lado, cada computadora posee un lenguaje ensamblador distinto, por lo que para utilizar un programa en otra computadora distinta habri\u0301a que rescribirlo. Por otro lado, el lenguaje sigue siendo demasiado cercano al lenguaje ma\u0301quina, lo que dificulta su comprensio\u0301n y por tanto encarece el desarrollo de programas de gran extensio\u0301n. Los lenguajes de alto nivel se caracterizan por no ser dependientes de ma\u0301quina. Mediante la compilacio\u0301n de un programa escrito en lenguaje de alto nivel podremos ejecutarlo en cualquier ma\u0301quina. Para ello, necesitaremos un compilador de ese lenguaje para cada ma\u0301quina en la que queramos ejecutar nuestro programa. Otra caracteri\u0301stica de estos lenguajes es su sintaxis es m\u00e1s cercana al lenguaje natural del programador y proporciona distintas herramientas de abstracci\u00f3n que facilitan la programaci\u00f3n. 1.5. Los primeros lenguajes de alto nivel \u00b6 Los primeros lenguajes de alto nivel se desarrollaron a finales de la d\u00e9cada de los 50: FORTRAN en 1956 Lisp en 1958 Ambos lenguajes planteaban dos enfoques muy distintos desde el principio y fueron la base y la influencia del desarrollo de numerosos lenguajes posteriores. Desde 1954 hasta la actualidad se han documentado m\u00e1s de 2.500 (consultar en The Language List ). Genealog\u00eda de los lenguajes de programaci\u00f3n El lenguaje C surgi\u00f3 en 1972, derivado de Fortran y Algol. Es el que vamos a estudiar en esta asignatura. El lenguaje Python surgi\u00f3 en 1991, a partir de Lisp y C. 1.6. Compiladores e int\u00e9rpretes \u00b6 En el nivel de abstracci\u00f3n m\u00e1s bajo, la ejecuci\u00f3n de un programa en un computador consiste en la ejecuci\u00f3n de un conjunto de instrucciones del c\u00f3digo m\u00e1quina del procesador. Compilaci\u00f3n La siguiente figura muestra el proceso de generaci\u00f3n y ejecuci\u00f3n de un programa compilado. Compilaci\u00f3n El proceso de compilaci\u00f3n de un programa consiste en la traducci\u00f3n del c\u00f3digo fuente original en el lenguaje de alto nivel al c\u00f3digo m\u00e1quina espec\u00edfico del procesador en el que va a ejecutarse el programa. El c\u00f3digo m\u00e1quina resultante s\u00f3lo corre en el procesador para el que se ha generado. Por ejemplo, un programa C compilado para un procesador Intel no puede ejecutarse en un procesador ARM, como los Ax de Apple . Ejemplos: C, C++ Diferentes momentos en la vida de un programa: tiempo de compilaci\u00f3n y tiempo de ejecuci\u00f3n Mayor eficiencia Interpretaci\u00f3n Interpretaci\u00f3n Ejemplos: Lisp, Python, Ruby No hay diferencia entre el tiempo de compilaci\u00f3n y el tiempo de ejecuci\u00f3n Mayor flexibilidad Los lenguajes interpretados suelen proporcionar un shell o int\u00e9rprete. Se trata de un entorno interactivo en el que podemos definir y evaluar expresiones. Este entorno se denomina en los c\u00edrculos de programaci\u00f3n funcional un REPL ( Read , Eval , Print , Loop ) y ya se utiliz\u00f3 en los primeros a\u00f1os de implementaci\u00f3n del Lisp. El uso del REPL promueve una programaci\u00f3n interactiva en la que continuamente evaluamos y comprobamos el c\u00f3digo que desarrollamos. Enfoques mixtos Existen tambi\u00e9n enfoques mixtos, como el usado por el lenguaje de programaci\u00f3n Java, en el que se realizan ambos procesos: por un lado, el compilador ( javac ) traduce el c\u00f3digo fuente original a un c\u00f3digo intermedio binario (multiplataforma), que es interpretado posteriormente por el int\u00e9rprete ( java ). Enfoque mixto (Java) Ejemplos: Java, Scala 2. Lenguaje C \u00b6 C es el lenguaje principal que vamos a estudiar en la asignatura, pero vamos a ver tambi\u00e9n algunos ejemplos en Python. C presenta ciertas caracter\u00edsticas que permiten ejercer un elevado control sobre la eficiencia de los programas, tanto en la velocidad de ejecuci\u00f3n como en el consumo de memoria, pero a un precio importante: tenemos que proporcionar informaci\u00f3n expl\u00edcita sobre gran cantidad de detalles, por lo que generalmente resultan programas m\u00e1s largos y complicados que sus equivalentes en otros lenguajes m\u00e1s modernos, aumentando as\u00ed la probabilidad de que cometamos errores. C es un lenguaje compilado: antes de ejecutar un programa escrito por nosotros, suministramos su c\u00f3digo fuente (en un fichero con extensi\u00f3n .c) a un compilador de C. El compilador lee y analiza todo el programa. Si el programa est\u00e1 correctamente escrito seg\u00fan la definici\u00f3n del lenguaje, el compilador genera un nuevo fichero con su traducci\u00f3n a c\u00f3digo de m\u00e1quina (llamado programa objeto), y si no, muestra los errores que ha detectado. Para ejecutar el programa utilizamos el nombre del fichero generado. Si no modificamos el c\u00f3digo fuente, no hace falta que lo compilemos nuevamente para volver a ejecutar el programa: basta con volver a ejecutar el fichero generado por el compilador. La principal ventaja de compilar los programas es que se gana en velocidad de ejecuci\u00f3n, ya que cuando el programa se ejecuta est\u00e1 completamente traducido a c\u00f3digo de m\u00e1quina y se ahorra el proceso de traducci\u00f3n simult\u00e1nea que conlleva interpretar un programa. Pero, adem\u00e1s, como se traduce a c\u00f3digo m\u00e1quina en una fase independiente de la fase de ejecuci\u00f3n, el programa traductor puede dedicar m\u00e1s tiempo a intentar encontrar la mejor traducci\u00f3n posible, la que proporcione el programa de c\u00f3digo m\u00e1quina m\u00e1s r\u00e1pido (o que consuma menos memoria). 2.1. Desarrollo de programas en lenguaje C \u00b6 Cuando se implementa un programa, en primer lugar editamos el c\u00f3digo fuente con un editor. Estos archivos contienen la implementaci\u00f3n del programa en un determinado lenguaje, pero no se pueden ejecutar directamente. Para ello necesitamos compilar los programas oara obtener el c\u00f3digo objeto , que es un c\u00f3digo en binario intermedio que puede enlazarse con otros m\u00f3ulos ya compilados o con bibliotecas para obtener un c\u00f3digo ejecutable . Este \u00faltimo es un fichero que se puede ejecutar directamente. Este proceso es un ciclo, de forma que si despu\u00e9s de ejecutar el programa hemos encontrado errores, volvemos a editar el programa, compilarlo y ejecutarlo. Compilador : un programa que lee un c\u00f3digo fuente y lo traduce a c\u00f3digo objeto (ensamblador o binario). Enlazador : combina archivos objeto y bibliotecas de forma que se puedan ejecutar en una sola unidad. Ejemplo de programa en C: 1 2 3 4 5 6 7 8 #include <stdio.h> int main () { printf ( \"Hola mundo!! \\n \" ); return 0 ; } Vamos a analizar este primer programa: La primera l\u00ednea #include <stdio.h> se debe incluir al principio de cada programa. Incluye las funciones de entrada y salida, por ejemplo la instrucci\u00f3n printf . La l\u00ednea int main() indica la funci\u00f3n principal main , es un nombre especial que indica d\u00f3nde empieza el programa su ejecuci\u00f3n. Los par\u00e9ntesis tanto de main como de printf indican que ambas son funciones, y dentro de los par\u00e9ntesis ir\u00e1n los argumentos de las mismas (si los tienen). El argumento de printf es la cadena de caracteres \"Hola mundo!!\\n\" . La instrucci\u00f3n printf es una funci\u00f3n que imprime su argumento por pantalla, en este caso \"Hola mundo\" . Los \u00faltimos dos caracteres de la cadena `\\n' indican el car\u00e1cter newline o salto de l\u00ednea. Todas las instrucciones en C terminan en un ; . La \u00faltima sentencia return 0; indica que se termina la ejecuci\u00f3n de main , y devuelve al sistema el valor 0. El cero es un valor que se usa para indicar que el programa ha terminado correctamente (sin errores). La devoluci\u00f3n de un n\u00famero distinto de cero indican distintos errores (por ejemplo que no se encuentra un fichero). Vamos a compilar y ejecutar nuestro primer programa. Son tres pasos: A partir del fichero de texto con nuestro programa con el co\u0301digo fuente en lenguaje C se realiza una fase de preprocesado en la que se eliminan comentarios y se satisfacen directivas # gcc -\u00adE holamundo.c Una vez preprocesado se genera un fichero con co\u0301digo objeto en el paso de compilacio\u0301n gcc -\u00adc holaMundo.c . Nos genera holaMundo.o El fichero objeto se debe enlazar con las libreri\u0301as para generar el ejecutable en el paso de enlazado. Esto se puede realizar con una instruccio\u0301n: gcc holaMundo.c \u00ad-o holaMundo Su forma de uso m\u00e1s b\u00e1sica es \u00e9sta (agrupamos los pasos anteriores en una \u00fanica instrucci\u00f3n): gcc -o holamundo holamundo.c La opci\u00f3n -o es abreviatura de output , y a ella le sigue el nombre del fichero que contendr\u00e1 la traducci\u00f3n a c\u00f3digo m\u00e1quina del programa. Este fichero s\u00f3lo se genera si el programa C est\u00e1 correctamente escrito y no tiene errores de compilaci\u00f3n. Ahora ejecutamos el fichero ejecutable: ./holamundo y el resultado es la salida por pantalla: Hola mundo!! Diferencias entre C y Python C es un lenguaje imperativo. Python es multiparadigma (imperativo, orientado a objetos y funcional). C es un lenguaje compilado. Python es interpretado. En C, el programador tiene que hacer la gesti\u00f3n de memoria (reservar, liberar, etc). Python tiene recolector de basura autom\u00e1tico para la gesti\u00f3n de memoria. C es fuertemente tipado (obligatorio declarar el tipo de las variables). Python es d\u00e9bilmente tipado. La sintaxis de C es m\u00e1s compleja. La sintaxis de Python es m\u00e1s sencilla y sus programas son m\u00e1s f\u00e1ciles de escribir y depurar. 2.2. Aprender a programar \u00b6 A programar se aprende programando . En esta asignatura os dar\u00e9is cuenta que no sirve de nada memorizar programas, ni mirar ejercicios resueltos o soluciones a las pr\u00e1cticas planteadas. Deb\u00e9is empezar desde el principio a hacer peque\u00f1os programas y modificaciones de los que hagamos o planteemos en clase. Pelearos con el c\u00f3digo, que os salgan errores, resolverlos, etc. Es la \u00fanica forma de aprender. Una vez hay\u00e1is implementado una soluci\u00f3n a un problema, entonces es el momento de mirar otra soluci\u00f3n para ver si pod\u00e9is mejorarlo, pero primero deb\u00e9is haberlo resuelto vosotros o al menos intentado resolver. Un programa de computadora es s\u00f3lo una recopilaci\u00f3n de las instrucciones necesarias para resolver un problema espec\u00edfico. El m\u00e9todo utilizado para resolver el problema se conoce como algoritmo. Por ejemplo, si queremos implementar un programa que comprueba si un n\u00famero es impar, el conjunto de instrucciones que resuelve el problema es el programa . El m\u00e9todo que se utiliza para comprobar si el n\u00famero es par o impar es el algoritmo . Normalmente, para desarrollar un programa para resolver un problema particular, primero hay que pensar en el algoritmo y luego desarrollar un programa que implementa ese algoritmo. Por lo tanto, el algoritmo para resolver el problema par / impar podr\u00eda expresarse de la siguiente manera: Primero, dividir el n\u00famero por dos. Si el resto de la divisi\u00f3n es cero, el n\u00famero es par; de lo contrario, el n\u00famero es impar. Caracter\u00edsticas deseables de un programa Integridad : Correcci\u00f3n de los c\u00e1lculos Claridad : Facilidad de lectura del programa en conjunto, con \u00e9nfasis en la l\u00f3gica subyacente. Sencillez : La claridad y la correcci\u00f3n de un programa se suelen ver favorecidos con hacer las cosas de forma tan sencilla como sea posible, consistente con los objetivos del programa en su conjunto Eficiencia : relacionado con la velocidad de ejecuci\u00f3n y la utilizaci\u00f3n eficiente de la memoria Modularidad : Casi todos los programas se pueden dividir en peque\u00f1as subtareas. Es una buena pr\u00e1ctica de programaci\u00f3n implementar cada una de estas subtareas como un m\u00f3dulo. En C estos m\u00f3dulos son las funciones. El dise\u00f1o modular aumenta la correcci\u00f3n y la claridad, y facilita los posibles cambios futuros del programa Generalidad : Intentaremos que el programa sea lo m\u00e1s gen\u00e9rico posible Todas estas caracter\u00edsticas las tendremos en cuenta en la evaluaci\u00f3n de vuestros programas en la asignatura. Pasos para desarrollar un programa Es fundamental comprender bien el problema antes de pensar en la solucio\u0301n. Antes de ponerse a escribir el programa es necesario tener claro co\u0301mo resolverlo, pensar en ello utilizando l\u00e1piz y papel: Entender el problema Disen\u0303ar la solucio\u0301n Implementar el programa Verificar y probar el programa Optimizar Entender el problema Para entender el problema debemos pensar y analizarlo. Debemos plantearnos las siguientes cuestiones: Datos de entrada Datos de salida \u00bfQue\u0301 hay que resolver? \u00bfCo\u0301mo se puede resolver? Ejemplo: Se desea calcular la nota de una asignatura de un alumno teniendo en cuenta la nota de los exa\u0301menes realizados en una determinada convocatoria. En Enero, la nota final se obtiene con el 15% de la nota de un primer examen con ordenador, el 35% de la nota de un segundo examen con ordenador y el 50% restante con la nota de un examen escrito, excepto si la nota del examen escrito o la del segundo examen con ordenador es menor que 4, en cuyo caso la nota final sera\u0301 la mi\u0301nima de las dos. En Julio, la nota final se obtendra\u0301 como 50% nota del examen escrito, 50% nota del examen con ordenador, excepto si cualquiera de estas dos notas es menor que 4, en cuyo caso la nota final sera\u0301 la mi\u0301nima de las dos. Dise\u00f1ar la soluci\u00f3n Detectar los pasos a seguir para solucionar el problema Estructurar el programa Plasmar esa solucio\u0301n de alguna manera Algoritmo: Dime de que\u0301 convocatoria quieres saber tu nota final Si es la convocatoria de Enero entonces Dime la nota de los 2 exa\u0301menes con ordenador y del examen escrito Si la nota del examen escrito < 4 o nota examen ordenador 2 < 4 Entonces TU NOTA FINAL ES = mi\u0301nimo (nota ex. escrito, nota ex. ord. 2) Sino TU NOTA FINAL ES =0,15 Ordenador_1+0,35 Ordenador_2+0,5*Escrito Si es la convocatoria de Julio Entonces Dime las notas del examen escrito y del examen con ordenador Si la nota del examen escrito < 4 o nota examen ordenador < 4 Entonces TU NOTA FINAL ES = mi\u0301nimo (nota ex. escrito, nota ex. ord.) Sino TU NOTA FINAL ES = 0,5 Ordenador+0,5 Escrito Implementar el programa Desarrollar en un lenguaje de programacio\u0301n los pasos a seguir para resolver el problema Importante: la solucio\u0301n debe ser (lo suficientemente) o\u0301ptima. Se pueden encontrar distintas soluciones para resolver el mismo problema Este paso implica un proceso ci\u0301clico donde se programa (implementa) la solucio\u0301n (total o parcial), se prueba, se detectan errores y se vuelve a programar para resolverlos. Normalmente un programa no funciona a la primera. Programa para calcular la nota: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include <stdio.h> int main () { char convocatoria ; float ordenador_1 , ordenador_2 , examen_escrito , nota_final ; printf ( \"Dime la convocatoria(E,J):\" ); scanf ( \"%c\" , & convocatoria ); if ( convocatoria == 'E' ) { printf ( \"Dime la nota del primer examen con ordenador:\" ); scanf ( \"%f\" , & ordenador_1 ); printf ( \"Dime la nota del segundo examen con ordenador:\" ); scanf ( \"%f\" , & ordenador_2 ); printf ( \"Dime la nota del examen escrito:\" ); scanf ( \"%f\" , & examen_escrito ); if ( examen_escrito < 4 || ordenador_2 < 4 ) // minimo: funcio\u0301n que calcula el nu\u0301mero ma\u0301s pequen\u0303o entre 2 nu\u0301meros nota_final = minimo ( examen_escrito , ordenador_2 ); else nota_final = 0.15 * ordenador_1 + 0.35 * ordenador_2 + 0.5 * examen_escrito ; } else if ( convocatoria == 'J' ) { printf ( \"Dime la nota del examen escrito:\" ); scanf ( \"%f\" , & examen_escrito ); printf ( \"Dime la nota del examen con ordenador:\" ); scanf ( \"%f\" , & ordenador_2 ); if ( examen_escrito < 4 || ordenador_2 < 4 ) // minimo: funcio\u0301n que calcula el nu\u0301mero ma\u0301s pequen\u0303o entre 2 nu\u0301meros nota_final = minimo ( examen_escrito , ordenador_2 ); else nota_final = 0.5 * ordenador_2 + 0.5 * examen_escrito ; } printf ( \"TU NOTA FINAL ES %f \\n \" , nota_final ); return 0 ; } Probar el programa Comprobar que el resultado obtenido es el adecuado. Para ello se deben realizar pruebas exhaustivas sobre nuestro programa y testear que los resultados obtenidos son los que esperamos Si no, volver al paso anterior Optimizaci\u00f3n Despu\u00e9s de tener un programa correcto y validado, es conveniente estudiar si se puede mejorar la soluci\u00f3n para que el programa sea m\u00e1s eficiente, m\u00e1s legible y menos redundante. Documentaci\u00f3n La documentacio\u0301n es un parte fundamental en el desarrollo de co\u0301digo. En C los comentarios son: 1 2 3 /* uno o varios comentarios */ /* Pueden ser multili\u0301nea */ El preprocesador elimina el texto del comentario. No abusar de ellos: 1 if ( x == 5 ) /* Si x es igual a 5 */ Usar lenguaje apropiado. Si tenemos funciones, comentar lo que hace justo antes de la definici\u00f3n de la funcio\u0301n: 1 2 /* Realiza la suma ponderada de los valores pasados por para\u0301metro */ double sumap ( double a , double b ) { La principal funcio\u0301n de los comentarios es el mantenimiento: tanto por ti como para otros programadores 2.3 Normas de estilo para programar en C \u00b6 Nota : En este apartado vamos a hablar de t\u00e9rminos que iremos explicando poco a poco en la asignatura. La idea es recopilarlo para que os sirva de gu\u00eda y de consulta. Los programas, a lo largo del tiempo, se van quedando obsoletos, por ejemplo, actualizaci\u00f3n del software de un robot para una determinada tarea. Es muy normal tener que modificar un programa porque debamos actualizarlo o porque decidamos incluirle nuevas posibilidades que antes no estaban previstas. Por otra parte, tambi\u00e9n es frecuente que uno deba modificar un programa escrito por otro programador, encontr\u00e1ndonos con problemas de legibilidad. Para poder modificarlo, primero hay que comprender su funcionamiento, y para facilitar esta tarea el programa debe estar escrito siguiendo unas normas b\u00e1sicas. Adem\u00e1s, el lenguaje C se presta a hacer programas complejos y dif\u00edciles de comprender. En C se pueden encapsular \u00f3rdenes y operadores, de tal forma que, aunque consigamos mayor eficiencia su comprensi\u00f3n sea todo un reto. No existen un conjunto de reglas fijas para programar con legibilidad. Lo que s\u00ed existen son un conjunto de reglas generales: Identificadores significativos Constantes simb\u00f3licas Comentarios Estructura del programa Identaci\u00f3n o sangrado Identificadores significativos Un identificador es un nombre asociado a un objeto de programa, que puede ser una variable, funci\u00f3n, constante, tipo de datos... El nombre de cada identificador debe expresar lo m\u00e1s claramente posible al objeto que identifica. Normalmente los identificadores deben empezar por una letra, no pueden contener espacios y suelen tener una longitud m\u00e1xima que puede variar, pero que no deber\u00eda superar los 10-20 caracteres para evitar lecturas muy pesadas. Un identificador debe indicar lo m\u00e1s breve y claramente posible el objeto al que referencia. Por ejemplo, si una variable contiene la lectura del sensor de visi\u00f3n de un robot, la variable se puede llamar sensorVision . Es muy normal usar variables como i, j o k para nombres de \u00edndices de bucles (for, while...), lo cual es aceptable siempre que la variable sirva s\u00f3lo para el bucle y no tenga un significado especial. En determinados casos, dentro de una funci\u00f3n o programa peque\u00f1o, se pueden usar este tipo de variables, si no crean problemas de comprensi\u00f3n, pero esto no es muy recomendable. Para los identificadores de funci\u00f3n se suelen usar las formas de los verbos en infinitivo, seguido de alg\u00fan sustantivo, para indicar claramente lo que hace. Por ejemplo, una funci\u00f3n podr\u00eda llamarse evitarObstaculo , y ser\u00eda m\u00e1s comprensible que si le hubi\u00e9ramos llamado evitar . Constantes simb\u00f3licas En un programa es muy normal usar constantes (num\u00e9ricas, cadenas...). Si estas constantes las usamos directamente en el programa, el programa funcionar\u00e1, pero es m\u00e1s recomendable usar constantes simb\u00f3licas, de forma que las definimos al principio del programa y luego las usamos cuando haga falta. As\u00ed, conseguimos principalmente dos ventajas: Los programas se hacen m\u00e1s legibles: Es m\u00e1s legible usar la constante simb\u00f3lica PI que usar 3.14 en su lugar: 1 volumen_esfera = 4 / 3. * PI * pow ( radio , 3 ); Los programas ser\u00e1n m\u00e1s f\u00e1ciles de modificar: Si en un momento dado necesitamos usar PI con m\u00e1s decimales (3.141592) s\u00f3lo tenemos que cambiar la definici\u00f3n, y no tenemos que cambiar todas las ocurrencias de 3.14 por 3.141592 que ser\u00eda m\u00e1s costoso y podemos olvidarnos alguna. En C, las constantes simb\u00f3licas se suelen poner usando una \u00f3rden al preprocesador de C, quedando definidas desde el lugar en que se definen hasta el final del fichero (o hasta que expresamente se indique). Su formato general es: 1 #define CONSTANTE valor Se encarga de cambiar todas las ocurrencias de CONSTANTE por el valor indicado en la segunda palabra (valor). Este cambio lo realiza el preprocesador de C, antes de empezar la compilaci\u00f3n. Por convenio, las constantes se suelen poner completamente en may\u00fasculas y las variables no, de forma que leyendo el programa podamos saber r\u00e1pidamente qu\u00e9 es cada cosa. En general, se deben usar constantes simb\u00f3licas en constantes que aparezcan m\u00e1s de una vez en el programa referidas a un mismo elemento que pueda variar ocasionalmente. Comentarios Sirven para aumentar la claridad de un programa, ayudan para la documentaci\u00f3n y bien utilizados nos pueden ahorrar mucho tiempo. Los comentarios deben ser breves y concisos. Se deben poner comentarios cuando se crean necesarios, y sobre todo: Al principio del programa o de cada fichero del programa que permita seguir un poco la historia de cada programa, indicando: Nombre del programa, objetivo, par\u00e1metros (si los tiene), condiciones de ejecuci\u00f3n, m\u00f3dulos que lo componen, autor o autores, fecha de finalizaci\u00f3n, \u00faltimas modificaciones realizadas y sus fechas... y cualquier otra eventualidad que el programador quiera dejar constancia. En cada sentencia o bloque (bucle, if, switch...) que revista cierta complejidad, de forma que el comentario indique qu\u00e9 se realiza o c\u00f3mo funciona. Al principio de cada funci\u00f3n cuyo nombre no explique suficientemente su cometido. Se debe poner no s\u00f3lo lo que hace sino la utilidad de cada par\u00e1metro, el valor que devuelve (si lo hubiera) y, si fuera oportuno, los requisitos necesarios para que dicha funci\u00f3n opere correctamente. En la declaraci\u00f3n de variables y constantes cuyo identificador no sea suficiente para comprender su utilidad. En los cierres de bloques con '}', para indicar a qu\u00e9 sentencias de control de flujo pertenecen, principalmente cuando existe mucho anidamiento de sentencias y/o los bloques contienen muchas l\u00edneas de c\u00f3digo. No olvidemos que los comentarios son textos para las personas, por lo que debemos cuidar el estilo, acentos y signos de puntuaci\u00f3n. Estructura del programa Un programa debe ser claro, estar bien organizado y ser f\u00e1cil de leer y entender Para aumentar la claridad no se deben escribir l\u00edneas muy largas que se salgan de la pantalla y funciones con muchas l\u00edneas de c\u00f3digo (especialmente la funci\u00f3n principal). Una funci\u00f3n demasiado grande demuestra, en general, una programaci\u00f3n descuidada y un an\u00e1lisis del problema poco estudiado. Estructura t\u00edpica de un programa C, es el que usaremos en esta asignatura: Comentarios de presentaci\u00f3n Inclusi\u00f3n de bibliotecas del sistema. Ejemplo: #include <stdio.h> Bibliotecas propias de la aplicaci\u00f3n Constantes simb\u00f3licas y definiciones de macros, con #define Definici\u00f3n de tipos, con typedef Declaraci\u00f3n de funciones Implementaci\u00f3n de funciones Este orden no es estricto y pueden cambiarse algunos puntos por otros, pero debemos ser coherentes y usar el mismo orden en todos nuestros programas Identaci\u00f3n o sangrado La indentaci\u00f3n o sangrado consiste en tabular hacia la derecha todas las sentencias de una misma funci\u00f3n o bloque, de forma que se vea r\u00e1pidamente cuales pertenecen al bloque y cuales no. Algunos estudios indican que el indentado debe hacerse con 3 \u00f3 4 espacios. Usar m\u00e1s espacios no aumenta la claridad y puede originar que las l\u00edneas se salgan de la pantalla, complicando su lectura. La indentaci\u00f3n es muy importante para que el programador no pierda la estructura del programa debido a los posibles anidamientos. Normalmente, la llave de comienzo de una estructura de control { se pone al final de la linea y la que lo cierra } justo debajo de donde comienza (como veremos m\u00e1s adelante). Ejemplo: 1 2 3 4 5 6 7 8 9 10 if ( condici\u00f3n ) { sentencia1 ; sentencia2 ; ... } else { sentencia1 ; sentencia2 ; ... } 1 2 3 4 int main () { printf ( \"Ejemplo de identaci\u00f3n \\n \" ); return 0 ; } 2.4. Consejos para la realizaci\u00f3n de las pr\u00e1cticas de programaci\u00f3n \u00b6 Leer bien el enunciado de lo que te piden. Pensar antes de escribir el c\u00f3digo. Coger l\u00e1piz y papel y estructurar los pasos que se desean implementar (algoritmo). Detenerse ante cualquier mensaje de error o warning y solucionarlo antes de continuar. Ir paso a paso. Nunca escribas una gran porci\u00f3n de c\u00f3digo sin haberla probado poco a poco. Escribir comentarios a medida que escribes c\u00f3digo. Preguntar al profesor lo que no entiendas. IMPORTANTE : No programas para el ordenador, programas para ti. Programar no es escribir c\u00f3digo y olvidarlo, sino mantenerlo. Puedes echarle un vistazo a este divertido enlace donde explican qu\u00e9 no debes hacer cuando implementas un programa. Bibliograf\u00eda \u00b6 Cap\u00edtulo 1 y del 3.1 al 3.4 de \"Programaci\u00f3n en C, metodolog\u00eda, algoritmos y estructuras de datos\", Luis Joyanes, Ignacio Zahonero Cap\u00edtulo 1.4 \"Programming Language Pragmatics\", Michael L. Scott, Compilation and Interpretation Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares Puig","title":"Tema 1"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#tema-1-introduccion-a-la-programacion","text":"","title":"Tema 1: Introducci\u00f3n a la  programaci\u00f3n"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#1-lenguajes-de-programacion","text":"Un lenguaje de programaci\u00f3n permite especificar procesos que se ejecutan en computadores. Un programa escrito en un determinado lenguaje nos permite definir las instrucciones que realizar\u00e1 el ordenador (o, m\u00e1s en concreto, el procesador) que lo ejecute. Por ello, para entender en profundidad qu\u00e9 es un lenguaje de programaci\u00f3n es fundamental conocer el ordenador.","title":"1. Lenguajes de programaci\u00f3n"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#11-el-ordenador-y-sus-componentes","text":"Lor ordenadores poseen los siguientes componentes: Dispositivos de entrada . Se encargan de capturar informacio\u0301n de entrada a la computadora: teclado, rato\u0301n, micro\u0301fono, etc. Dispositivos de salida . Se encargan de la salida de informacio\u0301n de la computadora: monitor, impresora, altavoces, etc. Dispositivos de almacenamiento . Se encargan de almacenar los datos para su uso posterior: disco duro, CD-ROM, etc. Unidad de Procesamiento . Realiza las operaciones con los datos Memoria principal . Es donde se almacenan temporalmente los datos con los que la CPU trabaja en cada momento. Est\u00e1 formada por circuitos electr\u00f3nicos integrados capaces de almacenar valores binarios (0 \u00f3 1) en cada celda de memoria Memoria principal: Palabra de memoria: menor conjunto de celdas de memoria que se pueden leer o escribir simult\u00e1neamente. En el ejemplo, cada palabra es de 1 byte (8 bits) Direcci\u00f3n de memoria: n\u00famero que identifica de forma un\u00edvoca cada palabra de memoria","title":"1.1. El ordenador y sus componentes"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#12-representacion-de-la-informacion","text":"La informacio\u0301n se representa en una computadora mediante el uso de dos estados: ausencia y presencia de corriente. Esto se debe a la naturaleza ele\u0301ctrica de la misma: Esta dualidad nos permite adoptar un sistema binario para representar la informacio\u0301n. Asi\u0301, la presencia de sen\u0303al se representa por el 1 y la ausencia por el 0. Esto nos lleva al concepto de bit , que es la unidad mi\u0301nima de informacio\u0301n. Un bit puede adoptar los valores 0 o\u0301 1. Un u\u0301nico bit aporta poca cantidad de informacio\u0301n. Es por ello que los bits se agrupan de 8 en 8 formando un byte . Un byte permite representar 2^8 = 256 combinaciones diferentes. A su vez, los bytes se agrupan formando palabras , que dependiendo de cada computadora pueden ser de 8, 16, 32 o\u0301 64 bytes .","title":"1.2. Representaci\u00f3n de la informaci\u00f3n"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#13-programa","text":"Un programa es el conjunto ordenado de instrucciones que indican a la computadora las acciones que debe realizar para cumplir una tarea especi\u0301fica. En este sentido, con un programa especificamos al ordenador que\u0301 tiene que hacer, en el orden en el que lo tiene que hacer y los datos que ha de usar para ello. Los programas esta\u0301n escritos en un determinado lenguaje formal libre de ambigu\u0308edades, de forma que la especificacio\u0301n de lo que queremos hacer sea uni\u0301voca. Con respecto al nivel de abstraccio\u0301n de estos lenguajes, los podemos clasificar en dos grandes grupos: Lenguajes Ma\u0301quina : Como su propio nombre indica, se trata de los lenguajes \"nativos\" de la computadora, y por ello es capaz de procesarlos directamente. Sumamente costosos para el programador. Lenguajes de Alto Nivel : Se trata de lenguajes mucho ma\u0301s cercanos al lenguaje humano, con un alto nivel de abstracci\u00f3n, por lo que son ma\u0301s comprensibles y menos engorrosos de usar para el programador. Los programas construidos con estos lenguajes han de ser traducidos a lenguaje ma\u0301quina mediante el uso de un compilador para que la computadora los pueda procesar. Python, C, C++, Java, etc.","title":"1.3. Programa"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#14-los-primeros-lenguajes-de-programacion","text":"Los primeros computadores electr\u00f3nicos se programan directamente usando el conjunto de instrucciones del procesador, en c\u00f3digo m\u00e1quina , c\u00f3digo hexadecimal. El siguiente programa, en lenguaje ma\u0301quina, resta un nu\u0301mero de otro y el resultado lo almacena en una posicio\u0301n de memoria: El primer lenguaje de un nivel algo m\u00e1s elevado que el c\u00f3digo m\u00e1quina es el ensamblador . Programas que empiezan a ayudar a los programadores: ensambladores. Hay una relaci\u00f3n casi directa entre la notaci\u00f3n en ensamblador y el c\u00f3digo hexadecimal que produce el ensamblador. El programa anterior en ensamblador seri\u0301a: 1 2 3 4 5 6 7 CAR A RES B ALM C STOP C : 0 A : 7 B : 2 El lenguaje ensamblador constituye un gran avance en lo que a facilidad de comprensio\u0301n se requiere a la hora de programar. De todas formas, este lenguaje sigue teniendo varios inconvenientes: Por un lado, cada computadora posee un lenguaje ensamblador distinto, por lo que para utilizar un programa en otra computadora distinta habri\u0301a que rescribirlo. Por otro lado, el lenguaje sigue siendo demasiado cercano al lenguaje ma\u0301quina, lo que dificulta su comprensio\u0301n y por tanto encarece el desarrollo de programas de gran extensio\u0301n. Los lenguajes de alto nivel se caracterizan por no ser dependientes de ma\u0301quina. Mediante la compilacio\u0301n de un programa escrito en lenguaje de alto nivel podremos ejecutarlo en cualquier ma\u0301quina. Para ello, necesitaremos un compilador de ese lenguaje para cada ma\u0301quina en la que queramos ejecutar nuestro programa. Otra caracteri\u0301stica de estos lenguajes es su sintaxis es m\u00e1s cercana al lenguaje natural del programador y proporciona distintas herramientas de abstracci\u00f3n que facilitan la programaci\u00f3n.","title":"1.4. Los primeros lenguajes de programaci\u00f3n"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#15-los-primeros-lenguajes-de-alto-nivel","text":"Los primeros lenguajes de alto nivel se desarrollaron a finales de la d\u00e9cada de los 50: FORTRAN en 1956 Lisp en 1958 Ambos lenguajes planteaban dos enfoques muy distintos desde el principio y fueron la base y la influencia del desarrollo de numerosos lenguajes posteriores. Desde 1954 hasta la actualidad se han documentado m\u00e1s de 2.500 (consultar en The Language List ).","title":"1.5. Los primeros lenguajes de alto nivel"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#16-compiladores-e-interpretes","text":"En el nivel de abstracci\u00f3n m\u00e1s bajo, la ejecuci\u00f3n de un programa en un computador consiste en la ejecuci\u00f3n de un conjunto de instrucciones del c\u00f3digo m\u00e1quina del procesador.","title":"1.6. Compiladores e int\u00e9rpretes"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#2-lenguaje-c","text":"C es el lenguaje principal que vamos a estudiar en la asignatura, pero vamos a ver tambi\u00e9n algunos ejemplos en Python. C presenta ciertas caracter\u00edsticas que permiten ejercer un elevado control sobre la eficiencia de los programas, tanto en la velocidad de ejecuci\u00f3n como en el consumo de memoria, pero a un precio importante: tenemos que proporcionar informaci\u00f3n expl\u00edcita sobre gran cantidad de detalles, por lo que generalmente resultan programas m\u00e1s largos y complicados que sus equivalentes en otros lenguajes m\u00e1s modernos, aumentando as\u00ed la probabilidad de que cometamos errores. C es un lenguaje compilado: antes de ejecutar un programa escrito por nosotros, suministramos su c\u00f3digo fuente (en un fichero con extensi\u00f3n .c) a un compilador de C. El compilador lee y analiza todo el programa. Si el programa est\u00e1 correctamente escrito seg\u00fan la definici\u00f3n del lenguaje, el compilador genera un nuevo fichero con su traducci\u00f3n a c\u00f3digo de m\u00e1quina (llamado programa objeto), y si no, muestra los errores que ha detectado. Para ejecutar el programa utilizamos el nombre del fichero generado. Si no modificamos el c\u00f3digo fuente, no hace falta que lo compilemos nuevamente para volver a ejecutar el programa: basta con volver a ejecutar el fichero generado por el compilador. La principal ventaja de compilar los programas es que se gana en velocidad de ejecuci\u00f3n, ya que cuando el programa se ejecuta est\u00e1 completamente traducido a c\u00f3digo de m\u00e1quina y se ahorra el proceso de traducci\u00f3n simult\u00e1nea que conlleva interpretar un programa. Pero, adem\u00e1s, como se traduce a c\u00f3digo m\u00e1quina en una fase independiente de la fase de ejecuci\u00f3n, el programa traductor puede dedicar m\u00e1s tiempo a intentar encontrar la mejor traducci\u00f3n posible, la que proporcione el programa de c\u00f3digo m\u00e1quina m\u00e1s r\u00e1pido (o que consuma menos memoria).","title":"2. Lenguaje C"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#21-desarrollo-de-programas-en-lenguaje-c","text":"Cuando se implementa un programa, en primer lugar editamos el c\u00f3digo fuente con un editor. Estos archivos contienen la implementaci\u00f3n del programa en un determinado lenguaje, pero no se pueden ejecutar directamente. Para ello necesitamos compilar los programas oara obtener el c\u00f3digo objeto , que es un c\u00f3digo en binario intermedio que puede enlazarse con otros m\u00f3ulos ya compilados o con bibliotecas para obtener un c\u00f3digo ejecutable . Este \u00faltimo es un fichero que se puede ejecutar directamente. Este proceso es un ciclo, de forma que si despu\u00e9s de ejecutar el programa hemos encontrado errores, volvemos a editar el programa, compilarlo y ejecutarlo. Compilador : un programa que lee un c\u00f3digo fuente y lo traduce a c\u00f3digo objeto (ensamblador o binario). Enlazador : combina archivos objeto y bibliotecas de forma que se puedan ejecutar en una sola unidad. Ejemplo de programa en C: 1 2 3 4 5 6 7 8 #include <stdio.h> int main () { printf ( \"Hola mundo!! \\n \" ); return 0 ; } Vamos a analizar este primer programa: La primera l\u00ednea #include <stdio.h> se debe incluir al principio de cada programa. Incluye las funciones de entrada y salida, por ejemplo la instrucci\u00f3n printf . La l\u00ednea int main() indica la funci\u00f3n principal main , es un nombre especial que indica d\u00f3nde empieza el programa su ejecuci\u00f3n. Los par\u00e9ntesis tanto de main como de printf indican que ambas son funciones, y dentro de los par\u00e9ntesis ir\u00e1n los argumentos de las mismas (si los tienen). El argumento de printf es la cadena de caracteres \"Hola mundo!!\\n\" . La instrucci\u00f3n printf es una funci\u00f3n que imprime su argumento por pantalla, en este caso \"Hola mundo\" . Los \u00faltimos dos caracteres de la cadena `\\n' indican el car\u00e1cter newline o salto de l\u00ednea. Todas las instrucciones en C terminan en un ; . La \u00faltima sentencia return 0; indica que se termina la ejecuci\u00f3n de main , y devuelve al sistema el valor 0. El cero es un valor que se usa para indicar que el programa ha terminado correctamente (sin errores). La devoluci\u00f3n de un n\u00famero distinto de cero indican distintos errores (por ejemplo que no se encuentra un fichero). Vamos a compilar y ejecutar nuestro primer programa. Son tres pasos: A partir del fichero de texto con nuestro programa con el co\u0301digo fuente en lenguaje C se realiza una fase de preprocesado en la que se eliminan comentarios y se satisfacen directivas # gcc -\u00adE holamundo.c Una vez preprocesado se genera un fichero con co\u0301digo objeto en el paso de compilacio\u0301n gcc -\u00adc holaMundo.c . Nos genera holaMundo.o El fichero objeto se debe enlazar con las libreri\u0301as para generar el ejecutable en el paso de enlazado. Esto se puede realizar con una instruccio\u0301n: gcc holaMundo.c \u00ad-o holaMundo Su forma de uso m\u00e1s b\u00e1sica es \u00e9sta (agrupamos los pasos anteriores en una \u00fanica instrucci\u00f3n): gcc -o holamundo holamundo.c La opci\u00f3n -o es abreviatura de output , y a ella le sigue el nombre del fichero que contendr\u00e1 la traducci\u00f3n a c\u00f3digo m\u00e1quina del programa. Este fichero s\u00f3lo se genera si el programa C est\u00e1 correctamente escrito y no tiene errores de compilaci\u00f3n. Ahora ejecutamos el fichero ejecutable: ./holamundo y el resultado es la salida por pantalla: Hola mundo!!","title":"2.1. Desarrollo de programas en lenguaje C"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#22-aprender-a-programar","text":"A programar se aprende programando . En esta asignatura os dar\u00e9is cuenta que no sirve de nada memorizar programas, ni mirar ejercicios resueltos o soluciones a las pr\u00e1cticas planteadas. Deb\u00e9is empezar desde el principio a hacer peque\u00f1os programas y modificaciones de los que hagamos o planteemos en clase. Pelearos con el c\u00f3digo, que os salgan errores, resolverlos, etc. Es la \u00fanica forma de aprender. Una vez hay\u00e1is implementado una soluci\u00f3n a un problema, entonces es el momento de mirar otra soluci\u00f3n para ver si pod\u00e9is mejorarlo, pero primero deb\u00e9is haberlo resuelto vosotros o al menos intentado resolver. Un programa de computadora es s\u00f3lo una recopilaci\u00f3n de las instrucciones necesarias para resolver un problema espec\u00edfico. El m\u00e9todo utilizado para resolver el problema se conoce como algoritmo. Por ejemplo, si queremos implementar un programa que comprueba si un n\u00famero es impar, el conjunto de instrucciones que resuelve el problema es el programa . El m\u00e9todo que se utiliza para comprobar si el n\u00famero es par o impar es el algoritmo . Normalmente, para desarrollar un programa para resolver un problema particular, primero hay que pensar en el algoritmo y luego desarrollar un programa que implementa ese algoritmo. Por lo tanto, el algoritmo para resolver el problema par / impar podr\u00eda expresarse de la siguiente manera: Primero, dividir el n\u00famero por dos. Si el resto de la divisi\u00f3n es cero, el n\u00famero es par; de lo contrario, el n\u00famero es impar.","title":"2.2. Aprender a programar"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#23-normas-de-estilo-para-programar-en-c","text":"Nota : En este apartado vamos a hablar de t\u00e9rminos que iremos explicando poco a poco en la asignatura. La idea es recopilarlo para que os sirva de gu\u00eda y de consulta. Los programas, a lo largo del tiempo, se van quedando obsoletos, por ejemplo, actualizaci\u00f3n del software de un robot para una determinada tarea. Es muy normal tener que modificar un programa porque debamos actualizarlo o porque decidamos incluirle nuevas posibilidades que antes no estaban previstas. Por otra parte, tambi\u00e9n es frecuente que uno deba modificar un programa escrito por otro programador, encontr\u00e1ndonos con problemas de legibilidad. Para poder modificarlo, primero hay que comprender su funcionamiento, y para facilitar esta tarea el programa debe estar escrito siguiendo unas normas b\u00e1sicas. Adem\u00e1s, el lenguaje C se presta a hacer programas complejos y dif\u00edciles de comprender. En C se pueden encapsular \u00f3rdenes y operadores, de tal forma que, aunque consigamos mayor eficiencia su comprensi\u00f3n sea todo un reto. No existen un conjunto de reglas fijas para programar con legibilidad. Lo que s\u00ed existen son un conjunto de reglas generales: Identificadores significativos Constantes simb\u00f3licas Comentarios Estructura del programa Identaci\u00f3n o sangrado","title":"2.3 Normas de estilo para programar en C"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#24-consejos-para-la-realizacion-de-las-practicas-de-programacion","text":"Leer bien el enunciado de lo que te piden. Pensar antes de escribir el c\u00f3digo. Coger l\u00e1piz y papel y estructurar los pasos que se desean implementar (algoritmo). Detenerse ante cualquier mensaje de error o warning y solucionarlo antes de continuar. Ir paso a paso. Nunca escribas una gran porci\u00f3n de c\u00f3digo sin haberla probado poco a poco. Escribir comentarios a medida que escribes c\u00f3digo. Preguntar al profesor lo que no entiendas. IMPORTANTE : No programas para el ordenador, programas para ti. Programar no es escribir c\u00f3digo y olvidarlo, sino mantenerlo. Puedes echarle un vistazo a este divertido enlace donde explican qu\u00e9 no debes hacer cuando implementas un programa.","title":"2.4. Consejos para la realizaci\u00f3n de las pr\u00e1cticas de programaci\u00f3n"},{"location":"Teoria/tema01-introduccion-a-la-programacion/tema01-introduccion-a-la-programacion.html#bibliografia","text":"Cap\u00edtulo 1 y del 3.1 al 3.4 de \"Programaci\u00f3n en C, metodolog\u00eda, algoritmos y estructuras de datos\", Luis Joyanes, Ignacio Zahonero Cap\u00edtulo 1.4 \"Programming Language Pragmatics\", Michael L. Scott, Compilation and Interpretation Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares Puig","title":"Bibliograf\u00eda"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html","text":"Tema 2: Tipos de datos simples \u00b6 1. Tipos de datos \u00b6 Los elementos b\u00e1sicos de los que consta un programa son: los datos las instrucciones que los procesan Los datos son los elementos que manipulan los programas. Para almacenar datos necesitamos zonas de memoria del ordenador. La memoria del ordenador est\u00e1 dividida en casillas numeradas en las que se guardan los datos. Los lenguajes de programaci\u00f3n nos permiten asignar nombres simb\u00f3licos a estas celdillas y controlar qu\u00e9 zonas de memoria est\u00e1n libres y ocupadas. El programador \u00fanicamente tiene que indicarle al ordenador el nombre de las zonas de memoria donde se quiere almacenar la informaci\u00f3n y de qu\u00e9 tipo es son los datos. A estas zonas de memoria les llamaremos variables . En un programa podemos distinguir entre: datos de entrada / salida: usados como punto de partida o resultado datos internos / auxiliares: usados por el programa para obtener el resultado Por ejemplo, en un programa que calcula la longitud de una circunferencia ( Dia\u0301metro * PI ) Dato de entrada: radio de la circunferencia Dato de salida: longitud de la circunferencia Datos internos: di\u00e1metro de la circunferencia, que toma como valor 2*radio de la circunferencia El lenguaje C es fuertemente tipado , eso significa que tenemos que asignar expl\u00edcitamente un tipo a cada dato. El tipo de un dato es el conjunto de valores que puede tomar durante el programa. La asignaci\u00f3n de tipos a los datos tiene cuatro objetivos principales: Determinar el rango de objetos que puede representar el dato. Conocer qu\u00e9 operaciones se pueden realizar con ellos Detectar errores en las operaciones Determinar c\u00f3mo ejecutar operaciones La clasificaci\u00f3n de los datos se hace teniendo en cuenta dos aspectos: Tama\u00f1o que ocupa en memoria fijo o variable: tipos est\u00e1ticos o din\u00e1micos N\u00famero de elementos que representan: tipos simples o estructurados Tipos est\u00e1ticos Ocupan un tama\u00f1o fijo en memoria, es decir, su tama\u00f1o no puede variar durante la ejecuci\u00f3n de un programa. Una vez declarada una variable de un tipo determinado, a \u00e9sta se le asigna un trozo de memoria fijo, y ese trozo no se podr\u00e1 aumentar ni disminuir. Tipos din\u00e1micos Tambi\u00e9n llamados punteros , los veremos m\u00e1s adelante. Un puntero no define un tipo determinado, sino que apunta a una direcci\u00f3n de memoria. Podemos reservar un tama\u00f1o determinado de memoria, ampliarlo, reducirlo y liberarlo. Tipos simples S\u00f3lo representan un dato, son los tipos b\u00e1sicos: entero, car\u00e1cter, real, etc. Tipos estructurados Est\u00e1n formados por un conjunto de elementos (tipos simples u otros estructurados). Los veremos en pr\u00f3ximos temas 2. Identificadores \u00b6 Un identificador es un nombre que se asigna a los distintos elementos de un programa: variables, funciones, etc. En lenguaje C son v\u00e1lidos los caracteres alfab\u00e9ticos en may\u00fasculas, min\u00fasculas, d\u00edgitos num\u00e9ricos (0..9) y el subrayado (_), aunque no pueden empezar por un n\u00famero. Las may\u00fasculas y min\u00fasculas se consideran caracteres distintos, el identificador hola es distinto a Hola . Ejemplo de identificadores v\u00e1lidos: 1 2 X Y12 sum_1 _temperature names area tax_rate TABLE Ejemplo de identificadores no v\u00e1lidos: 1 2 3 4 5 6 4 th /* El primer car\u00e1cter debe ser una letra o (_) */ \"x\" /* Car\u00e1cter no v\u00e1lido (\") */ num - orden /* Car\u00e1cter no v\u00e1lido (-) */ error flag /* Car\u00e1cter no v\u00e1lido (espacio) */ numero % 1 /* Car\u00e1cter no v\u00e1lido (%) */ numero $ 2 /* Car\u00e1cter no v\u00e1lido ($) */ Ejercicio : Indica qu\u00e9 identificadores son v\u00e1lidos en C: 1 2 3 casa mi - casa mi * casa micasa1 _MES MES_1 MES % 1 mes $ 1 a980 890 a _890 $ a890 Soluci\u00f3n: Son inv\u00e1lidos mi-casa mi*casa MES%1 mes$1 $a89 890a Las palabras reservadas son identificadores que tienen un significado especial para el compilador. Las palabras reservadas no se pueden usar como identificadores. Todas las palabras reservadas en C se escriben en min\u00fasculas. Palabras reservadas en C: 1 2 3 4 5 6 7 8 9 auto else long typedef break enum register union case extern return unsigned char float short void const for signed volatile continue goto sizeof while default if static _Bool do inline struct _Complex double int switch _Imaginary 3. Variables y constantes \u00b6 3.1. Variables \u00b6 Las variables son espacios reservados en la memoria que, como su nombre indica, pueden cambiar de contenido a lo largo de la ejecuci\u00f3n de un programa. Una variable corresponde a un \u00e1rea reservada en la memoria principal del ordenador. Para que nuestro c\u00f3digo sea m\u00e1s entendible y claro, el identificador de la variable debe ser mnemot\u00e9cnico, es decir que debe reflejar el uso dentro del programa de la misma El tama\u00f1o de la zona de memoria, en bytes, depender\u00e1 del tipo de dato que se almacene en la variable. Todas las variables en C deben definirse antes de su uso. En una misma l\u00ednea se pueden declarar varias variables del mismo tipo. Sintaxis: 1 < tipo_de_datos > < nombre1 > [, < nombre2 > ,...]; Ejemplo: 1 2 3 4 int temperaturaHorno ; // variable tipo int long numeroTelefono ; // variable tipo long float interes ; // variable tipo float double nota1 , nota2 ; // variables tipo double 3.2. Constantes \u00b6 Una constante representa un valor determinado que no cambia a lo largo del programa. Constantes con #define En C se definen mediante macros a trav\u00e9s de la directiva #define mediante la sintaxis: 1 #define <nombre> <valor> La palabra reservada define indica que la constante tiene un valor fijo durante toda la ejecuci\u00f3n del programa. El preprocesador debe sustituir las ocurrencias de nombre por su valor . Se suelen escribir en may\u00fasculas. Ejemplo: 1 2 3 4 #define PI 3.141516 #define VELOCIDAD_LUZ 300000 #define MENSAJE \"pulse intro\" #define VERDADERO 1 Constantes con const Otra forma de definir constantes es mediante la instrucci\u00f3n const . Sintaxis: 1 const tipo identificador = valor ; const : palabra clave usado para crear constantes tipo : palabra clave que determina el tipo de la variable: char, short, int, float, double identificador : nombre asignado a la variable, a eleccio\u0301n del desarrollador valor : valor compatible con el tipo de la variable Ejemplo: 1 const double cambioEuroPesetas = 166.386 ; Diferencias entre #define y const : #define afecta durante el proceso de pre-procesado, antes de la compilacio\u0301n (donde p.e., se eliminan los comentarios). const permite indicar de forma expli\u0301cita el tipo de la constante Variables y constantes en Python En C (lenguaje imperativo) hemos visto que las variables se pueden entender como \"cajas\" o zonas de memoria en las que se guardan los datos. Pero en Python (lenguaje orientado a objetos) las variables son \"etiquetas\" que permiten hacer referencia a los datos (objetos). En C hemos visto que para definir una variable es necesario que antes de utilizar esa variable se defina el tipo de informaci\u00f3n que va a contener (C es un lenguaje fuertemente tipado). En Python (lenguaje d\u00e9bilmente tipado), es el int\u00e9rprete del lenguaje el que decide el tipo de variable a utilizar en el momento que se guarda la informaci\u00f3n. Definimos variables en Python: 1 2 3 >>> a = 3 >>> nombre = \"hola\" >>> precio = 30.95 4. Tipos de datos simples \u00b6 En C hay 8 tipos de datos simples o elementales, a partir de los cuales se construyen todos los dem\u00e1s. Estos tipos sirven para hacer operaciones aritm\u00e9ticas (num\u00e9ricos enteros o reales), representaci\u00f3n de caracteres (caracteres) y valores l\u00f3gicos (booleanos). Vamos a ver los tipos de datos simples, sus operadores asociados y el tama\u00f1o que ocupan en memoria. 4.1. Enteros \u00b6 Los tipos de datos que permiten representar n\u00fameros enteros en C son: 1 2 3 short int long Permiten representar n\u00fameros positivos y negativos sin partes decimales. Podemos utilizar el modificador previo unsigned para indicar que se trata de un n\u00famero positivo (sin signo). Tama\u00f1o de los n\u00fameros enteros En el tama\u00f1o de los datos simples de C se suelen utilizar bytes (8 bits). Con 8 bits podemos representar hasta 2 8 = 256 combinaciones Tipo Bytes Valor m\u00ednimo Valor m\u00e1ximo short 2: 2 8 * 2 8 =2 16 -32.767 +32.767 unsigned short 2: 2 16 0 +65.535 int 4: 2 32 -2.147.483.647 +2.147.483.647 unsigned int 4: 2 32 0 +4.294.967.295 long 8: 2 64 -9.223.372.036.854.775.808 +9.223.372.036.854.775.808 Una forma de comprobar el tama\u00f1o que ocupa cada tipo en memoria es usar el operador sizeof . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* Este programa muestra para cada uno de los tipos de * datos b\u00e1sicos enteros de C el tama\u00f1o que ocupa en * bytes. */ #include <stdio.h> int main () { printf ( \"Un int ocupa %d bytes \\n \" , sizeof ( int )); printf ( \"Un unsigned int ocupa %d bytes \\n \" , sizeof ( unsigned int )); printf ( \"Un short ocupa %d bytes \\n \" , sizeof ( short )); printf ( \"Un unsigned short ocupa %d bytes \\n \" , sizeof ( unsigned short )); printf ( \"Un long ocupa %d bytes \\n \" , sizeof ( long )); printf ( \"Un unsigned long ocupa %d bytes \\n \" , sizeof ( unsigned long )); return 0 ; } Si se asigna a una variable de un tipo un valor que est\u00e1 fuera de su rango, no se obtiene ning\u00fan error ni aviso. Ese es uno de los problemas de C, su permisividad con los tipos. Hay que ser cuidadoso. 4.2. Reales \u00b6 Hay dos tipos n\u00fameros reales o n\u00fameros en coma flotante en C: 1 2 float double La representacio\u0301n interna de estos nu\u0301meros es diferente (uso de coma flotante), ya que los valores ma\u0301ximos y mi\u0301nimos no se obtienen so\u0301lo con los bytes. Adema\u0301s del rango (valores mi\u0301nimos y ma\u0301ximos), importa la precisio\u0301n (nu\u0301mero de cifras decimales): Tipo Bytes Valor m\u00ednimo Valor m\u00e1ximo Precisi\u00f3n float 4 -10 38 +10 38 7 cifras decimales double 8 -10 308 +10 308 15 cifras decimales Operaciones con n\u00fameros enteros y reales Operadores aritm\u00e9ticos. Operador Significado = Asignaci\u00f3n * Multiplicaci\u00f3n / Divisi\u00f3n % Resto de divisi\u00f3n entera (mod) + Suma - Resta 1 2 3 4 5 // Ejemplo operador m\u00f3dulo % int a = 6 ; a % 3 ; //\u2192 devuelve 0 a % 4 ; //\u2192 devuelve 2 Cuando la divisi\u00f3n se realiza entre enteros, el resultado se trunca al entero m\u00e1s pr\u00f3ximo por debajo. Por ejemplo, el resultado de 23/5 es 4 (se llama divisi\u00f3n entera). Sin embargo en la divisi\u00f3n real (alguno de los operandos es un n\u00famero real) no se trunca el resultado. 23/4 da 5.75 4.3. Car\u00e1cter \u00b6 El tipo car\u00e1cter char permite representar valores consistentes en un \u00fanico car\u00e1cter, como 'a', 'z', 'B', '%', '5', etc. Los caracteres v\u00e1lidos son los que est\u00e1n incluidos en la tabla del est\u00e1ndar ASCII extendido. El est\u00e1ndar incluye 256 caracteres, por lo que se necesitan 8 bits (1 byte) para representar un car\u00e1cter en C. 4.4. L\u00f3gico \u00b6 A diferencia de otros lenguajes, C no tiene un tipo booleano nativo. Necesitamos a\u00f1adir la cabecera: 1 #include <stdbool.h> Se maneja como nu\u0301mero de 1 byte (un bit seri\u0301a suficiente). Va\u0301lido para operaciones lo\u0301gicas. Operaciones con booleanos Operadores l\u00f3gicos. Operador Significado && AND l\u00f3gico || OR l\u00f3gico ! NOT l\u00f3gico 1 2 3 4 5 6 // Ejemplo bool a = true , b = false ; a && b ; // devuelve false a || b ; // devuelve true ! a ; // devuelve false Operadores relacionales: el resultado es un booleano Operador Significado < <= menor o menor/igual > >= mayor o mayor/igual == comparaci\u00f3n != distinto 1 2 3 4 5 6 // Ejemplo int a = 3 , b = 2 ; a > b ; // devuelve true a != b // devuelve true a == b ; // devuelve false Gu\u00eda operaciones l\u00f3gicas: 1 2 3 4 5 6 7 8 9 10 11 /* Algunas operaciones l\u00f3gicas */ int main () { printf ( \"Operaciones l\u00f3gicas:\" ); printf ( \"!true es %d \\n \" , ! true ); printf ( \"!false es %d \\n \" , ! false ); printf ( \"true AND false es %d \\n \" , true && false ); printf ( \"false OR true es %d \\n \" , false || true ); return 0 ; } Ejemplo del tama\u00f1o de tipos de datos simples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* Programa que muestra los tama\u00f1os de cada tipo */ #include <stdio.h> #include <limits.h> int main () { printf ( \" \\n n\u00famero de bits por char: %d\" , CHAR_BIT ); printf ( \" \\n m\u00ednimo valor para un signed char: %d\" , SCHAR_MIN ); printf ( \" \\n m\u00e1ximo valor para un signed char %d\" , SCHAR_MAX ); printf ( \" \\n m\u00ednimo valor para un signed short %d\" , SHRT_MIN ); printf ( \" \\n m\u00e1ximo valor para un signed short %d\" , SHRT_MAX ); printf ( \" \\n m\u00e1ximo valor para un unsigned short %d\" , USHRT_MAX ); printf ( \" \\n m\u00ednimo valor para un int %d\" , INT_MIN ); printf ( \" \\n m\u00e1ximo valor para un int %d\" , INT_MAX ); printf ( \" \\n m\u00ednimo valor para un long %ld\" , LONG_MIN ); printf ( \" \\n m\u00e1ximo valor para un long %ld\" , LONG_MAX ); return 0 ; } Precedencia de los operadores Precedencia Operador Asociatividad 0 ()[] -> . izq. a derecha 1 sizeof (tipo) ! ~ ++ -- signo* & derecha a izq. 2 * / % izq. a derecha 3 + - izq. a derecha 4 > izq. a derecha 5 >= izq. a derecha 6 == != izq. a derecha 7 && izq. a derecha 8 = += -= *= etc derecha a izq. 4.5. Enumerados \u00b6 Un tipo enumerado permite definir un conjunto de constantes simb\u00f3licas con valor entero. Limita los posibles valores a los expresados expli\u0301citamente a trave\u0301s de una lista. Cada valor de la enumeracio\u0301n se asocia internamente a un nu\u0301mero entero, comenzando por 0 y aumentando de 1 en 1. 1 enum calificacion { suspenso , aprobado , notable , sobresaliente , matricula }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Programa que hace operaciones con d\u00edas de la semana int main () { enum DiasSemana { lunes , martes , miercoles , jueves , viernes , sabado , domingo }; enum DiasSemana dia ; // variable tipo enum dia = lunes ; printf ( \"Primer d\u00eda de la semana: %d \\n \" , dia ); //0 dia = martes ; printf ( \"Segundo d\u00eda de la semana: %d \\n \" , dia ); //1 dia = miercoles ; printf ( \"Tercer d\u00eda de la semana: %d \\n \" , dia ); //2 dia = jueves ; printf ( \"Cuarto d\u00eda de la semana: %d \\n \" , dia ); //3 dia = viernes ; printf ( \"Quinto d\u00eda de la semana: %d \\n \" , dia ); //4 dia = sabado ; printf ( \"Sexto d\u00eda de la semana: %d \\n \" , dia ); //5 dia = domingo ; printf ( \"Ultimo d\u00eda de la semana: %d \\n \" , dia ); //6 return 0 ; } Tambi\u00e9n podemos asignar un valor distinto a cada elemento de la enumeraci\u00f3n: 1 enum Respuesta { No = - 1 , Si = 1 }; Otro ejemplo: 1 2 3 4 enum paloPoker { pica , corazon , trebol , diamante }; enum paloPoker paloCarta ; //variable tipo enum paloCarta = corazon ; paloCarta = espada ; // Error! espada no definida en enum 5. Definici\u00f3n de tipos con typedef \u00b6 C permite que el programador defina sus propios tipos de datos mediante la palabra clave typedef . Esta palabra puede tener distintos usos, los iremos viendo conforme vayamos aprendiendo los distintos tipos de datos. Su funci\u00f3n es asignar un nombre alternativo (alias) a tipos existentes, a menudo cuando su declaraci\u00f3n normal es aparatosa, o potencialmente confusa. La sintaxis es: 1 typedef declaraci\u00f3n ; Ejemplo b\u00e1sico con int : 1 2 int notas ; notas = 100 ; Le damos un alias a int : 1 2 3 typedef int nota_alumno_t ; nota_alumno_t notas ; notas = 100 ; Ambas secciones de c\u00f3digo hacen lo mismo: crean un tipo int (notas) y le dan un valor de 100. La segunda secci\u00f3n es m\u00e1s legible. Es m\u00e1s \u00fatil usarlo con definiciones de tipos m\u00e1s complejas, como enum : 1 2 3 typedef enum { pica , corazon , trebol , diamante } TPaloPoker ; TPaloPoker paloCarta ; //variable tipo TPaloPoker paloCarta = corazon ; 6. Sentencias de entrada / salida \u00b6 Las sentencias de entrada permiten asociar a las variables valores aportados por el usuario. Por ejemplo, un programa que pida al usuario un precio en euros para convertirlo a pesetas. Las veremos m\u00e1s adelante. Las sentencias de salida permiten mostrar datos al usuario, incluyendo el valor de las variables. Por ejemplo, mostrar el precio una vez convertido a pesetas. 6.1. Salida: printf \u00b6 Permite imprimir en la pantalla en un formato determinado: cadenas de caracteres que se mostrara\u0301n conforme se hayan introducido variables que mostrara\u0301n su valor en base a un tipo indicado Las cadena de caracteres puede incluir valores especiales para introducir saltos de linea usando \\n Sintaxis 1 printf ( cadena de control , val1 , val2 , ..., valN ); La cadena de control debe ir entre comillas dobles. Ejemplo: \u201cHola mundo\u201d Si queremos mostrar el valor de una variable o valor, haremos uso de especificadores de formato (marcas) dentro de la cadena de control. Por cada marca debemos an\u0303adir una variable o valor. La marca determina co\u0301mo visualizar la variable (nu\u0301mero, base del numero, cifras decimales, etc). El valor puede ser el resultado de una operacio\u0301n Los c\u00f3digos de formato o marcas se definen usando %tipo . Los m\u00e1s comunes son: Formato Significa %d %i entero %c car\u00e1cter %f real %ld long %u unsigned %e real notaci\u00f3n cient\u00edfica Precisi\u00f3n Si a\u00f1adimos un .numero entre el % y el f podemos ajustar la cantidad de decimales que queremos mostrar: 1 printf ( \"La nota media es: %.3f\" , nota ); // 3 decimales Ejemplos: 1 2 3 4 5 6 7 int operandoA = 2 ; float operandoB = 5.4 ; printf ( \"La suma de %d + %f es: %f \\n \" , operandoA , operandoB , operandoA + operandoB ); // La suma de 2 + 5.400000 es: 7.400000 printf ( \"La suma de %d + %f es: %e \\n \" , operandoA , operandoB , operandoA + operandoB ); // La suma de 2 + 5.400000 es: 7.400000e+00 1 2 3 4 5 6 7 8 9 char inicial = 'g' ; printf ( \"El apellido ma\u0301s comu\u0301n es %carcia \\n \" , inicial ); // El apellido ma\u0301s comu\u0301n es garcia printf ( \"El apellido ma\u0301s comu\u0301n es \\n\\n %carcia \\n \" , inicial ); // El apellido ma\u0301s comu\u0301n es // garcia Ejemplo con tipo char: 1 2 3 4 5 6 7 char valorImprimir = 65 ; printf ( \"El valor de valorImprimir es: %c \\n \" , valorImprimir ); // El valor de valorImprimir es: A char valorImprimir = 'A' ; printf ( \"El valor de valorImprimir es: %d \\n \" , valorImprimir ); // El valor de valorImprimir es: 65 6.2. Entrada: scanf \u00b6 La sentencia scanf nos permite leer un dato que ha introducido el usuario desde teclado y almacenarlo en una variable. Se utilizan una serie de marcas, de forma ana\u0301loga a printf , para dar formato a la entrada en base a los tipos base. Sintaxis Su sintaxis es similar a printf : 1 scanf ( cadena de control , & var1 , & var2 , ..., & varN ); La cadena de control debe ir entre comillas dobles e incluir tantas marcas como valores queramos solicitar al usuario. Cada marca consta de un % y una letra indicando el tipo esperado. Ejemplo: \"%d %c\" : Esperamos que el usuario introduzca un entero y un cara\u0301cter simple Cada variable debe ir precedida de & , usado para el manejo de punteros (se vera\u0301 en futuros temas) La ejecucio\u0301n se detendra\u0301 cuando que el usuario haya introducido valores paras las N variables solicitadas Respecto a las marcas, utilizaremos los tipos usados con printf excepto en el tipo double que debemos usar %lf y el %u para enumerados. El resto se mantienen: %c para char , %d para int y %f para float . Ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <stdio.h> int main () { char letra ; char siguiente ; printf ( \"Introduce una letra: \" ); scanf ( \"%c\" , & letra ); printf ( \"El valor de letra es %c \\n \" , letra ); siguiente = letra + 1 ; printf ( \"La siguiente letra es %c \\n \" , siguiente ); return 0 ; } Ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // C\u00e1lculo el \u00edndice de masa corporal IMC de una persona double peso , imc ; int altura ; char nom , ap1 , ap2 ; printf ( \"Introduce tus iniciales \\n \" ); scanf ( \"%c %c %c\" , & nom , & ap1 , & ap2 ); printf ( \"Introduce tu altura en centi\u0301metros \\n \" ); scanf ( \"%d\" , & altura ); printf ( \"Introduce tu peso en kilos \\n \" ); scanf ( \"%lf\" , & peso ); printf ( \"Peso: %g kilogramos y Altura: %d,%d metros \\n \" , peso , ( altura / 100 ), altura % 100 ); imc = peso / (( altura / 100.0 ) * ( altura / 100.0 )); printf ( \"El IMC de %c%c%c es %g \\n \" , nom , ap1 , ap2 , imc ); Tenemos que tener cuidado cuando leamos caracteres utilizando scanf . Fijaros en el siguiente c\u00f3digo. \u00bfQu\u00e9 sucede? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main () { char c ; printf ( \"letra 1: \\n \" ); scanf ( \"%c\" , & c ); printf ( \"c = %c \\n \" , c ); printf ( \"letra 2: \\n \" ); scanf ( \"%c\" , & c ); printf ( \"c = %c \\n \" , c ); printf ( \"letra 3: \\n \" ); scanf ( \"%c\" , & c ); printf ( \"c = %c \\n \" , c ); return 0 ; } Si observamos la salida por pantalla, obtenemos: 1 2 3 4 5 6 7 8 letra 1 : s c = s letra 2 : c = letra 3 : a c = a \u00bfQu\u00e9 ha sucedido con la segunda entrada? Se ha saltado. \u00bfPor qu\u00e9? El scanf funciona mediante un buffer. Cuando tecleamos cualquier valor en el teclado y pulsamos 'intro', el \\n tambi\u00e9n es un car\u00e1cter ASCII y se queda almacenado en el buffer. De forma que si lo que leemos a continuaci\u00f3n es otro car\u00e1cter, se recoge el \\n que estaba en el buffer y se salta a la siguiente instrucci\u00f3n. Esto no sucede si lo que leemos es un entero u otro tipo de dato. Para solucionarlo, tenemos que quitar del buffer el \\n antes de leer cualquier car\u00e1cter. La forma m\u00e1s sencilla consiste en poner un \\n en el scanf antes del %c (s\u00f3lo cuando se lean caracteres): 1 scanf ( \" \\n %c\" , & c ); Tipos de datos en Python \u00b6 Ya vimos en el tema anterior que Python es un lenguaje d\u00e9bilmente tipado. Eso significa que cuando definimos una variable no tenemos que indicar de qu\u00e9 tipo es el dato que va almacenar, porque el int\u00e9rprete lo puede inferir, pero internamente s\u00ed que se trabaja con tipos datos. En Python, para saber de qu\u00e9 tipo es una variable tenemos la instrucci\u00f3n type . Los tipos de datos que encontramos en Python son muy similares a los de C (pero siempre son objetos): enteros, decimales, complejos, cadenas, etc. Tambi\u00e9n incluye otros como tuplas, listas, diccionarios, etc. Bibliograf\u00eda \u00b6 Cap\u00edtulos 3.7 a 3.12 de \"Programaci\u00f3n en C, metodolog\u00eda, algoritmos y estructuras de datos\", Luis Joyanes, Ignacio Zahonero Cap\u00edtulos 4.1 a 4.4, 4.8 y 4.9 de \"Fundamentos de Programaci\u00f3n\", Jes\u00fas Carretero y otros Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares Puig","title":"Tema 2"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#tema-2-tipos-de-datos-simples","text":"","title":"Tema 2: Tipos de datos simples"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#1-tipos-de-datos","text":"Los elementos b\u00e1sicos de los que consta un programa son: los datos las instrucciones que los procesan Los datos son los elementos que manipulan los programas. Para almacenar datos necesitamos zonas de memoria del ordenador. La memoria del ordenador est\u00e1 dividida en casillas numeradas en las que se guardan los datos. Los lenguajes de programaci\u00f3n nos permiten asignar nombres simb\u00f3licos a estas celdillas y controlar qu\u00e9 zonas de memoria est\u00e1n libres y ocupadas. El programador \u00fanicamente tiene que indicarle al ordenador el nombre de las zonas de memoria donde se quiere almacenar la informaci\u00f3n y de qu\u00e9 tipo es son los datos. A estas zonas de memoria les llamaremos variables . En un programa podemos distinguir entre: datos de entrada / salida: usados como punto de partida o resultado datos internos / auxiliares: usados por el programa para obtener el resultado Por ejemplo, en un programa que calcula la longitud de una circunferencia ( Dia\u0301metro * PI ) Dato de entrada: radio de la circunferencia Dato de salida: longitud de la circunferencia Datos internos: di\u00e1metro de la circunferencia, que toma como valor 2*radio de la circunferencia El lenguaje C es fuertemente tipado , eso significa que tenemos que asignar expl\u00edcitamente un tipo a cada dato. El tipo de un dato es el conjunto de valores que puede tomar durante el programa. La asignaci\u00f3n de tipos a los datos tiene cuatro objetivos principales: Determinar el rango de objetos que puede representar el dato. Conocer qu\u00e9 operaciones se pueden realizar con ellos Detectar errores en las operaciones Determinar c\u00f3mo ejecutar operaciones La clasificaci\u00f3n de los datos se hace teniendo en cuenta dos aspectos: Tama\u00f1o que ocupa en memoria fijo o variable: tipos est\u00e1ticos o din\u00e1micos N\u00famero de elementos que representan: tipos simples o estructurados Tipos est\u00e1ticos Ocupan un tama\u00f1o fijo en memoria, es decir, su tama\u00f1o no puede variar durante la ejecuci\u00f3n de un programa. Una vez declarada una variable de un tipo determinado, a \u00e9sta se le asigna un trozo de memoria fijo, y ese trozo no se podr\u00e1 aumentar ni disminuir. Tipos din\u00e1micos Tambi\u00e9n llamados punteros , los veremos m\u00e1s adelante. Un puntero no define un tipo determinado, sino que apunta a una direcci\u00f3n de memoria. Podemos reservar un tama\u00f1o determinado de memoria, ampliarlo, reducirlo y liberarlo. Tipos simples S\u00f3lo representan un dato, son los tipos b\u00e1sicos: entero, car\u00e1cter, real, etc. Tipos estructurados Est\u00e1n formados por un conjunto de elementos (tipos simples u otros estructurados). Los veremos en pr\u00f3ximos temas","title":"1. Tipos de datos"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#2-identificadores","text":"Un identificador es un nombre que se asigna a los distintos elementos de un programa: variables, funciones, etc. En lenguaje C son v\u00e1lidos los caracteres alfab\u00e9ticos en may\u00fasculas, min\u00fasculas, d\u00edgitos num\u00e9ricos (0..9) y el subrayado (_), aunque no pueden empezar por un n\u00famero. Las may\u00fasculas y min\u00fasculas se consideran caracteres distintos, el identificador hola es distinto a Hola . Ejemplo de identificadores v\u00e1lidos: 1 2 X Y12 sum_1 _temperature names area tax_rate TABLE Ejemplo de identificadores no v\u00e1lidos: 1 2 3 4 5 6 4 th /* El primer car\u00e1cter debe ser una letra o (_) */ \"x\" /* Car\u00e1cter no v\u00e1lido (\") */ num - orden /* Car\u00e1cter no v\u00e1lido (-) */ error flag /* Car\u00e1cter no v\u00e1lido (espacio) */ numero % 1 /* Car\u00e1cter no v\u00e1lido (%) */ numero $ 2 /* Car\u00e1cter no v\u00e1lido ($) */ Ejercicio : Indica qu\u00e9 identificadores son v\u00e1lidos en C: 1 2 3 casa mi - casa mi * casa micasa1 _MES MES_1 MES % 1 mes $ 1 a980 890 a _890 $ a890 Soluci\u00f3n: Son inv\u00e1lidos mi-casa mi*casa MES%1 mes$1 $a89 890a Las palabras reservadas son identificadores que tienen un significado especial para el compilador. Las palabras reservadas no se pueden usar como identificadores. Todas las palabras reservadas en C se escriben en min\u00fasculas. Palabras reservadas en C: 1 2 3 4 5 6 7 8 9 auto else long typedef break enum register union case extern return unsigned char float short void const for signed volatile continue goto sizeof while default if static _Bool do inline struct _Complex double int switch _Imaginary","title":"2. Identificadores"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#3-variables-y-constantes","text":"","title":"3. Variables y constantes"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#31-variables","text":"Las variables son espacios reservados en la memoria que, como su nombre indica, pueden cambiar de contenido a lo largo de la ejecuci\u00f3n de un programa. Una variable corresponde a un \u00e1rea reservada en la memoria principal del ordenador. Para que nuestro c\u00f3digo sea m\u00e1s entendible y claro, el identificador de la variable debe ser mnemot\u00e9cnico, es decir que debe reflejar el uso dentro del programa de la misma El tama\u00f1o de la zona de memoria, en bytes, depender\u00e1 del tipo de dato que se almacene en la variable. Todas las variables en C deben definirse antes de su uso. En una misma l\u00ednea se pueden declarar varias variables del mismo tipo. Sintaxis: 1 < tipo_de_datos > < nombre1 > [, < nombre2 > ,...]; Ejemplo: 1 2 3 4 int temperaturaHorno ; // variable tipo int long numeroTelefono ; // variable tipo long float interes ; // variable tipo float double nota1 , nota2 ; // variables tipo double","title":"3.1. Variables"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#4-tipos-de-datos-simples","text":"En C hay 8 tipos de datos simples o elementales, a partir de los cuales se construyen todos los dem\u00e1s. Estos tipos sirven para hacer operaciones aritm\u00e9ticas (num\u00e9ricos enteros o reales), representaci\u00f3n de caracteres (caracteres) y valores l\u00f3gicos (booleanos). Vamos a ver los tipos de datos simples, sus operadores asociados y el tama\u00f1o que ocupan en memoria.","title":"4. Tipos de datos simples"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#41-enteros","text":"Los tipos de datos que permiten representar n\u00fameros enteros en C son: 1 2 3 short int long Permiten representar n\u00fameros positivos y negativos sin partes decimales. Podemos utilizar el modificador previo unsigned para indicar que se trata de un n\u00famero positivo (sin signo).","title":"4.1. Enteros"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#42-reales","text":"Hay dos tipos n\u00fameros reales o n\u00fameros en coma flotante en C: 1 2 float double La representacio\u0301n interna de estos nu\u0301meros es diferente (uso de coma flotante), ya que los valores ma\u0301ximos y mi\u0301nimos no se obtienen so\u0301lo con los bytes. Adema\u0301s del rango (valores mi\u0301nimos y ma\u0301ximos), importa la precisio\u0301n (nu\u0301mero de cifras decimales): Tipo Bytes Valor m\u00ednimo Valor m\u00e1ximo Precisi\u00f3n float 4 -10 38 +10 38 7 cifras decimales double 8 -10 308 +10 308 15 cifras decimales","title":"4.2. Reales"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#43-caracter","text":"El tipo car\u00e1cter char permite representar valores consistentes en un \u00fanico car\u00e1cter, como 'a', 'z', 'B', '%', '5', etc. Los caracteres v\u00e1lidos son los que est\u00e1n incluidos en la tabla del est\u00e1ndar ASCII extendido. El est\u00e1ndar incluye 256 caracteres, por lo que se necesitan 8 bits (1 byte) para representar un car\u00e1cter en C.","title":"4.3. Car\u00e1cter"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#44-logico","text":"A diferencia de otros lenguajes, C no tiene un tipo booleano nativo. Necesitamos a\u00f1adir la cabecera: 1 #include <stdbool.h> Se maneja como nu\u0301mero de 1 byte (un bit seri\u0301a suficiente). Va\u0301lido para operaciones lo\u0301gicas.","title":"4.4. L\u00f3gico"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#45-enumerados","text":"Un tipo enumerado permite definir un conjunto de constantes simb\u00f3licas con valor entero. Limita los posibles valores a los expresados expli\u0301citamente a trave\u0301s de una lista. Cada valor de la enumeracio\u0301n se asocia internamente a un nu\u0301mero entero, comenzando por 0 y aumentando de 1 en 1. 1 enum calificacion { suspenso , aprobado , notable , sobresaliente , matricula }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Programa que hace operaciones con d\u00edas de la semana int main () { enum DiasSemana { lunes , martes , miercoles , jueves , viernes , sabado , domingo }; enum DiasSemana dia ; // variable tipo enum dia = lunes ; printf ( \"Primer d\u00eda de la semana: %d \\n \" , dia ); //0 dia = martes ; printf ( \"Segundo d\u00eda de la semana: %d \\n \" , dia ); //1 dia = miercoles ; printf ( \"Tercer d\u00eda de la semana: %d \\n \" , dia ); //2 dia = jueves ; printf ( \"Cuarto d\u00eda de la semana: %d \\n \" , dia ); //3 dia = viernes ; printf ( \"Quinto d\u00eda de la semana: %d \\n \" , dia ); //4 dia = sabado ; printf ( \"Sexto d\u00eda de la semana: %d \\n \" , dia ); //5 dia = domingo ; printf ( \"Ultimo d\u00eda de la semana: %d \\n \" , dia ); //6 return 0 ; } Tambi\u00e9n podemos asignar un valor distinto a cada elemento de la enumeraci\u00f3n: 1 enum Respuesta { No = - 1 , Si = 1 }; Otro ejemplo: 1 2 3 4 enum paloPoker { pica , corazon , trebol , diamante }; enum paloPoker paloCarta ; //variable tipo enum paloCarta = corazon ; paloCarta = espada ; // Error! espada no definida en enum","title":"4.5. Enumerados"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#5-definicion-de-tipos-con-typedef","text":"C permite que el programador defina sus propios tipos de datos mediante la palabra clave typedef . Esta palabra puede tener distintos usos, los iremos viendo conforme vayamos aprendiendo los distintos tipos de datos. Su funci\u00f3n es asignar un nombre alternativo (alias) a tipos existentes, a menudo cuando su declaraci\u00f3n normal es aparatosa, o potencialmente confusa. La sintaxis es: 1 typedef declaraci\u00f3n ; Ejemplo b\u00e1sico con int : 1 2 int notas ; notas = 100 ; Le damos un alias a int : 1 2 3 typedef int nota_alumno_t ; nota_alumno_t notas ; notas = 100 ; Ambas secciones de c\u00f3digo hacen lo mismo: crean un tipo int (notas) y le dan un valor de 100. La segunda secci\u00f3n es m\u00e1s legible. Es m\u00e1s \u00fatil usarlo con definiciones de tipos m\u00e1s complejas, como enum : 1 2 3 typedef enum { pica , corazon , trebol , diamante } TPaloPoker ; TPaloPoker paloCarta ; //variable tipo TPaloPoker paloCarta = corazon ;","title":"5. Definici\u00f3n de tipos con typedef"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#6-sentencias-de-entrada-salida","text":"Las sentencias de entrada permiten asociar a las variables valores aportados por el usuario. Por ejemplo, un programa que pida al usuario un precio en euros para convertirlo a pesetas. Las veremos m\u00e1s adelante. Las sentencias de salida permiten mostrar datos al usuario, incluyendo el valor de las variables. Por ejemplo, mostrar el precio una vez convertido a pesetas.","title":"6. Sentencias de entrada / salida"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#61-salida-printf","text":"Permite imprimir en la pantalla en un formato determinado: cadenas de caracteres que se mostrara\u0301n conforme se hayan introducido variables que mostrara\u0301n su valor en base a un tipo indicado Las cadena de caracteres puede incluir valores especiales para introducir saltos de linea usando \\n","title":"6.1. Salida: printf"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#62-entrada-scanf","text":"La sentencia scanf nos permite leer un dato que ha introducido el usuario desde teclado y almacenarlo en una variable. Se utilizan una serie de marcas, de forma ana\u0301loga a printf , para dar formato a la entrada en base a los tipos base.","title":"6.2. Entrada: scanf"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#tipos-de-datos-en-python","text":"Ya vimos en el tema anterior que Python es un lenguaje d\u00e9bilmente tipado. Eso significa que cuando definimos una variable no tenemos que indicar de qu\u00e9 tipo es el dato que va almacenar, porque el int\u00e9rprete lo puede inferir, pero internamente s\u00ed que se trabaja con tipos datos. En Python, para saber de qu\u00e9 tipo es una variable tenemos la instrucci\u00f3n type . Los tipos de datos que encontramos en Python son muy similares a los de C (pero siempre son objetos): enteros, decimales, complejos, cadenas, etc. Tambi\u00e9n incluye otros como tuplas, listas, diccionarios, etc.","title":"Tipos de datos en Python"},{"location":"Teoria/tema02-tipos-de-datos-simples/tema02-tipos-de-datos-simples.html#bibliografia","text":"Cap\u00edtulos 3.7 a 3.12 de \"Programaci\u00f3n en C, metodolog\u00eda, algoritmos y estructuras de datos\", Luis Joyanes, Ignacio Zahonero Cap\u00edtulos 4.1 a 4.4, 4.8 y 4.9 de \"Fundamentos de Programaci\u00f3n\", Jes\u00fas Carretero y otros Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares Puig","title":"Bibliograf\u00eda"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html","text":"Tema 3: Sentencias de control \u00b6 1. Programas y algoritmos \u00b6 Un algoritmo es un conjunto de instrucciones que permiten hallar la solucio\u0301n a un determinado problema. Un programa es un conjunto de sentencias escritas en un lenguaje determinado para que un ordenador lleve a cabo una tarea. Los programas codifican algoritmos. Ejemplo. Tarea: Obtener el \u00e1rea de un tri\u00e1ngulo Algoritmo: multiplicar la base del tria\u0301ngulo por la altura del mismo y dividirla entre dos Programa: 1 2 3 int base = 3 , altura = 5 ; double area = base * altura / 2.0 ; printf ( \"El area de un tria\u0301ngulo de base %d y altura %d es %g \\n \" , base , altura , area ); En un determinado instante, el estado de un programa queda definido por el valor que tienen sus variables en ese momento. El estado de un programa es dina\u0301mico, y puede cambiar con la ejecucio\u0301n de sentencias dentro del mismo. Es imprescindible realizar las sentencias adecuadas en el orden adecuado . 2. Sentencias de control \u00b6 El flujo de ejecuci\u00f3n de un programa define el orden que siguen las sentencias durante la ejecuci\u00f3n del mismo. La estructura secuencial es aquella en la que las instrucciones o sentencias se ejecutan una a una en el orden establecido. Ejemplo: 1 2 3 int valorA = 11 , valorB = 4 , resultado ; resultado = valorA / valorB ; valorA = valorA + 1 ; // resultado = 2 No es lo mismo que: 1 2 3 int valorA = 11 , valorB = 4 , resultado ; valorA = valorA + 1 ; resultado = valorA / valorB ; // resultado = 3 Se puede alterar esa secuencialidad usando estructuras no secuenciales, que permiten variar el flujo de control del programa dependiendo de ciertas condiciones. Las estructuras no secuenciales son: Estructuras de selecci\u00f3n : Permite que se tomen rutas alternativas de acci\u00f3n dependiendo del resultado de una condici\u00f3n. Estructuras de iteraci\u00f3n : Permite repetir un conjunto de sentencias. 3. Estructuras de selecci\u00f3n \u00b6 Permiten que el programa determine las sentencias a ejecutar en base a determinadas condiciones . Las condiciones se presentan como operadores relacionales (condiciones booleanas), integrando como operandos valores, variables o constantes. Suponen una bifurcacio\u0301n en la secuencia de ejecucio\u0301n de las instrucciones de un programa Ejemplos donde se utilizan estructuras de seleccio\u0301n: Si el robot no tiene bateri\u0301a: ir a la zona de carga Si el robot esta\u0301 cerca de un obsta\u0301culo: reducir su velocidad Si el sema\u0301foro esta en rojo: detenernos, en cualquier otro caso: continuar Sentencia if \u00b6 La sentencia if permite decidir qu\u00e9 secuencia de c\u00f3digo se va a ejecutar a continuaci\u00f3n en base a una condici\u00f3n. La sintaxis de la sentencia if es: 1 2 3 4 // Cuando la ejecucio\u0301n condicional afecta a una u\u0301nica li\u0301nea if ( condicion_a_cumplir ) instrucci\u00f3n a realizar ; 1 2 3 4 5 // Cuando la ejecucio\u0301n condicional afecta a una o ma\u0301s li\u0301neas if ( condicion_a_cumplir ) { instrucci\u00f3n ( es ) a realizar ; } La sem\u00e1ntica (funcionamiento) del if es el siguiente: Si la condicion_a_cumplir devuelve un valor verdadero (o distinto de 0), se ejecutar\u00e1 la secuencia de instrucciones a realizar. Si la condicion_a_cumplir devuelve un valor falso (o 0), el if finalizar\u00e1 sin ejecutar la sencuencia de instrucciones asociada, pas\u00e1ndose a ejecutar la sentencia siguiente al if . Como hemos comentado, el lenguaje C nativo no incorpora el tipo bool , por lo que tenemos que incluir la librer\u00eda #include <stdbool.h> para trabajar con booleanos. La condici\u00f3n del if admite variables de otro tipo ( int , char , double , ...) y se manejan como una variable bool , tomando el valor false si vale 0 o true para cualquier otro valor. No es aconsejable. Ejemplo de sentencia if : 1 2 3 4 5 6 7 8 9 bool fumador = true ; double dineroAhorrado = 500 ; ... if ( fumador ) dineroAhorrado = 0 ; ... if ( dineroAhorrado > 1000 ) { fumador = false ; } El uso de llaves es opcional si la instruccio\u0301n a ejecutar tiene una \u00fanica sentencia y es obligatorio si la instruccio\u0301n tiene dos o ma\u0301s sentencias. Si no se an\u0303aden llaves, solamente la primera instruccio\u0301n despue\u0301s del if (condicion_a_cumplir) sera\u0301 condicional: la segunda y sucesivas se ejecutara\u0301n siempre. 1 2 3 4 5 6 7 8 9 10 11 12 13 bool condicionCumplida = false ; if ( condicionCumplida ) printf ( \"Primera instruccio\u0301n \\n \" ); printf ( \"Segunda instruccio\u0301n \\n \" ); // se ejecuta siempre printf ( \"Tercera instruccio\u0301n \\n \" ); // se ejecuta siempre if ( condicionCumplida ) { printf ( \"Primera instruccio\u0301n \\n \" ); printf ( \"Segunda instruccio\u0301n \\n \" ); printf ( \"Tercera instruccio\u0301n \\n \" ); } La condicion_a_cumplir puede obtenerse mediante la combinacio\u0301n (usando operadores lo\u0301gicos) de diferentes (sub)condiciones. Precedencia de operadores: 1 2 3 4 5 6 1. () 2. *, /, % 3. +, - 4. <, <=, >, >= \u2013 ==, != 5. && 6. || Ejemplo: 1 2 3 4 5 6 7 8 bool oscuridad = true , bateriaAgotada = false , prioridad = false , camaraEncendida = true ; int tiempoEnEspera = 100 ; ... if ( oscuridad || bateriaAgotada || ( tiempoEnEspera > 60 && ! prioridad )) cameraEncendida = false ; Un programa con sentencias if puede visualizarse como un diagrama de la siguiente forma: 1 2 3 4 5 6 7 instruccion_a ; if ( condicion ) instruccionSiSeCumpleCondicion ; instruccion_b ; instruccion_c ; Sentencia if-else \u00b6 La sentencia if-else es una forma ampliada de la sentencia if . La utilizamos cuando tenemos instrucciones que so\u0301lo queremos que se ejecuten cuando no se cumple la condicio\u0301n (opcio\u0301n else ) La sintaxis de la sentencia if-else es: 1 2 3 4 5 6 7 if ( condicion_a_cumplir ) { instruccion ( es ) _a_ejecutar_condicion_verdadera ; } else { instruccion ( es ) _a_ejecutar_condicion_falsa ; } La sem\u00e1ntica de la sentencia if-else es: Si la condicion_a_cumplir devuelve verdadero, se ejecuta instruccion(es)_a_ejecutar_condicion_verdadera . Si la condicion_a_cumplir devuelve falso, se ejecuta instruccion(es)_a_ejecutar_condicion_falsa . El uso de llaves es id\u00e9ntico a la sentencia if : opcional si la instruccio\u0301n a ejecutar tiene una \u00fanica sentencia y obligatorio si la instruccio\u0301n tiene dos o ma\u0301s sentencias, tanto en la parte del if como en el else . Ejemplo de if-else : 1 2 3 4 5 6 7 8 int dineroAhorrado = 25500 ; int precioCoche = 15000 ; if ( dineroAhorrado < precioCoche ) printf ( \"Necesitas ahorrar, so\u0301lo tienes %d euros \\n \" , dineroAhorrado ); else printf ( \"Ya puedes comprarte el coche de %d euros \\n \" , precioCoche ); Diagrama de sentencias if-else : 1 2 3 4 5 6 7 8 9 instruccion_a ; if ( condicion ) instruccionSiSeCumpleCondicion ; else instruccionSiNoSeCumpleCondicion ; instruccion_b ; instruccion_c ; Sentencias if anidadas \u00b6 Podemos anidar condiciones usando la combinacio\u0301n else if : 1 2 3 4 5 6 7 8 9 double distancia ; ... if ( distancia < 500 ) printf ( \"Cerca \\n \" ); else if ( distancia < 1500 ) printf ( \"Distancia media \\n \" ); else printf ( \"Lejos \\n \" ); Diagrama sentencia if anidada : Tambi\u00e9n podemos anidar if-else con esta estructura, dependiendo del problema: 1 2 3 4 5 6 7 8 9 10 11 12 13 if ( ...) { ... } else { if ( ... ) { ... } else { if ( ... ) { ... } } } Como siempre, hay que procurar buscar claridad, legibilidad y sencillez en nuestro programa. Si tenemos que anidar sentencias if , hacerlas lo m\u00e1s claras y eficientes posibles. Sentencias condicionales en Python Las estructuras de control de flujo condicionales, se definen mediante el uso de tres palabras claves reservadas, del lenguaje: if , elif (como el else-if de C) y else . Veamos su sintaxis con algunos ejemplos: 1 2 3 4 if semaforo == verde : print \"Cruzar la calle\" else : print \"Esperar\" 1 2 3 4 5 6 if compra <= 100 : print \"Pago en efectivo\" elif compra > 100 and compra < 300 : print \"Pago con tarjeta de d\u00e9bito\" else : print \"Pago con tarjeta de cr\u00e9dito\" 1 2 3 4 5 importe_a_pagar = total_compra if total_compra > 100 : tasa_descuento = 10 importe_descuento = total_compra * tasa_descuento / 100 importe_a_pagar = total_compra \u2013 importe_descuento Operador ? \u00b6 Es una herramienta \u00fatil para evaluar expresiones condicionales de forma abreviada. Su sintaxis general es la siguiente: 1 expresi\u00f3n1 ? expresi\u00f3n2 : expresi\u00f3n3 ; Sem\u00e1ntica : Si la expresi\u00f3n1 es cierta, entonces se eval\u00faa la expresi\u00f3n2 , en otro caso se eval\u00faa la expresi\u00f3n3 . Ejemplo: 1 2 3 4 5 6 7 8 a = b < 0 ? - b : b ; /* Si el valor de b es menor que 0, la expresi\u00f3n completa tomar\u00e1 el valor de -b, en otro caso tomar\u00e1 el valor de b. En definitiva, a la variable a se le asigna el valor absoluto de b dependiendo de la condici\u00f3n b < 0. La sentencia anterior completa es equivalente a: if (b<0) a = -b; else a = b; */ Sentencias switch \u00b6 La sentencia switch permite seleccionar entre mu\u0301ltiples opciones. La sintaxis de la sentencia switch es: 1 2 3 4 5 6 7 8 9 10 switch ( variable_entera_a_evaluar ) { case resultado_a : instruccion_a_realizar_resultado_a ; break ; case resultado_b : instruccion_a_realizar_resultado_b ; break ; default : instruccion_a_realizar_resultado_diferente_a_b ; } La sem\u00e1ntica de la sentencia switch es: Se eval\u00faa en primer lugar la expresi\u00f3n que va entre par\u00e9ntesis a continuaci\u00f3n del switch . Debe dar como resultado un n\u00famero entero. Despu\u00e9s la ejecuci\u00f3n empieza en el primer case cuya expresi\u00f3n coincida con el resultado obtenido en variable_entera_a_evaluar . Se ejecutan todas las instrucciones hasta el break . El default se ejecuta si no ha habido ning\u00fan case cuyo resultado coincida con variable_entera_a_evaluar . Si hubiesen dos o m\u00e1s sentencias case seguidas sin break , se ejecutan todas hasta llegar al break . Diagrama: Ejemplo sentencia switch-case : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int numHermanos = 6 ; // Prueba a usar 0,1,2,3,4 ... switch ( numHermanos ) { case 0 : printf ( \"Hijo/a u\u0301nico \\n \" ); break ; case 1 : printf ( \"Pareja \\n \" ); break ; case 2 : printf ( \"Familia numerosa \\n \" ); break ; default : printf ( \"Familia muy numerosa \\n \" ); } Cada bloque de sentencias case debe terminar con un break . Si no es as\u00ed, el compilador entiende que tambi\u00e9n debe ejecutarse el bloque del case siguiente y lo engloba como el mismo bloque. Ejemplo: 1 2 3 4 5 6 7 8 // Sentencias case sin break // Si contador vale 1 se ejecutar\u00e1n las dos sentencias `printf`: switch ( contador ) { case 1 : printf ( \"Opcion 1\" ); case 2 : printf ( \"Opcion 2\" ); } Lo anterior es equivalente a: 1 2 3 4 5 6 switch ( contador ) { case 1 : case 2 : printf ( \"Opcion 1\" ); printf ( \"Opcion 2\" ); } Ejemplo de enumeraciones y switch : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 enum paloPoker { pica , corazon , trebol , diamante }; enum paloPoker miCarta = pica ; switch ( miCarta ) { case diamante : printf ( \"Diamante \\n \" ); break ; case trebol : printf ( \"Tre\u0301bol \\n \" ); break ; case corazon : printf ( \"Corazo\u0301n \\n \" ); break ; case pica : printf ( \"Pica \\n \" ); break ; default : printf ( \"La carta no es de poker \\n \" ); } Ejemplo con caracteres (internamente se almacenan con un valor entero, su valor ASCII): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 char letra ; printf ( \"Introduzca una letra: \" ); scanf ( \"%c\" , & letra ); switch ( letra ) { case 'a' : printf ( \"Se ha pulsado una a.\" ); break ; case 'e' : printf ( \"Se ha pulsado una e.\" ); break ; case 'i' : printf ( \"Se ha pulsado una i.\" ); break ; case 'o' : printf ( \"Se ha pulsado una o.\" ); break ; case 'u' : printf ( \"Se ha pulsado una u.\" ); break ; default : printf ( \"Otro car\u00e1cter\" ); } Ejercicios \u00b6 Escribe un programa que pida dos n\u00fameros por teclado y nos indique cual es el mayor, cual es el menor o si son iguales. Escribe un programa que pida dos n\u00famero por teclado y nos diga si uno es m\u00faltiplo del otro (divisible). Escribe un programa que pida tres n\u00fameros por teclado y nos diga cu\u00e1l es el menor. Escribe un programa que pida una nota de 0 a 10 y la muestre en forma de texto: \"Suspenso\", \"Aprobado\", \"Notable\", \"Sobresaliente\". Escribe un programa que pida dos n\u00fameros por teclado y una de las cuatro operaciones aritm\u00e9ticas de una calculadora (+, -, *, /). Devuelve el resultado de la operaci\u00f3n aplicada a los dos n\u00fameros. Escribe un programa que calcule el \u00edndice de masa corporal IMC de una persona. Se debe introducir el peso en kg y la altura en m. El IMC = peso / (altura * altura). El programa muestra por pantalla el tipo de peso: - IMC < 18.0 --> \"Inferior al normal\" - 18.1 - 24.9 --> \"Normal\" - 25.0 - 29.9 --> \"Sobrepeso\" - IMC > 30.0 --> \"Obesidad\" Escribe un programa que solicite al usuario una letra (may\u00fascula o min\u00fascula) e indique si es una vocal o una consonante. 4. Estructuras de iteraci\u00f3n \u00b6 Un bucle es una estructura de programacio\u0301n formada por una secuencia de sentencias, denominada cuerpo del bucle , que se puede repetir varias veces. Cada ejecucio\u0301n del cuerpo del bucle es una iteracio\u0301n . El nu\u0301mero de veces que se ejecuta el cuerpo del bucle esta\u0301 controlado por una condicio\u0301n (expresio\u0301n lo\u0301gica). Por lo tanto, a la hora de disen\u0303ar e implementar un bucle, hay que tener en cuenta dos aspectos: El cuerpo del bucle Cu\u00e1ntas veces debe iterarse el cuerpo del bucle El lenguaje C proporciona tres sentencias de iteraci\u00f3n: while , do-while y for . Se pueden agrupar en dos tipos, dependiendo si conocemos de antemano el n\u00famero de iteraciones: Bucles determinados : Sabemos a priori el n\u00famero de veces que se repetir\u00e1 el bucle. Es el caso del bucle for Bucles indeterminados : No sabemos de antemano cu\u00e1ntas iteraciones se realizar\u00e1n. Es el caso de los bucles while y do-while Bucle while \u00b6 Permite repetir cero o ma\u0301s veces la ejecucio\u0301n de una secuencia de sentencias mientras la condicio\u0301n sea verdadera. Sintaxis: 1 2 3 while ( condicion_a_cumplir ) { secuencia_de_instrucciones ; } Sem\u00e1ntica: Mientras la condicion_a_cumplir devuelva un valor verdadero (distinto de cero), se ejecutar\u00e1 repetidamente la secuencia de instrucciones , evaluando nuevamente la condici\u00f3n en cada iteraci\u00f3n. Si la condicion_a_cumplir devuelve un valor falso (igual a cero), finalizara la ejecuci\u00f3n de la sentencia while . La condici\u00f3n_a_cumplir debe ir entre par\u00e9ntesis. La condici\u00f3n se sit\u00faa al inicio, por lo que es posible que si inicialmente no se cumple, no se llegue a ejecutar nunca la secuencia_de_instrucciones . Ejemplo: 1 2 3 4 5 int cargaBateria = 0 ; while ( cargaBateria < 100 ) { cargaBateria = cargaBateria + 1 ; } Otro ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 int caramelos = 0 ; char res ; printf ( \"\u00bfQuieres un caramelo (s/n)?:\" ); scanf ( \"%c\" , & res ); while ( res == 'S' || res == 's' ) { caramelos = caramelos + 1 ; printf ( \"\u00bfQuieres otro caramelo? (s/n):\" ); scanf ( \" \\n %c\" , & res ); //\"\\n\" es para que res ignore el intro } // fin de la sentencia while printf ( \"Te he dado %d caramelos \\n \" , caramelos ); Bucle do-while \u00b6 Permite repetir una o ma\u0301s veces la ejecucio\u0301n de una secuencia de sentencias mientras la condicio\u0301n sea verdadera. Sintaxis : 1 2 3 do { secuencia_de_instrucciones ; } while ( condici\u00f3n_a_cumplir ); Sem\u00e1ntica : En primer lugar se ejecuta la secuencia_de_instrucciones . Despu\u00e9s se eval\u00faa la condicion_a_cumplir . Si el resultado es verdadero se repite la ejecuci\u00f3n de secuencia de instrucciones . Si es falso, finaliza la ejecuci\u00f3n. Ejemplo: 1 2 3 4 5 6 7 8 9 10 int num ; int suma = 0 ; do { printf ( \"Introduzca un n\u00famero: (0 para finalizar)\" ); scanf ( \"%d\" , & num ); suma += num ; } while ( num != 0 ); printf ( \"La suma de todos los n\u00fameros introducidos es: %d \\n \" , suma ); Al situarse la condici\u00f3n se sit\u00faa al final, la secuencia_de_instrucciones se ejecuta al menos una vez. Bucle for \u00b6 Permite repetir un nu\u0301mero determinado de veces la ejecucio\u0301n de una secuencia de instrucciones. El nu\u0301mero de iteraciones del bucle es controlado por una variable usada como un contador . Es un bucle determinado porque conocemos de antemano el n\u00famero de iteraciones. Sintaxis : 1 2 3 for ( inicializacio \u0301 n_contador ; condicion ; modificaci\u00f3n_contador ){ secuencia_de_instrucciones ; } Sem\u00e1ntica : Primera vez que se ejecuta: Se ejecuta la inicializaci\u00f3n_contador Se eval\u00faa la condici\u00f3n . Si el resultado es verdadero se ejecuta la secuencia_de_instrucciones . Si es falso, finaliza. Segunda vez y sucesivas ejecuciones: Se ejecuta la modificaci\u00f3n_contador Se eval\u00faa la condici\u00f3n . Si el resultado es verdadero se ejecuta la secuencia_de_instrucciones . Si es falso, finaliza. Ejemplos: 1 2 3 for ( i = 0 ; i < 10 ; i ++ ) { printf ( \"Esta es la iteraci\u00f3n %d\" , i ); } Ejemplo con un incremento de 2 en 2: 1 2 3 4 5 6 7 int i ; for ( i = 6 ; i <= 20 ; i += 2 ) { // incremento de 2 en 2 if ( i % 3 == 0 ) // m\u00faltiplos de 3 printf ( \"%d \" , i ); } // Imprime 6 12 18 Cualquier bucle for se puede escribir con un bucle while : 1 2 3 for ( expresio \u0301 n_1 ; expresio \u0301 n_2 ; expresio \u0301 n_3 ) { secuencia de sentencias ; } Es equivalente a: 1 2 3 4 5 6 expresio \u0301 n_1 ; while ( expresio \u0301 n_2 ) { secuencia de sentencias ; expresio \u0301 n_3 ; } El equivalente usando while del ejemplo anterior es: 1 2 3 4 5 6 i = 0 ; while ( i < 10 ) { printf ( \"Esta es la iteraci\u00f3n %d\" , i ); i ++ ; } Pero hay que utilizar siempre el bucle adecuado. Para saber qu\u00e9 tipo de bucle hay que usar: Si el cuerpo del bucle (secuencia de instrucciones) se tiene que ejecutar al menos una vez: do-while Si no (0 \u00f3 m\u00e1s veces): Si no sabemos de antemano el n\u00famero de iteraciones: while Si sabemos el n\u00famero de iteraciones (usamos un contador): for Variables en los bucles \u00b6 En los bucles se suelen utilizar variables para unas tareas especi\u0301ficas: Contadores : son variables destinadas a contener un valor que se ira\u0301 incrementando o decrementando en una cantidad fija. Se suelen utilizar para el control de procesos repetitivos. Acumuladores : Son variables destinadas a contener distintas cantidades provenientes de los resultados obtenidos en operaciones aritme\u0301ticas previamente analizadas de manera sucesiva, lo que nos permitira\u0301 obtener el total acumulado de dichas cantidades. A diferencia de los contadores, no controlan los procesos repetitivos. Su inicializacio\u0301n depende de en que\u0301 operacio\u0301n matema\u0301tica van a ser utilizados. Interruptores (switches): tambie\u0301n denominados conmutadores o indicadores, son variables que pueden tomar dos u\u0301nicos valores considerados como lo\u0301gicos y opuestos entre si\u0301 a lo largo de todo el programa (0 o\u0301 1, 1 o\u0301 -1, Verdadero o Falso, on/off, etc.). Su objetivo es recordar en un determinado lugar del programa un suceso determinado o hacer que dos acciones diferentes se ejecuten alternativamente en un proceso repetitivo. Tambie\u0301n deben ser inicializados. No se debe abusar de su utilizacio\u0301n cuando no sea necesario. Ejercicio: Implementa un programa que lea nu\u0301meros que el usuario introduzca por teclado hasta que introduzca el cero. El programa tiene que imprimir la suma de todos los nu\u0301meros introducidos y el n\u00famero de n\u00fameros que se han introducido. Validaci\u00f3n de datos \u00b6 Cuando estamos desarrollando un programa es frecuente que nos pidan por teclado un n\u00famero que est\u00e9 en un rango determinado (por ejemplo entre 1 y 10) o que nos pidan unos determinados caracteres (por ejemplo 's' o 'n'). Normalmente en estos casos, si el dato introducido no es v\u00e1lido, se tiene que volver a solicitar un nuevo dato hasta que sea correcto. Para ello utilizamos bucles que pidan repetidamente el dato mientras no sea correcto. Por ejemplo, nos piden un n\u00famero par. Si no es par, se tiene que volver a pedir: 1 2 3 4 5 6 int num ; do { printf ( \"Introduce un n\u00famero par: \" ); scanf ( \"%d\" , & num ); } while ( num % 2 != 0 ); //repetir mientras no sea par Bucles anidados \u00b6 Se puede utilizar un bucle dentro de otro. Para cada iteraci\u00f3n del bucle exterior, se ejecuta completo el bucle interior. Ejemplo, imprimimos las posiciones de una matriz: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #define TAM 10 int main () { int fil , col ; for ( fil = 0 ; fil < TAM ; fil ++ ){ for ( col = 0 ; col < TAM ; col ++ ) { printf ( \"%4d-%d\" , fil , col ); //%4d a\u00f1ade 4 espacios delante del entero } printf ( \" \\n \" ); } return 0 ; } Bucles en Python Bucle while en Python: 1 2 3 4 num = 1 while num <= 10 : print \"El n\u00famero es: \" , num num = num + 1 Bucle for en Python: Ejemplo que itera sobre una lista: 1 2 3 4 lista_animales = [ 'gato' , 'perro' , 'pez' ] for animal in lista_animales : print \"El animal es:\" , animal Ejemplos de bucles en C \u00b6 Ejemplo con bucle while . Utilizamos el bucle indeterminado while porque no sabemos de antemano el n\u00famero de iteraciones: el bucle terminar\u00e1 cuando el usuario introduzca un cero. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* Obtener la media de una lista de n\u00fameros. La lista termina cuando se introduce el n\u00famero cero */ void main () { int total = 0 ; float num = 0 , media = 0 ; printf ( \u201c Dime un n\u00famero : \u201d ); scanf ( \u201c % f \u201d , & num ); while ( num != 0 ) { media = media + num ; total ++ ; printf ( \u201c Dime otro n\u00famero : \u201d ); scanf ( \u201c % f \u201d , & num ); } if ( total != 0 ) printf ( \u201c La media es % f . \\ n \u201d , media / total ); else printf ( \u201c No hay media . \\ n \u201d ); } Ejemplo con bucle do-while 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Calcular el n\u00famero m\u00e1s grande de una lista de n\u00fameros mayores que cero. La entrada de n\u00fameros terminar\u00e1 cuando se introduzca un n\u00famero negativo o cero. */ void main () { int num , max = 0 ; do { printf ( \u201c Dame un n\u00famero : \u201d ); scanf ( \u201c % d \u201d , & num ); if ( num > max ) max = num ; } while ( num > 0 ); if ( max != 0 ) printf ( \u201c El n\u00famero m\u00e1s grande es % d . \\ n \u201d , max ); else printf ( \u201c No hay m\u00e1ximo . \\ n \u201d ); } Ejemplo con bucle for y do-while 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #define NUM_PARCIALES 5 // Nu\u0301mero de exa\u0301menes parciales int main () { float nota_parcial , nota_final ; float suma ; int i ; suma = 0 ; // Introducir las notas de todos los parciales y sumarlas (so\u0301lo cuando el dato introducido sea correcto) for ( i = 1 ; i <= NUM_PARCIALES ; i ++ ) { do { printf ( \"Dime tu nota del parcial %d \\n \" , i ); scanf ( \"%f\" , & nota_parcial ); } while ( nota_parcial < 0.0 || nota_parcial > 10.0 ); suma = suma + nota_parcial ; } // Calcular la nota media e imprimirla por pantalla nota_final = suma / NUM_PARCIALES ; printf ( \"Tu nota final es: %.2f \\n \" , nota_final ); //%.2f imprime s\u00f3lo dos decimales return 0 ; } Factorial de un n\u00famero: 1 2 3 4 5 6 7 8 9 10 11 12 int n ; int res = 1 ; printf ( \"Introduce un n\u00famero n: \" ); scanf ( \"%d\" , & n ); do { res *= n ; n -- ; } while ( n > 1 ); printf ( \"El factorial de %d es %d \\n \" , n , res ); Ejercicio: Haz el ejercicio anterior (factorial de un n\u00famero) utilizando un bucle for 5. Traza de ejecuci\u00f3n de un programa \u00b6 Se utiliza para estudiar la secuencia de estados por los que pasa un programa, es decir, el valor que van tomando las variables instrucci\u00f3n a instrucci\u00f3n. Las variables almacenan el estado de un programa y mediante los pasos de ejecuci\u00f3n se va modificando su estado. Se utilizan principalmente para depurar un programa (corregir errores de ejecucio\u0301n) o para comprender que\u0301 hace un programa o parte del mismo. La traza se lleva a cabo normalmente mediante la ejecucio\u0301n manual de forma secuencial de las sentencias que componen el programa. Tambi\u00e9n existen herramientas de depuraci\u00f3n que nos permiten ejecutar paso a paso, o parar la ejecuci\u00f3n en un punto concreto para observar el estado del programa. Por ejemplo el depurador gdb . Ejemplo: Realiza una traza de ejecici\u00f3n del siguiente programa y explica lo que hace: 1 2 3 4 5 6 7 8 void main () { int i , res ; res = 0 ; for ( i = 1 ; i <= 10 ; i ++ ) { res += i * i ; } printf ( \"%d \\n \" , res ); } Para realizar la traza tenemos que hacer una tabla de este estilo: i i * i res 1 1 1 2 4 5 3 9 14 4 16 30 5 25 55 6 36 91 7 49 140 8 64 204 9 81 285 10 100 385 \u00bfQu\u00e9 hace el c\u00f3digo? Veamos otro ejemplo: Todos los di\u0301as paso por una libreri\u0301a y me compro una serie de libros siguiendo este patro\u0301n di\u0301a 1 \u2192 1 libro di\u0301a 2 \u2192 2 libros di\u0301a N \u2192 N libros Si tengo una estanteri\u0301a donde caben M libros \u00bf que\u0301 di\u0301a llegare\u0301 a casa y no podre\u0301 poner todos los libros que he comprado ? Programa: 1 2 3 4 5 6 7 8 int capacidadMaxima = 15 , capacidadActual = 0 , dia = 0 ; do { dia = dia + 1 ; capacidadActual = capacidadActual + dia ; } while ( capacidadActual <= capacidadMaxima ); printf ( \"Rebasamos la capacidad el di\u0301a %d\" , dia ); Traza: Iteraci\u00f3n dia capacidadActual 1 1 0 + 1 = 1 2 2 1 + 2 = 3 3 3 3 + 3 = 6 4 4 6 + 4 = 10 5 5 10 + 5 = 15 6 6 15 + 6 = 21 Ejercicios resueltos \u00b6 Ejercicio 1 Escribe un programa que lea cantidades y precios y al final indique el total de la factura. Primero se pregunta la cantidad vendida, tras lo cual el usuario introducir\u00e1 un n\u00famero entero positivo. Despu\u00e9s se pregunta el precio que ser\u00e1 un n\u00famero decimal positivo. La lectura termina cuando en la cantidad se introduzca un cero. Si es as\u00ed se escribir\u00e1 el total. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int main (){ int n ; double precio , total = 0 ; do { do { printf ( \" \\n Introduzca la cantidad vendida: \" ); scanf ( \"%d\" , & n ); } while ( n < 0 ); // validaci\u00f3n de datos if ( n > 0 ){ do { printf ( \"Introduzca el precio: \" ); scanf ( \"%lf\" , & precio ); if ( precio > 0 ) total += n * precio ; } while ( precio < 0 ); // validaci\u00f3n de datos } } while ( n != 0 ); printf ( \"Total vendido = %.2f\" , total ); return 0 ; } Ejercicio 2 Escribe un programa que escriba la tabla de multiplicar de un n\u00famero pedido entre 1 y 10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main () { int num , i ; do { printf ( \"Introduce un num entre 1 y 10: \" ); scanf ( \"%d\" , & num ); } while ( num < 1 || num > 10 ); // validaci\u00f3n de datos for ( i = 1 ; i <= 10 ; i ++ ) { printf ( \"%d x %d = %d \\n \" , i , num , i * num ); } return 0 ; } Ejercicio 3 Escribe un programa que lea un n\u00famero entero y positivo y que escriba tres columnas. La primera cuenta desde uno hasta el n\u00famero escrito contando de uno en uno; la segunda columna contando de dos en dos y la tercera de tres en tres. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int main (){ int col1 = 1 , col2 = 1 , col3 = 1 ; int n ; printf ( \"Introduce un n\u00famero: \" ); scanf ( \"%d\" , & n ); while ( col1 <= n ){ printf ( \"%d\" , col1 ); if ( col2 <= n ) { printf ( \" \\t %d\" , col2 ); //\\t para tabular if ( col3 <= n ){ printf ( \" \\t %d\" , col3 ); col3 += 3 ; } col2 += 2 ; } printf ( \" \\n \" ); col1 ++ ; } return 0 ; } Ejercicio 4 Escribe un programa que muestre un men\u00fa como este: Salir Sumatorio Factorial Tras mostrar el men\u00fa, el programa debe leer un n\u00famero del 1 al 3: si se elige 1, el programa acaba. si se elige 2 se calcula el sumatorio del n\u00famero si se elige 3 se calcula el factorial En las opciones 2 y 3 el programa pedir\u00e1 el n\u00famero sobre el que se calcula el sumatorio o el factorial. Tras calcular el sumatorio o el factorial e indicar el resultado, el programa volver\u00e1 a mostrar el men\u00fa y as\u00ed sucesivamente. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include <stdio.h> #define SALIR 1 int main (){ int seleccion ; int num , i ; int res ; do { do { printf ( \"****************** \\n \" ); printf ( \"1 Salir \\n \" ); printf ( \"2 Sumatorio \\n \" ); printf ( \"3 Factorial \\n \" ); printf ( \"****************** \\n \" ); printf ( \"Escriba su opcion: \" ); scanf ( \"%d\" , & seleccion ); } while ( seleccion != 1 && seleccion != 2 && seleccion != 3 ); switch ( seleccion ){ case 2 : /* Sumatorio */ printf ( \"Escriba el numero sobre el que quiere el sumatorio: \" ); scanf ( \"%d\" , & num ); res = 0 ; for ( i = 0 ; i <= num ; i ++ ) res += i ; printf ( \"El sumatorio es: %d \\n \" , res ); break ; case 3 : /* Factorial */ printf ( \"Escriba el numero sobre el que quiere el factorial: \" ); scanf ( \"%d\" , & num ); res = 1 ; for ( i = 1 ; i <= num ; i ++ ) res *= i ; printf ( \"El factorial es: %d \\n \" , res ); break ; } } while ( seleccion != SALIR ); return 0 ; } Ejercicio 5 Escribe un programa que lea un n\u00famero entero y a partir de \u00e9l imprima un cuadrado de asteriscos de ese tama\u00f1o. Los asteriscos s\u00f3lo se ver\u00e1n en el borde del cuadrado, no en el interior. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main (){ int n , fil , col ; printf ( \"tama\u00f1o del cuadrado: \" ); scanf ( \"%d\" , & n ); for ( fil = 0 ; fil < n ; fil ++ ) { for ( col = 0 ; col < n ; col ++ ) { if ( fil == 0 || fil == n - 1 || col == 0 || col == n - 1 ) printf ( \"*\" ); else printf ( \" \" ); } printf ( \" \\n \" ); } return 0 ; } Ejercicios propuestos \u00b6 Escribe un programa que muestre todos los multiplos de un nu\u0301mero dado en el rango [0, 100] \u2013 Pedir el nu\u0301mero por teclado Escribe un programa que muestre todos los divisores de un nu\u0301mero dado \u2013 Pedir el nu\u0301mero por consola \u2013 Uso del operando mo\u0301dulo % Hacer las trazas de los ejercicios 1 (valor de entrada 40) y 2 (valor de entrada 16) Escribir un programa que pida dos n\u00fameros y muestre un men\u00fa como este: 1 2 3 4 5 6 1. Suma 2. Resta 3. Multiplicaci\u00f3n 4. Divisi\u00f3n 5. M\u00f3dulo 6. Salir Tras mostrar el men\u00fa, el programa debe leer un n\u00famero del 1 al 6 y realizar la opci\u00f3n indicada con los dos n\u00fameros. Tras realizar las operaciones e indicar el resultado, el programa volver\u00e1 a mostrar el men\u00fa y as\u00ed sucesivamente. Finalizar\u00e1 cuando se introduzca la opci\u00f3n 6. Bibliograf\u00eda \u00b6 Cap\u00edtulos 5 y 6 de \"Programaci\u00f3n en C, metodolog\u00eda, algoritmos y estructuras de datos\", Luis Joyanes, Ignacio Zahonero Cap\u00edtulos 5.1 a 5.7 de \"Fundamentos de Programaci\u00f3n\", Jes\u00fas Carretero y otros Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares Puig","title":"Tema 3"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#tema-3-sentencias-de-control","text":"","title":"Tema 3: Sentencias de control"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#1-programas-y-algoritmos","text":"Un algoritmo es un conjunto de instrucciones que permiten hallar la solucio\u0301n a un determinado problema. Un programa es un conjunto de sentencias escritas en un lenguaje determinado para que un ordenador lleve a cabo una tarea. Los programas codifican algoritmos. Ejemplo. Tarea: Obtener el \u00e1rea de un tri\u00e1ngulo Algoritmo: multiplicar la base del tria\u0301ngulo por la altura del mismo y dividirla entre dos Programa: 1 2 3 int base = 3 , altura = 5 ; double area = base * altura / 2.0 ; printf ( \"El area de un tria\u0301ngulo de base %d y altura %d es %g \\n \" , base , altura , area ); En un determinado instante, el estado de un programa queda definido por el valor que tienen sus variables en ese momento. El estado de un programa es dina\u0301mico, y puede cambiar con la ejecucio\u0301n de sentencias dentro del mismo. Es imprescindible realizar las sentencias adecuadas en el orden adecuado .","title":"1. Programas y algoritmos"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#2-sentencias-de-control","text":"El flujo de ejecuci\u00f3n de un programa define el orden que siguen las sentencias durante la ejecuci\u00f3n del mismo. La estructura secuencial es aquella en la que las instrucciones o sentencias se ejecutan una a una en el orden establecido. Ejemplo: 1 2 3 int valorA = 11 , valorB = 4 , resultado ; resultado = valorA / valorB ; valorA = valorA + 1 ; // resultado = 2 No es lo mismo que: 1 2 3 int valorA = 11 , valorB = 4 , resultado ; valorA = valorA + 1 ; resultado = valorA / valorB ; // resultado = 3 Se puede alterar esa secuencialidad usando estructuras no secuenciales, que permiten variar el flujo de control del programa dependiendo de ciertas condiciones. Las estructuras no secuenciales son: Estructuras de selecci\u00f3n : Permite que se tomen rutas alternativas de acci\u00f3n dependiendo del resultado de una condici\u00f3n. Estructuras de iteraci\u00f3n : Permite repetir un conjunto de sentencias.","title":"2. Sentencias de control"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#3-estructuras-de-seleccion","text":"Permiten que el programa determine las sentencias a ejecutar en base a determinadas condiciones . Las condiciones se presentan como operadores relacionales (condiciones booleanas), integrando como operandos valores, variables o constantes. Suponen una bifurcacio\u0301n en la secuencia de ejecucio\u0301n de las instrucciones de un programa Ejemplos donde se utilizan estructuras de seleccio\u0301n: Si el robot no tiene bateri\u0301a: ir a la zona de carga Si el robot esta\u0301 cerca de un obsta\u0301culo: reducir su velocidad Si el sema\u0301foro esta en rojo: detenernos, en cualquier otro caso: continuar","title":"3. Estructuras de selecci\u00f3n"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#sentencia-if","text":"La sentencia if permite decidir qu\u00e9 secuencia de c\u00f3digo se va a ejecutar a continuaci\u00f3n en base a una condici\u00f3n. La sintaxis de la sentencia if es: 1 2 3 4 // Cuando la ejecucio\u0301n condicional afecta a una u\u0301nica li\u0301nea if ( condicion_a_cumplir ) instrucci\u00f3n a realizar ; 1 2 3 4 5 // Cuando la ejecucio\u0301n condicional afecta a una o ma\u0301s li\u0301neas if ( condicion_a_cumplir ) { instrucci\u00f3n ( es ) a realizar ; } La sem\u00e1ntica (funcionamiento) del if es el siguiente: Si la condicion_a_cumplir devuelve un valor verdadero (o distinto de 0), se ejecutar\u00e1 la secuencia de instrucciones a realizar. Si la condicion_a_cumplir devuelve un valor falso (o 0), el if finalizar\u00e1 sin ejecutar la sencuencia de instrucciones asociada, pas\u00e1ndose a ejecutar la sentencia siguiente al if . Como hemos comentado, el lenguaje C nativo no incorpora el tipo bool , por lo que tenemos que incluir la librer\u00eda #include <stdbool.h> para trabajar con booleanos. La condici\u00f3n del if admite variables de otro tipo ( int , char , double , ...) y se manejan como una variable bool , tomando el valor false si vale 0 o true para cualquier otro valor. No es aconsejable. Ejemplo de sentencia if : 1 2 3 4 5 6 7 8 9 bool fumador = true ; double dineroAhorrado = 500 ; ... if ( fumador ) dineroAhorrado = 0 ; ... if ( dineroAhorrado > 1000 ) { fumador = false ; } El uso de llaves es opcional si la instruccio\u0301n a ejecutar tiene una \u00fanica sentencia y es obligatorio si la instruccio\u0301n tiene dos o ma\u0301s sentencias. Si no se an\u0303aden llaves, solamente la primera instruccio\u0301n despue\u0301s del if (condicion_a_cumplir) sera\u0301 condicional: la segunda y sucesivas se ejecutara\u0301n siempre. 1 2 3 4 5 6 7 8 9 10 11 12 13 bool condicionCumplida = false ; if ( condicionCumplida ) printf ( \"Primera instruccio\u0301n \\n \" ); printf ( \"Segunda instruccio\u0301n \\n \" ); // se ejecuta siempre printf ( \"Tercera instruccio\u0301n \\n \" ); // se ejecuta siempre if ( condicionCumplida ) { printf ( \"Primera instruccio\u0301n \\n \" ); printf ( \"Segunda instruccio\u0301n \\n \" ); printf ( \"Tercera instruccio\u0301n \\n \" ); } La condicion_a_cumplir puede obtenerse mediante la combinacio\u0301n (usando operadores lo\u0301gicos) de diferentes (sub)condiciones. Precedencia de operadores: 1 2 3 4 5 6 1. () 2. *, /, % 3. +, - 4. <, <=, >, >= \u2013 ==, != 5. && 6. || Ejemplo: 1 2 3 4 5 6 7 8 bool oscuridad = true , bateriaAgotada = false , prioridad = false , camaraEncendida = true ; int tiempoEnEspera = 100 ; ... if ( oscuridad || bateriaAgotada || ( tiempoEnEspera > 60 && ! prioridad )) cameraEncendida = false ; Un programa con sentencias if puede visualizarse como un diagrama de la siguiente forma: 1 2 3 4 5 6 7 instruccion_a ; if ( condicion ) instruccionSiSeCumpleCondicion ; instruccion_b ; instruccion_c ;","title":"Sentencia if"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#sentencia-if-else","text":"La sentencia if-else es una forma ampliada de la sentencia if . La utilizamos cuando tenemos instrucciones que so\u0301lo queremos que se ejecuten cuando no se cumple la condicio\u0301n (opcio\u0301n else ) La sintaxis de la sentencia if-else es: 1 2 3 4 5 6 7 if ( condicion_a_cumplir ) { instruccion ( es ) _a_ejecutar_condicion_verdadera ; } else { instruccion ( es ) _a_ejecutar_condicion_falsa ; } La sem\u00e1ntica de la sentencia if-else es: Si la condicion_a_cumplir devuelve verdadero, se ejecuta instruccion(es)_a_ejecutar_condicion_verdadera . Si la condicion_a_cumplir devuelve falso, se ejecuta instruccion(es)_a_ejecutar_condicion_falsa . El uso de llaves es id\u00e9ntico a la sentencia if : opcional si la instruccio\u0301n a ejecutar tiene una \u00fanica sentencia y obligatorio si la instruccio\u0301n tiene dos o ma\u0301s sentencias, tanto en la parte del if como en el else . Ejemplo de if-else : 1 2 3 4 5 6 7 8 int dineroAhorrado = 25500 ; int precioCoche = 15000 ; if ( dineroAhorrado < precioCoche ) printf ( \"Necesitas ahorrar, so\u0301lo tienes %d euros \\n \" , dineroAhorrado ); else printf ( \"Ya puedes comprarte el coche de %d euros \\n \" , precioCoche ); Diagrama de sentencias if-else : 1 2 3 4 5 6 7 8 9 instruccion_a ; if ( condicion ) instruccionSiSeCumpleCondicion ; else instruccionSiNoSeCumpleCondicion ; instruccion_b ; instruccion_c ;","title":"Sentencia if-else"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#sentencias-if-anidadas","text":"Podemos anidar condiciones usando la combinacio\u0301n else if : 1 2 3 4 5 6 7 8 9 double distancia ; ... if ( distancia < 500 ) printf ( \"Cerca \\n \" ); else if ( distancia < 1500 ) printf ( \"Distancia media \\n \" ); else printf ( \"Lejos \\n \" ); Diagrama sentencia if anidada : Tambi\u00e9n podemos anidar if-else con esta estructura, dependiendo del problema: 1 2 3 4 5 6 7 8 9 10 11 12 13 if ( ...) { ... } else { if ( ... ) { ... } else { if ( ... ) { ... } } } Como siempre, hay que procurar buscar claridad, legibilidad y sencillez en nuestro programa. Si tenemos que anidar sentencias if , hacerlas lo m\u00e1s claras y eficientes posibles.","title":"Sentencias if anidadas"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#operador","text":"Es una herramienta \u00fatil para evaluar expresiones condicionales de forma abreviada. Su sintaxis general es la siguiente: 1 expresi\u00f3n1 ? expresi\u00f3n2 : expresi\u00f3n3 ; Sem\u00e1ntica : Si la expresi\u00f3n1 es cierta, entonces se eval\u00faa la expresi\u00f3n2 , en otro caso se eval\u00faa la expresi\u00f3n3 . Ejemplo: 1 2 3 4 5 6 7 8 a = b < 0 ? - b : b ; /* Si el valor de b es menor que 0, la expresi\u00f3n completa tomar\u00e1 el valor de -b, en otro caso tomar\u00e1 el valor de b. En definitiva, a la variable a se le asigna el valor absoluto de b dependiendo de la condici\u00f3n b < 0. La sentencia anterior completa es equivalente a: if (b<0) a = -b; else a = b; */","title":"Operador ?"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#sentencias-switch","text":"La sentencia switch permite seleccionar entre mu\u0301ltiples opciones. La sintaxis de la sentencia switch es: 1 2 3 4 5 6 7 8 9 10 switch ( variable_entera_a_evaluar ) { case resultado_a : instruccion_a_realizar_resultado_a ; break ; case resultado_b : instruccion_a_realizar_resultado_b ; break ; default : instruccion_a_realizar_resultado_diferente_a_b ; } La sem\u00e1ntica de la sentencia switch es: Se eval\u00faa en primer lugar la expresi\u00f3n que va entre par\u00e9ntesis a continuaci\u00f3n del switch . Debe dar como resultado un n\u00famero entero. Despu\u00e9s la ejecuci\u00f3n empieza en el primer case cuya expresi\u00f3n coincida con el resultado obtenido en variable_entera_a_evaluar . Se ejecutan todas las instrucciones hasta el break . El default se ejecuta si no ha habido ning\u00fan case cuyo resultado coincida con variable_entera_a_evaluar . Si hubiesen dos o m\u00e1s sentencias case seguidas sin break , se ejecutan todas hasta llegar al break . Diagrama: Ejemplo sentencia switch-case : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int numHermanos = 6 ; // Prueba a usar 0,1,2,3,4 ... switch ( numHermanos ) { case 0 : printf ( \"Hijo/a u\u0301nico \\n \" ); break ; case 1 : printf ( \"Pareja \\n \" ); break ; case 2 : printf ( \"Familia numerosa \\n \" ); break ; default : printf ( \"Familia muy numerosa \\n \" ); } Cada bloque de sentencias case debe terminar con un break . Si no es as\u00ed, el compilador entiende que tambi\u00e9n debe ejecutarse el bloque del case siguiente y lo engloba como el mismo bloque. Ejemplo: 1 2 3 4 5 6 7 8 // Sentencias case sin break // Si contador vale 1 se ejecutar\u00e1n las dos sentencias `printf`: switch ( contador ) { case 1 : printf ( \"Opcion 1\" ); case 2 : printf ( \"Opcion 2\" ); } Lo anterior es equivalente a: 1 2 3 4 5 6 switch ( contador ) { case 1 : case 2 : printf ( \"Opcion 1\" ); printf ( \"Opcion 2\" ); } Ejemplo de enumeraciones y switch : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 enum paloPoker { pica , corazon , trebol , diamante }; enum paloPoker miCarta = pica ; switch ( miCarta ) { case diamante : printf ( \"Diamante \\n \" ); break ; case trebol : printf ( \"Tre\u0301bol \\n \" ); break ; case corazon : printf ( \"Corazo\u0301n \\n \" ); break ; case pica : printf ( \"Pica \\n \" ); break ; default : printf ( \"La carta no es de poker \\n \" ); } Ejemplo con caracteres (internamente se almacenan con un valor entero, su valor ASCII): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 char letra ; printf ( \"Introduzca una letra: \" ); scanf ( \"%c\" , & letra ); switch ( letra ) { case 'a' : printf ( \"Se ha pulsado una a.\" ); break ; case 'e' : printf ( \"Se ha pulsado una e.\" ); break ; case 'i' : printf ( \"Se ha pulsado una i.\" ); break ; case 'o' : printf ( \"Se ha pulsado una o.\" ); break ; case 'u' : printf ( \"Se ha pulsado una u.\" ); break ; default : printf ( \"Otro car\u00e1cter\" ); }","title":"Sentencias switch"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#ejercicios","text":"Escribe un programa que pida dos n\u00fameros por teclado y nos indique cual es el mayor, cual es el menor o si son iguales. Escribe un programa que pida dos n\u00famero por teclado y nos diga si uno es m\u00faltiplo del otro (divisible). Escribe un programa que pida tres n\u00fameros por teclado y nos diga cu\u00e1l es el menor. Escribe un programa que pida una nota de 0 a 10 y la muestre en forma de texto: \"Suspenso\", \"Aprobado\", \"Notable\", \"Sobresaliente\". Escribe un programa que pida dos n\u00fameros por teclado y una de las cuatro operaciones aritm\u00e9ticas de una calculadora (+, -, *, /). Devuelve el resultado de la operaci\u00f3n aplicada a los dos n\u00fameros. Escribe un programa que calcule el \u00edndice de masa corporal IMC de una persona. Se debe introducir el peso en kg y la altura en m. El IMC = peso / (altura * altura). El programa muestra por pantalla el tipo de peso: - IMC < 18.0 --> \"Inferior al normal\" - 18.1 - 24.9 --> \"Normal\" - 25.0 - 29.9 --> \"Sobrepeso\" - IMC > 30.0 --> \"Obesidad\" Escribe un programa que solicite al usuario una letra (may\u00fascula o min\u00fascula) e indique si es una vocal o una consonante.","title":"Ejercicios"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#4-estructuras-de-iteracion","text":"Un bucle es una estructura de programacio\u0301n formada por una secuencia de sentencias, denominada cuerpo del bucle , que se puede repetir varias veces. Cada ejecucio\u0301n del cuerpo del bucle es una iteracio\u0301n . El nu\u0301mero de veces que se ejecuta el cuerpo del bucle esta\u0301 controlado por una condicio\u0301n (expresio\u0301n lo\u0301gica). Por lo tanto, a la hora de disen\u0303ar e implementar un bucle, hay que tener en cuenta dos aspectos: El cuerpo del bucle Cu\u00e1ntas veces debe iterarse el cuerpo del bucle El lenguaje C proporciona tres sentencias de iteraci\u00f3n: while , do-while y for . Se pueden agrupar en dos tipos, dependiendo si conocemos de antemano el n\u00famero de iteraciones: Bucles determinados : Sabemos a priori el n\u00famero de veces que se repetir\u00e1 el bucle. Es el caso del bucle for Bucles indeterminados : No sabemos de antemano cu\u00e1ntas iteraciones se realizar\u00e1n. Es el caso de los bucles while y do-while","title":"4. Estructuras de iteraci\u00f3n"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#bucle-while","text":"Permite repetir cero o ma\u0301s veces la ejecucio\u0301n de una secuencia de sentencias mientras la condicio\u0301n sea verdadera. Sintaxis: 1 2 3 while ( condicion_a_cumplir ) { secuencia_de_instrucciones ; } Sem\u00e1ntica: Mientras la condicion_a_cumplir devuelva un valor verdadero (distinto de cero), se ejecutar\u00e1 repetidamente la secuencia de instrucciones , evaluando nuevamente la condici\u00f3n en cada iteraci\u00f3n. Si la condicion_a_cumplir devuelve un valor falso (igual a cero), finalizara la ejecuci\u00f3n de la sentencia while . La condici\u00f3n_a_cumplir debe ir entre par\u00e9ntesis. La condici\u00f3n se sit\u00faa al inicio, por lo que es posible que si inicialmente no se cumple, no se llegue a ejecutar nunca la secuencia_de_instrucciones . Ejemplo: 1 2 3 4 5 int cargaBateria = 0 ; while ( cargaBateria < 100 ) { cargaBateria = cargaBateria + 1 ; } Otro ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 int caramelos = 0 ; char res ; printf ( \"\u00bfQuieres un caramelo (s/n)?:\" ); scanf ( \"%c\" , & res ); while ( res == 'S' || res == 's' ) { caramelos = caramelos + 1 ; printf ( \"\u00bfQuieres otro caramelo? (s/n):\" ); scanf ( \" \\n %c\" , & res ); //\"\\n\" es para que res ignore el intro } // fin de la sentencia while printf ( \"Te he dado %d caramelos \\n \" , caramelos );","title":"Bucle while"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#bucle-do-while","text":"Permite repetir una o ma\u0301s veces la ejecucio\u0301n de una secuencia de sentencias mientras la condicio\u0301n sea verdadera. Sintaxis : 1 2 3 do { secuencia_de_instrucciones ; } while ( condici\u00f3n_a_cumplir ); Sem\u00e1ntica : En primer lugar se ejecuta la secuencia_de_instrucciones . Despu\u00e9s se eval\u00faa la condicion_a_cumplir . Si el resultado es verdadero se repite la ejecuci\u00f3n de secuencia de instrucciones . Si es falso, finaliza la ejecuci\u00f3n. Ejemplo: 1 2 3 4 5 6 7 8 9 10 int num ; int suma = 0 ; do { printf ( \"Introduzca un n\u00famero: (0 para finalizar)\" ); scanf ( \"%d\" , & num ); suma += num ; } while ( num != 0 ); printf ( \"La suma de todos los n\u00fameros introducidos es: %d \\n \" , suma ); Al situarse la condici\u00f3n se sit\u00faa al final, la secuencia_de_instrucciones se ejecuta al menos una vez.","title":"Bucle do-while"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#bucle-for","text":"Permite repetir un nu\u0301mero determinado de veces la ejecucio\u0301n de una secuencia de instrucciones. El nu\u0301mero de iteraciones del bucle es controlado por una variable usada como un contador . Es un bucle determinado porque conocemos de antemano el n\u00famero de iteraciones. Sintaxis : 1 2 3 for ( inicializacio \u0301 n_contador ; condicion ; modificaci\u00f3n_contador ){ secuencia_de_instrucciones ; } Sem\u00e1ntica : Primera vez que se ejecuta: Se ejecuta la inicializaci\u00f3n_contador Se eval\u00faa la condici\u00f3n . Si el resultado es verdadero se ejecuta la secuencia_de_instrucciones . Si es falso, finaliza. Segunda vez y sucesivas ejecuciones: Se ejecuta la modificaci\u00f3n_contador Se eval\u00faa la condici\u00f3n . Si el resultado es verdadero se ejecuta la secuencia_de_instrucciones . Si es falso, finaliza. Ejemplos: 1 2 3 for ( i = 0 ; i < 10 ; i ++ ) { printf ( \"Esta es la iteraci\u00f3n %d\" , i ); } Ejemplo con un incremento de 2 en 2: 1 2 3 4 5 6 7 int i ; for ( i = 6 ; i <= 20 ; i += 2 ) { // incremento de 2 en 2 if ( i % 3 == 0 ) // m\u00faltiplos de 3 printf ( \"%d \" , i ); } // Imprime 6 12 18 Cualquier bucle for se puede escribir con un bucle while : 1 2 3 for ( expresio \u0301 n_1 ; expresio \u0301 n_2 ; expresio \u0301 n_3 ) { secuencia de sentencias ; } Es equivalente a: 1 2 3 4 5 6 expresio \u0301 n_1 ; while ( expresio \u0301 n_2 ) { secuencia de sentencias ; expresio \u0301 n_3 ; } El equivalente usando while del ejemplo anterior es: 1 2 3 4 5 6 i = 0 ; while ( i < 10 ) { printf ( \"Esta es la iteraci\u00f3n %d\" , i ); i ++ ; } Pero hay que utilizar siempre el bucle adecuado. Para saber qu\u00e9 tipo de bucle hay que usar: Si el cuerpo del bucle (secuencia de instrucciones) se tiene que ejecutar al menos una vez: do-while Si no (0 \u00f3 m\u00e1s veces): Si no sabemos de antemano el n\u00famero de iteraciones: while Si sabemos el n\u00famero de iteraciones (usamos un contador): for","title":"Bucle for"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#variables-en-los-bucles","text":"En los bucles se suelen utilizar variables para unas tareas especi\u0301ficas: Contadores : son variables destinadas a contener un valor que se ira\u0301 incrementando o decrementando en una cantidad fija. Se suelen utilizar para el control de procesos repetitivos. Acumuladores : Son variables destinadas a contener distintas cantidades provenientes de los resultados obtenidos en operaciones aritme\u0301ticas previamente analizadas de manera sucesiva, lo que nos permitira\u0301 obtener el total acumulado de dichas cantidades. A diferencia de los contadores, no controlan los procesos repetitivos. Su inicializacio\u0301n depende de en que\u0301 operacio\u0301n matema\u0301tica van a ser utilizados. Interruptores (switches): tambie\u0301n denominados conmutadores o indicadores, son variables que pueden tomar dos u\u0301nicos valores considerados como lo\u0301gicos y opuestos entre si\u0301 a lo largo de todo el programa (0 o\u0301 1, 1 o\u0301 -1, Verdadero o Falso, on/off, etc.). Su objetivo es recordar en un determinado lugar del programa un suceso determinado o hacer que dos acciones diferentes se ejecuten alternativamente en un proceso repetitivo. Tambie\u0301n deben ser inicializados. No se debe abusar de su utilizacio\u0301n cuando no sea necesario. Ejercicio: Implementa un programa que lea nu\u0301meros que el usuario introduzca por teclado hasta que introduzca el cero. El programa tiene que imprimir la suma de todos los nu\u0301meros introducidos y el n\u00famero de n\u00fameros que se han introducido.","title":"Variables en los bucles"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#validacion-de-datos","text":"Cuando estamos desarrollando un programa es frecuente que nos pidan por teclado un n\u00famero que est\u00e9 en un rango determinado (por ejemplo entre 1 y 10) o que nos pidan unos determinados caracteres (por ejemplo 's' o 'n'). Normalmente en estos casos, si el dato introducido no es v\u00e1lido, se tiene que volver a solicitar un nuevo dato hasta que sea correcto. Para ello utilizamos bucles que pidan repetidamente el dato mientras no sea correcto. Por ejemplo, nos piden un n\u00famero par. Si no es par, se tiene que volver a pedir: 1 2 3 4 5 6 int num ; do { printf ( \"Introduce un n\u00famero par: \" ); scanf ( \"%d\" , & num ); } while ( num % 2 != 0 ); //repetir mientras no sea par","title":"Validaci\u00f3n de datos"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#bucles-anidados","text":"Se puede utilizar un bucle dentro de otro. Para cada iteraci\u00f3n del bucle exterior, se ejecuta completo el bucle interior. Ejemplo, imprimimos las posiciones de una matriz: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #define TAM 10 int main () { int fil , col ; for ( fil = 0 ; fil < TAM ; fil ++ ){ for ( col = 0 ; col < TAM ; col ++ ) { printf ( \"%4d-%d\" , fil , col ); //%4d a\u00f1ade 4 espacios delante del entero } printf ( \" \\n \" ); } return 0 ; }","title":"Bucles anidados"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#ejemplos-de-bucles-en-c","text":"Ejemplo con bucle while . Utilizamos el bucle indeterminado while porque no sabemos de antemano el n\u00famero de iteraciones: el bucle terminar\u00e1 cuando el usuario introduzca un cero. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* Obtener la media de una lista de n\u00fameros. La lista termina cuando se introduce el n\u00famero cero */ void main () { int total = 0 ; float num = 0 , media = 0 ; printf ( \u201c Dime un n\u00famero : \u201d ); scanf ( \u201c % f \u201d , & num ); while ( num != 0 ) { media = media + num ; total ++ ; printf ( \u201c Dime otro n\u00famero : \u201d ); scanf ( \u201c % f \u201d , & num ); } if ( total != 0 ) printf ( \u201c La media es % f . \\ n \u201d , media / total ); else printf ( \u201c No hay media . \\ n \u201d ); } Ejemplo con bucle do-while 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Calcular el n\u00famero m\u00e1s grande de una lista de n\u00fameros mayores que cero. La entrada de n\u00fameros terminar\u00e1 cuando se introduzca un n\u00famero negativo o cero. */ void main () { int num , max = 0 ; do { printf ( \u201c Dame un n\u00famero : \u201d ); scanf ( \u201c % d \u201d , & num ); if ( num > max ) max = num ; } while ( num > 0 ); if ( max != 0 ) printf ( \u201c El n\u00famero m\u00e1s grande es % d . \\ n \u201d , max ); else printf ( \u201c No hay m\u00e1ximo . \\ n \u201d ); } Ejemplo con bucle for y do-while 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #define NUM_PARCIALES 5 // Nu\u0301mero de exa\u0301menes parciales int main () { float nota_parcial , nota_final ; float suma ; int i ; suma = 0 ; // Introducir las notas de todos los parciales y sumarlas (so\u0301lo cuando el dato introducido sea correcto) for ( i = 1 ; i <= NUM_PARCIALES ; i ++ ) { do { printf ( \"Dime tu nota del parcial %d \\n \" , i ); scanf ( \"%f\" , & nota_parcial ); } while ( nota_parcial < 0.0 || nota_parcial > 10.0 ); suma = suma + nota_parcial ; } // Calcular la nota media e imprimirla por pantalla nota_final = suma / NUM_PARCIALES ; printf ( \"Tu nota final es: %.2f \\n \" , nota_final ); //%.2f imprime s\u00f3lo dos decimales return 0 ; } Factorial de un n\u00famero: 1 2 3 4 5 6 7 8 9 10 11 12 int n ; int res = 1 ; printf ( \"Introduce un n\u00famero n: \" ); scanf ( \"%d\" , & n ); do { res *= n ; n -- ; } while ( n > 1 ); printf ( \"El factorial de %d es %d \\n \" , n , res ); Ejercicio: Haz el ejercicio anterior (factorial de un n\u00famero) utilizando un bucle for","title":"Ejemplos de bucles en C"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#5-traza-de-ejecucion-de-un-programa","text":"Se utiliza para estudiar la secuencia de estados por los que pasa un programa, es decir, el valor que van tomando las variables instrucci\u00f3n a instrucci\u00f3n. Las variables almacenan el estado de un programa y mediante los pasos de ejecuci\u00f3n se va modificando su estado. Se utilizan principalmente para depurar un programa (corregir errores de ejecucio\u0301n) o para comprender que\u0301 hace un programa o parte del mismo. La traza se lleva a cabo normalmente mediante la ejecucio\u0301n manual de forma secuencial de las sentencias que componen el programa. Tambi\u00e9n existen herramientas de depuraci\u00f3n que nos permiten ejecutar paso a paso, o parar la ejecuci\u00f3n en un punto concreto para observar el estado del programa. Por ejemplo el depurador gdb . Ejemplo: Realiza una traza de ejecici\u00f3n del siguiente programa y explica lo que hace: 1 2 3 4 5 6 7 8 void main () { int i , res ; res = 0 ; for ( i = 1 ; i <= 10 ; i ++ ) { res += i * i ; } printf ( \"%d \\n \" , res ); } Para realizar la traza tenemos que hacer una tabla de este estilo: i i * i res 1 1 1 2 4 5 3 9 14 4 16 30 5 25 55 6 36 91 7 49 140 8 64 204 9 81 285 10 100 385 \u00bfQu\u00e9 hace el c\u00f3digo? Veamos otro ejemplo: Todos los di\u0301as paso por una libreri\u0301a y me compro una serie de libros siguiendo este patro\u0301n di\u0301a 1 \u2192 1 libro di\u0301a 2 \u2192 2 libros di\u0301a N \u2192 N libros Si tengo una estanteri\u0301a donde caben M libros \u00bf que\u0301 di\u0301a llegare\u0301 a casa y no podre\u0301 poner todos los libros que he comprado ? Programa: 1 2 3 4 5 6 7 8 int capacidadMaxima = 15 , capacidadActual = 0 , dia = 0 ; do { dia = dia + 1 ; capacidadActual = capacidadActual + dia ; } while ( capacidadActual <= capacidadMaxima ); printf ( \"Rebasamos la capacidad el di\u0301a %d\" , dia ); Traza: Iteraci\u00f3n dia capacidadActual 1 1 0 + 1 = 1 2 2 1 + 2 = 3 3 3 3 + 3 = 6 4 4 6 + 4 = 10 5 5 10 + 5 = 15 6 6 15 + 6 = 21","title":"5. Traza de ejecuci\u00f3n de un programa"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#ejercicios-resueltos","text":"","title":"Ejercicios resueltos"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#ejercicios-propuestos","text":"Escribe un programa que muestre todos los multiplos de un nu\u0301mero dado en el rango [0, 100] \u2013 Pedir el nu\u0301mero por teclado Escribe un programa que muestre todos los divisores de un nu\u0301mero dado \u2013 Pedir el nu\u0301mero por consola \u2013 Uso del operando mo\u0301dulo % Hacer las trazas de los ejercicios 1 (valor de entrada 40) y 2 (valor de entrada 16) Escribir un programa que pida dos n\u00fameros y muestre un men\u00fa como este: 1 2 3 4 5 6 1. Suma 2. Resta 3. Multiplicaci\u00f3n 4. Divisi\u00f3n 5. M\u00f3dulo 6. Salir Tras mostrar el men\u00fa, el programa debe leer un n\u00famero del 1 al 6 y realizar la opci\u00f3n indicada con los dos n\u00fameros. Tras realizar las operaciones e indicar el resultado, el programa volver\u00e1 a mostrar el men\u00fa y as\u00ed sucesivamente. Finalizar\u00e1 cuando se introduzca la opci\u00f3n 6.","title":"Ejercicios propuestos"},{"location":"Teoria/tema03-sentencias-de-control/tema03-sentencias-de-control.html#bibliografia","text":"Cap\u00edtulos 5 y 6 de \"Programaci\u00f3n en C, metodolog\u00eda, algoritmos y estructuras de datos\", Luis Joyanes, Ignacio Zahonero Cap\u00edtulos 5.1 a 5.7 de \"Fundamentos de Programaci\u00f3n\", Jes\u00fas Carretero y otros Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares Puig","title":"Bibliograf\u00eda"},{"location":"Teoria/tema04-descomposicion-modular/tema04-descomposicion-modular.html","text":"Tema 4: Descomposici\u00f3n modular \u00b6 1. Descomposici\u00f3n modular \u00b6 Ya hemos visto que en C se utilizan funciones de biblioteca (como printf o scanf ). Tambi\u00e9n hemos utilizado la funci\u00f3n main , que es la funci\u00f3n principal del programa. En este tema vamos a aprender a definir nuestras propias funciones que realicen determinadas tareas. El uso de funciones definidas por el programador permite dividir un programa grande en un cierto n\u00famero de componentes m\u00e1s peque\u00f1as, cada una de las cuales con un prop\u00f3sito \u00fanico e identificable. Por tanto, un programa en C se puede modularizar en subproblemas (programar de forma estructurada) mediante el uso adecuado de funciones. Podemos decir que la ejecuci\u00f3n de cualquier programa en C empieza ejecutando la funci\u00f3n main instrucci\u00f3n a instrucci\u00f3n desde la primera a la \u00faltima. Si alguna instrucci\u00f3n hace una llamada a una funci\u00f3n (la invoca), el programa deja en espera el punto de ejecuci\u00f3n por donde iba y pasa a ejecutar la funci\u00f3n, de la misma forma. Cuando termina, vuelve a seguir por la funci\u00f3n principal por donde la hab\u00eda dejado. Cada funci\u00f3n puede llamar a otras funciones, e incluso a s\u00ed misma (recursi\u00f3n). Una de las habilidades fundamentales del pensamiento computacional es la abstracci\u00f3n : definir subproblemas que creen nueva sem\u00e1ntica, dividir un problema grande en peque\u00f1os problemas (funciones). Esto hace el c\u00f3digo m\u00e1s f\u00e1cil de entender, probar, modificar, compartir y reutilizar. Ventajas de modularizar un programa: Generalizaci\u00f3n : si un programa tiene instrucciones repetidas en distintas partes, esas instrucciones repetidas se pueden agrupar en una sola funci\u00f3n, a la que acceder cuando sea necesario. Claridad l\u00f3gica : programas m\u00e1s f\u00e1ciles de escribir y depurar. La estructura l\u00f3gica es m\u00e1s f\u00e1cil de entender. Tambi\u00e9n permite al programador construir bibliotecas de funciones de uso frecuente . Evita la reescritura del c\u00f3digo. Favorece la portabilidad . Facilita el disen\u0303o descendente y la programacio\u0301n estructurada . Reduce el tiempo de programacio\u0301n: reutilizaci\u00f3n y divisi\u00f3n de tareas Disminuye el taman\u0303o total del programa Facilita la deteccio\u0301n y correccio\u0301n de errores Facilita el mantenimiento del programa Cuando empezamos a abordar un problema, lo mejor es ir dividie\u0301ndolo en subproblemas. Por ejemplo: guiado de un robot desde la clase hasta la puerta de salida Subproblemas: Encontrar la puerta del aula y salir Guiado por el pasillo hasta encontrar las escaleras Bajar las escaleras Encontrar la puerta de salida y salir Cada subproblema puede ser tratado por separado: analizado, dividido a su vez en subproblemas, probado de manera independiente, y tenemos la posibilidad de reutilizar co\u0301digo ya hecho 2. Funciones \u00b6 Algunos lenguajes de programaci\u00f3n tienen dos tipos de herramientas para modularizar: procedimientos y funciones. En el lenguaje C s\u00f3lo existen las funciones . Un programa en C est\u00e1 estructurado en funciones. De hecho, main() es una funci\u00f3n, es la funci\u00f3n principal. Una funci\u00f3n es una unidad de c\u00f3digo dise\u00f1ada para realizar una tarea determinada. Las funciones en programaci\u00f3n son similares a las funciones matem\u00e1ticas, pudiendo tener argumentos o par\u00e1metros. Ejemplo: Definici\u00f3n de una funci\u00f3n en matem\u00e1ticas: f(x) = x + 5; f es el nombre de la funci\u00f3n que tiene un par\u00e1metro formal: x. La funci\u00f3n f, una vez definida, puede usarse o llamarse en algunas expresiones: y = f(4) + 1; Para descubrir el valor de f(4) hay que sustituir el par\u00e1metro formal x por el valor 4 (argumento actual), f(4) = 4+5 = 9, de donde obtenemos que y = 9 + 1 = 10. Se dice que la funci\u00f3n f devuelve el valor 9. Las funciones en programaci\u00f3n son m\u00e1s generales que las funciones matem\u00e1ticas: pueden tener par\u00e1metros de cualquier tipo y pueden incorporar estructuras de control. Funciones como cajas negras Podemos plantearnos las funciones como cajas negras, definidas exclusivamente por los datos de entrada (informaci\u00f3n que hay que suministrarles) y los datos de salida. Lo que suceda dentro de la caja negra no tiene por qu\u00e9 saberse, s\u00f3lo importa a los que han dise\u00f1ado la funci\u00f3n. El usuario debe saber c\u00f3mo funciona y c\u00f3mo se usa, pero no c\u00f3mo est\u00e1 implementada. Elementos de las funciones Las funciones en programaci\u00f3n tambi\u00e9n tienen todos los elementos vistos en las funciones matem\u00e1ticas: Definici\u00f3n : Donde se define su nombre, los par\u00e1metropar\u00e1metros que va a tener (nombre, n\u00famero y tipo) y lo que la funci\u00f3n debe hacer o c\u00f3mo calcular el valor que devuelve la funci\u00f3n. Tambi\u00e9n se define el tipo del valor que se devuelve (tipo de la funci\u00f3n). Par\u00e1metros formales : Son los nombres de los par\u00e1metros que aparecen en la definici\u00f3n de una funci\u00f3n. Llamada a una funci\u00f3n : Es la instrucci\u00f3n donde se invoca a la funci\u00f3n. Par\u00e1metros actuales : Son los par\u00e1metros utilizados en la llamada. Ejemplo: implementamos en C la funci\u00f3n matem\u00e1tica f(x)=x+5: 1 2 3 4 5 6 7 8 /*int f: Tipo del valor que devuelve la funci\u00f3n (tipo de la funci\u00f3n). Debe coincidir con el tipo de la expresi\u00f3n que hay despu\u00e9s de la palabra return f: nombre de la funci\u00f3n (int x): par\u00e1metro formal y su tipo*/ int f ( int x ) { return x + 5 ; /*valor que devuelve la funci\u00f3n*/ } En un programa definimos la funci\u00f3n una vez y la utilizamos (llamamos) siempre que sea necesario. La llamada a una funci\u00f3n puede utilizarse en cualquier lugar en el que pueda utilizarse una expresi\u00f3n del tipo de la funci\u00f3n. Ejemplo: \u00bfQu\u00e9 salida produce el siguiente programa para un determinado valor de entrada ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <stdio.h> int f ( int x ); // Prototipo o declaraci\u00f3n de la funci\u00f3n f void main () { int num1 , num2 num3 ; printf ( \" \\n - Introduzca un n\u00famero: \" ); scanf ( \"%d\" , & num1 ); num2 = f ( 5 ); num2 = f ( num1 ) + num1 - num2 ; num3 = f ( num2 + 1 ); printf ( \" \\n - Valores: %d, %d y %d.\" , num1 , num2 , f ( num3 )); return 0 ; } int f ( int x ) { // Definici\u00f3n de la funci\u00f3n f return x + 5 ; } Cuando se llama a la funci\u00f3n f(5) , el par\u00e1metro formal x toma el valor de 5 que es el par\u00e1metro actual . Sintaxis de una funci\u00f3n en C \u00b6 1 2 3 < tipo_devuelto > < nombre_funcion > ( < par\u00e1metros formales > ) { < cuerpo de la funci\u00f3n > } El <tipo_devuelto> indica el tipo del valor que devuelve la funci\u00f3n. En el caso del ejemplo de la funci\u00f3n m\u00ednimo , el tipo de retorno es int . Es posible que la funci\u00f3n no devuelva nada, en ese caso el tipo de devuelto es void . El <nombre_funci\u00f3n> , en nuestro ejemplo minimo . Debe ser indicativo de la funcionalidad desarrollada. Usaremos la misma norma que para las variables <par\u00e1metros formales> : es una lista con la declaraci\u00f3n de todos los par\u00e1metros formales (tipo y nombre), separados por comas. Puede estar vac\u00eda. Los par\u00e1metros formales permiten que se transfiera informaci\u00f3n desde el punto del programa en donde se llama a la funci\u00f3n a \u00e9sta. Cada par\u00e1metro formal debe ser del mismo tipo que el dato que recibe desde el punto de llamada. El <cuerpo de la funci\u00f3n> contiene las instrucciones que realizan la tarea concreta de la funci\u00f3n. Es la implementaci\u00f3n de la funci\u00f3n. Pueden declararse variables locales a la funci\u00f3n. Puede contener la sentencia return para devolver el valor que corresponda. Formato: return <expresi\u00f3n>; Esta sentencia puede aparecer varias veces, aunque es deseable que s\u00f3lo aparezca una vez al final. En cuanto se ejecute una sentencia return la funci\u00f3n termina, devolviendo el valor que haya en esa sentencia return . El valor devuelto debe ser del tipo especificado tipo_devuelto . Prototipo o declaraci\u00f3n de una funci\u00f3n Sintaxis: 1 < tipo_devuelto > < nombre_f > ( < tipo_args_formales > ); <tipo_args_formales> : Es una lista con la declaraci\u00f3n de todos los par\u00e1metros formales, separados por comas. Pueden ponerse s\u00f3lo los tipos (sin el nombre de los par\u00e1metros). El resto es como la sintaxis de definici\u00f3n de una funci\u00f3n, pero sin el cuerpo. El prototipo, tambi\u00e9n llamado declaraci\u00f3n de una funci\u00f3n o cabecera ( header ) sirve para especificar o declarar que existe una funci\u00f3n con cierto n\u00famero y tipo de par\u00e1metros y que devuelve un determinado tipo de datos. El prototipo no define el proceso que se realiza, el cual se especifica en la definici\u00f3n de la funci\u00f3n. El prototipo de una funci\u00f3n debe ser coherente con la cabecera de su definici\u00f3n. Ejemplo de prototipos de funciones: 1 2 3 4 int sumaValores ( int valorA , int valorB ); void muestraResultados ( int ); bool estaDentroLimites ( int x , int y ); char preguntaUsuario (); Variables locales a una funci\u00f3n Las variables locales son aquellas que se declaran dentro de una funci\u00f3n. Las variables de sus par\u00e1metros formales son locales a la funci\u00f3n: S\u00f3lo tienen sentido y s\u00f3lo pueden usarse dentro de esa funci\u00f3n: su \u00e1mbito es local a la funci\u00f3n Su nombre es totalmente independiente de las variables locales de otras funciones, incluyendo la funci\u00f3n main() . 1 2 3 4 5 6 7 8 int f ( int x ){ int y = 3 ; return x + y ; } void g ( char x ){ printf ( \"%c\" , x ); } Si nos fijamos en las variables x de las funciones anteriores, vemos que se llaman igual pero son variables distintas: tienen distinto \u00e1mbito (visibilidad), distinto significado, distinta utilidad... Otros ejemplos: 1 2 3 4 5 6 7 8 9 10 11 // Esta funci\u00f3n recibe dos par\u00e1metros y devuelve el menor de ellos int minimo ( int a , int b ) { int menor ; // el menor de dos nu\u0301meros menor = a ; if ( b < menor ) menor = b ; return ( menor ); } 1 2 3 4 5 // Esta funci\u00f3n no recibe par\u00e1metros e imprime la cadena de texto \"hola mundo\" void holamundo () { printf ( \"Hola mundo \\n \" ); } \u00c1mbito de las variables \u00b6 Variables locales : Son variables que s\u00f3lo son visibles y accesibles dentro del \u00e1mbito donde se han creado Si declaramos una variable dentro del cuerpo de una funcio\u0301n, es accesible en toda la funcio\u0301n. En cuanto la funci\u00f3n termine su ejecuci\u00f3n, esa variable desaparece. Si esta declaracio\u0301n se realiza dentro de un bloque de co\u0301digo (dentro de un if, switch, for, while ...), s\u00f3lo es accesible dentro del bloque de co\u0301digo 1 2 3 4 5 6 7 8 9 10 int main () { int a = 1 ; if ( a > 0 ) { int b = 8 ; // variable local al if } printf ( \"El valor de la variable es: %d\" , b ); //Error, variable no definida return 0 ; } Variables globales (NO SE PERMITEN EN ESTA ASIGNATURA): Son variables que se declaran fuera de todas las funciones. Pueden ser utilizadas por todas las funciones que haya despu\u00e9s de su declaraci\u00f3n. Normalmente, estas variables se declaran antes que las funciones, por lo que su \u00e1mbito o visibilidad es global. Su uso est\u00e1 desaconsejado, especialmente en programadores noveles, porque complica la comprensi\u00f3n de los programas y pueden dar lugar a efectos laterales err\u00f3neos que suelen ser muy dif\u00edcil de localizar. D\u00f3nde definir las funciones en C \u00b6 En un programa en C las funciones pueden situarse en dos sitios distintos: Antes de la funci\u00f3n main() : En este caso se definir\u00e1 la funci\u00f3n main() al final. Las funciones se ordenar\u00e1n teniendo en cuenta que para utilizar una funci\u00f3n \u00e9sta debe estar definida previamente. 2. Despu\u00e9s de la funci\u00f3n main() : En este caso lo habitual es definir la funci\u00f3n main() al principio. Antes de la funci\u00f3n main() se incluir\u00e1n los prototipos de todas las funciones. Esto es imprescindible, ya que, al estar definidas las funciones al final, el compilador no reconoce las llamadas a las mismas que puedan haberse realizado. El orden de las funciones ya no es importante, ya que todas podr\u00e1n utilizar a todas las dem\u00e1s, puesto que est\u00e1n todos los prototipos declarados previamente. Esta segunda forma es m\u00e1s laboriosa pero evita errores en el orden de las funciones. Adem\u00e1s, el tener todos los prototipos juntos simplifica localizar las caracter\u00edsticas de cada funci\u00f3n. Paso de par\u00e1metros por valor y por referencia \u00b6 Paso de par\u00e1metros por valor Cuando se produce la llamada a una funci\u00f3n, se transfiere la ejecuci\u00f3n del programa al cuerpo de la funci\u00f3n. Se crea un nuevo \u00e1mbito local donde la funci\u00f3n se ejecuta. Pasos: Se declaran las variables de los par\u00e1metros formales. Se copia el valor de los par\u00e1metros actuales en las variables de los par\u00e1metros formales. Esta copia se hace por orden: el primer par\u00e1metro actual en el primer par\u00e1metro formal, el segundo en el segundo... Esta copia no se hace por el nombre de los respectivos par\u00e1metros formales y actuales. Se copia el valor: si el argumento actual es una variable, se copia su valor en el correspondiente argumento formal, pero ambos par\u00e1metros actuales y formales son variables distintas. Se declaran las variables locales a la funci\u00f3n. Se ejecuta el c\u00f3digo de la funci\u00f3n en ese \u00e1mbito local. Al terminar la funci\u00f3n las variables LOCALES son destruidas, es decir, el \u00e1mbito donde la funci\u00f3n se ejecut\u00f3 desaparece . Si los par\u00e1metros formales se modifican dentro de la funci\u00f3n, no se modificar\u00e1n los argumentos actuales, puesto que son variables distintas. Ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /*\u00bfQu\u00e9 salida produce el siguiente programa para distintas entradas?*/ #include <stdio.h> float func ( float x , float y ); // prototipo void main (){ float x , y , z ; printf ( \" \\n - Introduzca un n\u00famero: \" ); scanf ( \"%f\" , & x ); y = x + x ; z = func ( y , x ); printf ( \" \\n - Valores: %.1f, %.1f y %.1f.\" , x , y , z ); return 0 ; } float func ( float x , float y ){ x = x + 1 ; y = y + 2 ; return x - y ; } Ejemplo de funciones con enumerados: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 typedef enum { Avance , Retroceso } TMotor ; TMotor leerPalanca (); void modificaEstadoMotor ( TMotor ); int main () { TMotor estadoMotor ; estadoMotor = leerPalanca (); modificaEstadoMotor ( estadoMotor ); return 0 ; } TMotor leerPalanca () { TMotor direccionMotor ; do { printf ( \"\u00bfEn qu\u00e9 posici\u00f3n est\u00e1 la palanca del cortac\u00e9sped? 0-Avance 1-Restroceso \\n \" ); scanf ( \"%d\" , & direccionMotor ); } while ( direccionMotor != Avance && direccionMotor != Retroceso ); return direccionMotor ; } void modificaEstadoMotor ( TMotor estado ) { switch ( estado ) { case Avance : //Llamada a funci\u00f3n para modificar el motor hacia adelante break ; case Retroceso : //Llamada a funci\u00f3n para modificar el motor hacia atr\u00e1s break ; } } Paso de par\u00e1metros por referencia En el paso de par\u00e1metros por valor , si los argumentos formales se modifican, los argumentos actuales no cambian. Sin embargo, a veces resulta muy \u00fatil poder modificar en una funci\u00f3n los argumentos actuales. Esto se consigue usando el paso de argumentos por referencia : Esto es otra forma de conseguir que una funci\u00f3n devuelva valores (aparte de la instrucci\u00f3n return ). Adem\u00e1s, de esta forma una funci\u00f3n puede devolver tantos valores como se deseen. En lenguaje C, por defecto todos los pasos de par\u00e1metros son por valor. Se llama paso de par\u00e1metros por referencia a una t\u00e9cnica que permite a una funci\u00f3n modificar variables utilizadas como argumentos actuales. La funcio\u0301n recibe la referencia a la posicio\u0301n de memoria donde se encuentra el valor a utilizar. Este para\u0301metro debe ser una variable, la cual puede o no contener un valor inicial. Las modificaciones realizadas sobre el para\u0301metro dentro de la funcio\u0301n se trasladan a la variable actual ya que se realizan sobre su zona de memoria. C\u00f3mo pasar argumentos por referencia: En la llamada a la funci\u00f3n: usar el operador de direcci\u00f3n & (ampersand) delante del argumento en la llamada. El operador & indica que dicha variable puede verse modificada por la funci\u00f3n. En la definici\u00f3n de la funci\u00f3n: Usar el operador de indirecci\u00f3n * (asterisco) delante del argumento formal correspondiente. Se usar\u00e1 el operador * cada vez que la variable del argumento formal sea utilizada, tanto en la declaraci\u00f3n de la variable (entre los par\u00e9ntesis de la funci\u00f3n) como en el cuerpo de la funci\u00f3n. Ejemplo 1: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void swap ( int * , int * ); // prototipo de la funci\u00f3n swap int main (){ int x = 1 , y = 2 , z = 3 ; swap ( & x , & y ); swap ( & y , & z ); printf ( \"x: %d, y: %d, z:%d \\n \" , x , y , z ); return 0 ; } /* Intercambio de valores entre dos variables */ void swap ( int * x , int * y ){ // definici\u00f3n de la funci\u00f3n swap int aux = * x ; * x = * y ; * y = aux ; } Ejemplo 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void dividirSeguro ( int , int , int * , bool * ); int main () { int valor1 , valor2 , result ; bool error ; printf ( \"Introduce dos numeros: \\n \" ); scanf ( \"%d\" , & valor1 ); scanf ( \"%d\" , & valor2 ); dividirSeguro ( valor1 , valor2 , & result , & error ); if ( error ) printf ( \"Error: Division por cero \\n \" ); else printf ( \"%d/%d = %d \\n \" , valor1 , valor2 , result ); return 0 ; } /* Divisi\u00f3n segura */ void dividirSeguro ( int dividendo , int divisor , int * result , bool * error ) { * error = false ; if ( divisor != 0 ) * result = dividendo / divisor ; else * error = true ; } Ejemplo 3: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int elevarAlCuadrado ( int entrada ); // prototipo int main () { int valor = 7 , resultado ; resultado = elevarAlCuadrado ( valor ); printf ( \"El resultado es: %d \\n \" , resultado ); return 0 ; } int elevarAlCuadrado ( int entrada ) { // definici\u00f3n return entrada * entrada ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Ejemplo 4 : // Prototipo o declaraci\u00f3n de la funci\u00f3n int potencia ( int base , int exponente ); // int potencia(int, int); int main () { int res ; res = potencia ( 2 , 4 ); // Llamada a la funci\u00f3n return 0 ; } // Definici\u00f3n de la funci\u00f3n int potencia ( int base , int exponente ) { int resultado , i ; resultado = base ; for ( i = 0 ; i < exponente ; i ++ ) resultado *= base ; return resultado ; } Ejemplo 5: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Prototipos int pedirDato (); void pedirXY ( int * , int * ); int main () { int numero , posX , posY ; pedirXY ( & posX , & posY ); printf ( \"X: %d, Y: %d \\n \" , posX , posY ); return 0 ; } // Definiciones de funciones int pedirDato () { int dato ; do { printf ( \"Introduce un num entre 1 y 8: \" ); scanf ( \"%d\" , & dato ); } while ( dato < 1 || dato > 8 ); return dato ; } void pedirXY ( int * x , int * y ) { * x = pedirDato (); * y = pedirDato (); } Por lo general, usaremos funciones con paso de par\u00e1metros por valor cuando s\u00f3lo queramos devolver un resultado , y \u00e9ste se devuelve con return . Y cuando se necesite devolver m\u00e1s de un resultado , usaremos funciones con paso de par\u00e1metros por referencia , siendo esta funci\u00f3n tipo void . Funciones en Python En Python, la definici\u00f3n de funciones se realiza mediante la instrucci\u00f3n def m\u00e1s un nombre de funci\u00f3n descriptivo seguido de par\u00e9ntesis de apertura y cierre y : 1 2 def mi_funcion (): print \"Hola Mundo\" Cuando una funci\u00f3n, haga un retorno de datos, \u00e9stos, pueden ser asignados a una variable: 1 2 3 4 5 def funcion (): return \"Hola Mundo\" frase = funcion () print frase En Python todos los par\u00e1metros se pasan por valor. El paso por referencia es la manera en que los lenguajes (como C) pueden devolver m\u00e1s de un valor en una misma funci\u00f3n. En cambio, Python permite devolver varios datos utilizando tuplas o listas. Por ejemplo: 1 2 3 4 5 6 7 a = 1 b = 2 c = 3 def f (): return 4 , 5 , 6 a , b , c = f () # Ahora \"a\" es 4, \"b\" es 5 y \"c\" es 6. Estructura de un programa en C \u00b6 Comentarios: En primer lugar se deben incluir unos comentarios indicando qu\u00e9 hace el programa, requisitos, autor, fecha... Inclusi\u00f3n de las Bibliotecas: Las del sistema (como stdio.h, math.h, etc.) van entre \u00e1ngulos: <...>. Las creadas por el programador van entre comillas dobles: \"...\". Declaraciones globales: variables y constantes globales (con const ), constantes simb\u00f3licas del preprocesador (con #define ) y definici\u00f3n de tipos de datos (con typedef ). Como norma general, NO DEBEN USARSE VARIABLES GLOBALES . Prototipos o declaraci\u00f3n de las funciones. Implementaci\u00f3n de las funciones, incluida main() , que puede ponerse la primera o la \u00faltima. Las dem\u00e1s funciones deber\u00edan ponerse en el mismo orden que sus prototipos para que sea f\u00e1cil localizarlas. Antes de cada funci\u00f3n debe incluirse un comentario indicando qu\u00e9 hace la funci\u00f3n, significado de sus argumentos, etc. Si se escriben antes las funciones que son llamadas por otras, poniendo main() al final, los prototipos no son estrictamente necesarios. La comunicacio\u0301n entre funciones debe realizarse a trave\u0301s de para\u0301metros, y no de variables globales Bibliotecas del lenguaje C \u00b6 La mayori\u0301a de lenguajes de programacio\u0301n proporcionan una coleccio\u0301n de procedimientos y funciones de uso comu\u0301n (bibliotecas o libreri\u0301as). En lenguaje C, para hacer uso de los mo\u0301dulos incluidos en una biblioteca se utiliza la directiva del compilador #include . Existe una gran variedad de bibliotecas disponibles: - Funciones matema\u0301ticas - Manejo de caracteres y de cadenas de caracteres - Manejo de entrada y salida de datos - Manejo del tiempo (fecha, hora, ...) Algunas funciones predefinidas en C Ejercicios \u00b6 Define un programa que pida un n\u00famero impar y dibuje una T de ese tama\u00f1o. Define las funciones que consideres necesarias. Define un programa que permita leer y validar dos datos de entrada de manera que en uno de ellos el valor sea mayor que 0 y menor que 100 y el otro impar y mayor que el n\u00famero anterior. El programa imprime la suma y la cuenta de los nu\u0301meros entre los dos valores. Escribe un programa en C que permita convertir grados Celsius a Fahrenheit y viceversa. El programa debe mostrar un menu\u0301 para poder seleccionar que\u0301 opcio\u0301n se desea (ma\u0301s la opcio\u0301n terminar) y preguntar la temperatura que desea convertir. Cada una de las conversiones se debe realizar en una funci\u00f3n distinta . La conversio\u0301n de grados Celsius a grados Fahrenheit se obtiene multiplicando la temperatura en Celsius por 1,8 y sumando 32. La conversio\u0301n de grados Fahrenheit a grados Celsius se obtiene resta\u0301ndole 32 a la temperatura en grados Fahrenheit y dividie\u0301ndolo por 1,8. Escribe la funci\u00f3n binarioADecimal que reciba como par\u00e1metro un n\u00famero en binario y devuelva su correspondiente n\u00famero en decimal. Despu\u00e9s, pru\u00e9bala desde main . Escribe un programa que realice dos operaciones a partir de un n\u00famero entero n. Las operaciones a realizar son: - Calcular de cu\u00e1ntas cifras se compone - Mostrar la cifra i-\u00e9sima de dicho n\u00famero (la posici\u00f3n i debe pedirse al usuario). Ejemplo de ejecuci\u00f3n: 1 2 3 Introduce num : 5634 El num 5634 tiene 4 cifras La cifra 2 del n\u00famero 5634 es 3 Escribe un programa que pida caracteres hasta introducir el '.'. El programa deber\u00e1 mostrar el primer car\u00e1cter introducido, el \u00faltimo y el total de caracteres (incluido el '.'). Dada la siguiente funci\u00f3n que calcula y muestra por pantalla la suma de los n\u00fameros enteros que hay entre un intervalo y que se lleva a cabo para 3 intervalos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void SumaIntervalos () { int suma , i ; suma = 0 ; printf ( \"La suma de los n\u00fameros entre 2 y 5 es: \" ); for ( i = 2 ; i <= 5 ; i ++ ) { suma = suma + i ; } printf ( \"%d \\n \" , suma ); suma = 0 ; printf ( \"La suma de los n\u00fameros entre 0 y 3 es: \" ); for ( i = 0 ; i <= 3 ; i ++ ) { suma = suma + i ; } printf ( \"%d \\n \" , suma ); suma = 0 ; printf ( \"La suma de los n\u00fameros entre 1 y 4 es: \" ); for ( i = 1 ; i <= 4 ; i ++ ) { suma = suma + i ; } printf ( \"%d \\n \" , suma ); } La ejecuci\u00f3n de dicha funci\u00f3n, muestra por pantalla los siguientes mensajes: 1 2 3 La suma de los n\u00fameros entre 2 y 5 es : 14 La suma de los n\u00fameros entre 0 y 3 es : 6 La suma de los n\u00fameros entre 1 y 4 es : 10 Se pide definir las funciones necesarias (al menos 2) que permitan generalizar y evitar c\u00f3digo duplicado, pidiendo por teclado los datos necesarios. Un ejemplo de ejecuci\u00f3n equivalente a la anterior, pero solicitando datos por teclado ser\u00eda: 1 2 3 4 5 6 7 Introduce el n\u00famero de intervalos : 3 Introduce el intervalo : 2 5 la suma de los n\u00fameros entre 2 y 5 es : 14 Introduce el intervalo : 0 3 la suma de los n\u00fameros entre 0 y 3 es : 6 Introduce el intervalo : 1 4 la suma de los n\u00fameros entre 1 y 4 es : 10 Soluci\u00f3n ejercicio 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /////////// // Prototipos de funciones /////////// int pedirDato (); void dibujaT ( int tam ); /////////// // Funci\u00f3n principal /////////// int main () { int n ; n = pedirDato (); dibujaT ( n ); return 0 ; } ////////// // Definiciones de funciones ///////// int pedirDato () { int n ; do { printf ( \"Introduce un num impar: \" ); scanf ( \"%d\" , & n ); } while ( n % 2 == 0 ); return n ; } void dibujaT ( int tam ) { int fil , col ; for ( fil = 1 ; fil <= tam ; fil ++ ) { for ( col = 1 ; col <= tam ; col ++ ) { if ( col == tam / 2 + 1 || fil == 1 ) printf ( \"*\" ); else printf ( \" \" ); } printf ( \" \\n \" ); } } Soluci\u00f3n ejercicio 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /////////// // Prototipos de funciones /////////// void pedirDatos ( int * , int * ); void sumaYCuenta ( int , int , int * , int * ); /////////// // Funci\u00f3n principal /////////// int main () { int n1 , n2 ; int suma = 0 , cuenta = 0 ; pedirDatos ( & n1 , & n2 ); sumaYCuenta ( n1 , n2 , & suma , & cuenta ); printf ( \"La suma entre %d y %d es: %d y hay %d n\u00fameros \\n \" , n1 , n2 , suma , cuenta ); return 0 ; } ////////// // Definiciones de funciones ///////// void pedirDatos ( int * n1 , int * n2 ) { do { printf ( \"Introduce un num entre 1 y 100: \" ); scanf ( \"%d\" , n1 ); } while ( * n1 < 1 || * n1 > 100 ); do { printf ( \"Introduce un num impar y mayor que %d: \" , * n1 ); scanf ( \"%d\" , n2 ); } while ( * n2 % 2 == 0 || * n2 < * n1 ); } void sumaYCuenta ( int n1 , int n2 , int * suma , int * cuenta ) { int i ; * suma = 0 ; * cuenta = 0 ; for ( i = n1 ; i < n2 ; i ++ ) { * suma += i ; * cuenta += 1 ; } } Soluci\u00f3n ejercicio 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 /////////// // Prototipos de funciones /////////// void mostrar_menu (); float celsius_to_Fahrenheit ( float ); float fahrenheit_to_Celsius ( float ); /////////// // Funci\u00f3n principal /////////// int main (){ int opcion ; float celsius , fahr ; do { mostrar_menu (); printf ( \"Opcio\u0301n: \" ); scanf ( \"%d\" , & opcion ); switch ( opcion ){ case 1 : printf ( \"Introduzca la temperatura en grados Celsius:\" ); scanf ( \"%f\" , & celsius ); fahr = celsius_to_Fahrenheit ( celsius ); printf ( \"La temperatura en grados Fahrenheit es: %.2f \\n \" , fahr ); break ; case 2 : printf ( \"Introduzca la temperatura en grados faherenheit: \" ); scanf ( \"%f\" , & fahr ); celsius = fahrenheit_to_Celsius ( fahr ); printf ( \"La temperatura en grados Celsius es: %.2f \\n \" , celsius ); break ; case 3 : printf ( \"Ha seleccionado la opcio\u0301n Salir \\n \" ); break ; default : printf ( \"Debe introducir una opcio\u0301n de 1 a 3 \\n \" ); } } while ( opcion != 3 ); return 0 ; } ////////// // Definiciones de funciones ///////// void mostrar_menu () { printf ( \"Seleccione que\u0301 tipo de conversio\u0301n desea realizar: \\n \" ); printf ( \"1. Convertir grados Celsius a Fahrenheit. \\n \" ); printf ( \"2. Convertir grados Fahrenheit a Celsius. \\n \" ); printf ( \"3. Terminar el programa. \\n \" ); } float celsius_to_Fahrenheit ( float cel ) { float fah ; fah = cel * 1.8 + 32 ; return ( fah ); } float fahrenheit_to_Celsius ( float fah ) { float cel ; cel = ( fah - 32 ) / 1.8 ; return ( cel ); } Soluci\u00f3n ejercicio 4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /////////// // Prototipo de funci\u00f3n /////////// int binarioADecimal ( int ); /////////// // Funci\u00f3n principal /////////// int main () { int num2 , num10 ; printf ( \"Introduzca un numero en base 2: \\n \" ); scanf ( \"%d\" , & num2 ); // Llamada a la funcio\u0301n num10 = binarioADecimal ( num2 ); // Mostrar Resultados printf ( \"El numero %d en base 2 equivale a %d en base 10 \\n \" , num2 , num10 ); return 0 ; } ////////// // Definici\u00f3n de funci\u00f3n ///////// int binarioADecimal ( int n ) { int n_decimal = 0 , coef = 1 ; while ( n != 0 ) { n_decimal += coef * ( n % 10 ); coef *= 2 ; n = n / 10 ; } return ( n_decimal ); } Soluci\u00f3n ejercicio 5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 int pedirNum (); int numCifras ( int ); int cifra_i_esima ( int , int ); int main (){ int n , cifras , cifra ; n = pedirNum (); cifras = numCifras ( n ); printf ( \"El num %d tiene %d cifras \\n \" , n , cifras ); cifra = cifra_i_esima ( n , 2 ); printf ( \"La cifra 2 del n\u00famero %d es %d \\n \" , n , cifra ); return 0 ; } int pedirNum () { int n ; printf ( \"Introduce num: \" ); scanf ( \"%d\" , & n ); return n ; } int numCifras ( int num ) { int contador = 1 ; while ( num >= 10 ) { num = num / 10 ; contador ++ ; } return contador ; } int cifra_i_esima ( int num , int i ) { int posicion = 1 ; int cifra ; cifra = num % 10 ; while ( num > 9 && posicion < i ) { num = num / 10 ; // num /= 10; cifra = num % 10 ; posicion ++ ; } return cifra ; } Soluci\u00f3n ejercicio 6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void cuentaCaracteres ( char * , char * , int * ); int main () { char primero , ultimo ; int total ; cuentaCaracteres ( & primero , & ultimo , & total ); printf ( \"El primer car\u00e1cter es: %c \\n \" , primero ); printf ( \"El \u00faltimo es: %c \\n \" , ultimo ); printf ( \"El total es: %d \\n \" , total ); return 0 ; } void cuentaCaracteres ( char * primero , char * ultimo , int * total ){ char caracter ; * total = 0 ; do { printf ( \"Introduce un car\u00e1cter: \" ); scanf ( \" \\n %c\" , & caracter ); if ( * total == 0 ) * primero = caracter ; else if ( caracter != '.' ) * ultimo = caracter ; ( * total ) ++ ; } while ( caracter != '.' ); } Soluci\u00f3n ejercicio 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void solucion () { int a , b ; int n , i ; printf ( \"Introduce el n\u00famero de intervalos: \" ); scanf ( \"%d\" , & n ); for ( i = 0 ; i < n ; i ++ ) { printf ( \"Introduce el intervalo: \" ); scanf ( \"%d %d\" , & a , & b ); printf ( \"la suma de los n\u00fameros entre %d y %d es: \" , a , b ); printf ( \"%d \\n \" , sumaIntervalo ( a , b )); } } int sumaIntervalo ( int a , int b ) { int suma = 0 ; int i ; for ( i = a ; i <= b ; i ++ ) { suma = suma + i ; } return ( suma ); } Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares Puig","title":"Tema 4"},{"location":"Teoria/tema04-descomposicion-modular/tema04-descomposicion-modular.html#tema-4-descomposicion-modular","text":"","title":"Tema 4: Descomposici\u00f3n modular"},{"location":"Teoria/tema04-descomposicion-modular/tema04-descomposicion-modular.html#1-descomposicion-modular","text":"Ya hemos visto que en C se utilizan funciones de biblioteca (como printf o scanf ). Tambi\u00e9n hemos utilizado la funci\u00f3n main , que es la funci\u00f3n principal del programa. En este tema vamos a aprender a definir nuestras propias funciones que realicen determinadas tareas. El uso de funciones definidas por el programador permite dividir un programa grande en un cierto n\u00famero de componentes m\u00e1s peque\u00f1as, cada una de las cuales con un prop\u00f3sito \u00fanico e identificable. Por tanto, un programa en C se puede modularizar en subproblemas (programar de forma estructurada) mediante el uso adecuado de funciones. Podemos decir que la ejecuci\u00f3n de cualquier programa en C empieza ejecutando la funci\u00f3n main instrucci\u00f3n a instrucci\u00f3n desde la primera a la \u00faltima. Si alguna instrucci\u00f3n hace una llamada a una funci\u00f3n (la invoca), el programa deja en espera el punto de ejecuci\u00f3n por donde iba y pasa a ejecutar la funci\u00f3n, de la misma forma. Cuando termina, vuelve a seguir por la funci\u00f3n principal por donde la hab\u00eda dejado. Cada funci\u00f3n puede llamar a otras funciones, e incluso a s\u00ed misma (recursi\u00f3n). Una de las habilidades fundamentales del pensamiento computacional es la abstracci\u00f3n : definir subproblemas que creen nueva sem\u00e1ntica, dividir un problema grande en peque\u00f1os problemas (funciones). Esto hace el c\u00f3digo m\u00e1s f\u00e1cil de entender, probar, modificar, compartir y reutilizar. Ventajas de modularizar un programa: Generalizaci\u00f3n : si un programa tiene instrucciones repetidas en distintas partes, esas instrucciones repetidas se pueden agrupar en una sola funci\u00f3n, a la que acceder cuando sea necesario. Claridad l\u00f3gica : programas m\u00e1s f\u00e1ciles de escribir y depurar. La estructura l\u00f3gica es m\u00e1s f\u00e1cil de entender. Tambi\u00e9n permite al programador construir bibliotecas de funciones de uso frecuente . Evita la reescritura del c\u00f3digo. Favorece la portabilidad . Facilita el disen\u0303o descendente y la programacio\u0301n estructurada . Reduce el tiempo de programacio\u0301n: reutilizaci\u00f3n y divisi\u00f3n de tareas Disminuye el taman\u0303o total del programa Facilita la deteccio\u0301n y correccio\u0301n de errores Facilita el mantenimiento del programa Cuando empezamos a abordar un problema, lo mejor es ir dividie\u0301ndolo en subproblemas. Por ejemplo: guiado de un robot desde la clase hasta la puerta de salida Subproblemas: Encontrar la puerta del aula y salir Guiado por el pasillo hasta encontrar las escaleras Bajar las escaleras Encontrar la puerta de salida y salir Cada subproblema puede ser tratado por separado: analizado, dividido a su vez en subproblemas, probado de manera independiente, y tenemos la posibilidad de reutilizar co\u0301digo ya hecho","title":"1. Descomposici\u00f3n modular"},{"location":"Teoria/tema04-descomposicion-modular/tema04-descomposicion-modular.html#2-funciones","text":"Algunos lenguajes de programaci\u00f3n tienen dos tipos de herramientas para modularizar: procedimientos y funciones. En el lenguaje C s\u00f3lo existen las funciones . Un programa en C est\u00e1 estructurado en funciones. De hecho, main() es una funci\u00f3n, es la funci\u00f3n principal. Una funci\u00f3n es una unidad de c\u00f3digo dise\u00f1ada para realizar una tarea determinada. Las funciones en programaci\u00f3n son similares a las funciones matem\u00e1ticas, pudiendo tener argumentos o par\u00e1metros. Ejemplo: Definici\u00f3n de una funci\u00f3n en matem\u00e1ticas: f(x) = x + 5; f es el nombre de la funci\u00f3n que tiene un par\u00e1metro formal: x. La funci\u00f3n f, una vez definida, puede usarse o llamarse en algunas expresiones: y = f(4) + 1; Para descubrir el valor de f(4) hay que sustituir el par\u00e1metro formal x por el valor 4 (argumento actual), f(4) = 4+5 = 9, de donde obtenemos que y = 9 + 1 = 10. Se dice que la funci\u00f3n f devuelve el valor 9. Las funciones en programaci\u00f3n son m\u00e1s generales que las funciones matem\u00e1ticas: pueden tener par\u00e1metros de cualquier tipo y pueden incorporar estructuras de control.","title":"2. Funciones"},{"location":"Teoria/tema04-descomposicion-modular/tema04-descomposicion-modular.html#sintaxis-de-una-funcion-en-c","text":"1 2 3 < tipo_devuelto > < nombre_funcion > ( < par\u00e1metros formales > ) { < cuerpo de la funci\u00f3n > } El <tipo_devuelto> indica el tipo del valor que devuelve la funci\u00f3n. En el caso del ejemplo de la funci\u00f3n m\u00ednimo , el tipo de retorno es int . Es posible que la funci\u00f3n no devuelva nada, en ese caso el tipo de devuelto es void . El <nombre_funci\u00f3n> , en nuestro ejemplo minimo . Debe ser indicativo de la funcionalidad desarrollada. Usaremos la misma norma que para las variables <par\u00e1metros formales> : es una lista con la declaraci\u00f3n de todos los par\u00e1metros formales (tipo y nombre), separados por comas. Puede estar vac\u00eda. Los par\u00e1metros formales permiten que se transfiera informaci\u00f3n desde el punto del programa en donde se llama a la funci\u00f3n a \u00e9sta. Cada par\u00e1metro formal debe ser del mismo tipo que el dato que recibe desde el punto de llamada. El <cuerpo de la funci\u00f3n> contiene las instrucciones que realizan la tarea concreta de la funci\u00f3n. Es la implementaci\u00f3n de la funci\u00f3n. Pueden declararse variables locales a la funci\u00f3n. Puede contener la sentencia return para devolver el valor que corresponda. Formato: return <expresi\u00f3n>; Esta sentencia puede aparecer varias veces, aunque es deseable que s\u00f3lo aparezca una vez al final. En cuanto se ejecute una sentencia return la funci\u00f3n termina, devolviendo el valor que haya en esa sentencia return . El valor devuelto debe ser del tipo especificado tipo_devuelto .","title":"Sintaxis de una funci\u00f3n en C"},{"location":"Teoria/tema04-descomposicion-modular/tema04-descomposicion-modular.html#ambito-de-las-variables","text":"Variables locales : Son variables que s\u00f3lo son visibles y accesibles dentro del \u00e1mbito donde se han creado Si declaramos una variable dentro del cuerpo de una funcio\u0301n, es accesible en toda la funcio\u0301n. En cuanto la funci\u00f3n termine su ejecuci\u00f3n, esa variable desaparece. Si esta declaracio\u0301n se realiza dentro de un bloque de co\u0301digo (dentro de un if, switch, for, while ...), s\u00f3lo es accesible dentro del bloque de co\u0301digo 1 2 3 4 5 6 7 8 9 10 int main () { int a = 1 ; if ( a > 0 ) { int b = 8 ; // variable local al if } printf ( \"El valor de la variable es: %d\" , b ); //Error, variable no definida return 0 ; } Variables globales (NO SE PERMITEN EN ESTA ASIGNATURA): Son variables que se declaran fuera de todas las funciones. Pueden ser utilizadas por todas las funciones que haya despu\u00e9s de su declaraci\u00f3n. Normalmente, estas variables se declaran antes que las funciones, por lo que su \u00e1mbito o visibilidad es global. Su uso est\u00e1 desaconsejado, especialmente en programadores noveles, porque complica la comprensi\u00f3n de los programas y pueden dar lugar a efectos laterales err\u00f3neos que suelen ser muy dif\u00edcil de localizar.","title":"\u00c1mbito de las variables"},{"location":"Teoria/tema04-descomposicion-modular/tema04-descomposicion-modular.html#donde-definir-las-funciones-en-c","text":"En un programa en C las funciones pueden situarse en dos sitios distintos: Antes de la funci\u00f3n main() : En este caso se definir\u00e1 la funci\u00f3n main() al final. Las funciones se ordenar\u00e1n teniendo en cuenta que para utilizar una funci\u00f3n \u00e9sta debe estar definida previamente. 2. Despu\u00e9s de la funci\u00f3n main() : En este caso lo habitual es definir la funci\u00f3n main() al principio. Antes de la funci\u00f3n main() se incluir\u00e1n los prototipos de todas las funciones. Esto es imprescindible, ya que, al estar definidas las funciones al final, el compilador no reconoce las llamadas a las mismas que puedan haberse realizado. El orden de las funciones ya no es importante, ya que todas podr\u00e1n utilizar a todas las dem\u00e1s, puesto que est\u00e1n todos los prototipos declarados previamente. Esta segunda forma es m\u00e1s laboriosa pero evita errores en el orden de las funciones. Adem\u00e1s, el tener todos los prototipos juntos simplifica localizar las caracter\u00edsticas de cada funci\u00f3n.","title":"D\u00f3nde definir las funciones en C"},{"location":"Teoria/tema04-descomposicion-modular/tema04-descomposicion-modular.html#paso-de-parametros-por-valor-y-por-referencia","text":"","title":"Paso de par\u00e1metros por valor y por referencia"},{"location":"Teoria/tema04-descomposicion-modular/tema04-descomposicion-modular.html#estructura-de-un-programa-en-c","text":"Comentarios: En primer lugar se deben incluir unos comentarios indicando qu\u00e9 hace el programa, requisitos, autor, fecha... Inclusi\u00f3n de las Bibliotecas: Las del sistema (como stdio.h, math.h, etc.) van entre \u00e1ngulos: <...>. Las creadas por el programador van entre comillas dobles: \"...\". Declaraciones globales: variables y constantes globales (con const ), constantes simb\u00f3licas del preprocesador (con #define ) y definici\u00f3n de tipos de datos (con typedef ). Como norma general, NO DEBEN USARSE VARIABLES GLOBALES . Prototipos o declaraci\u00f3n de las funciones. Implementaci\u00f3n de las funciones, incluida main() , que puede ponerse la primera o la \u00faltima. Las dem\u00e1s funciones deber\u00edan ponerse en el mismo orden que sus prototipos para que sea f\u00e1cil localizarlas. Antes de cada funci\u00f3n debe incluirse un comentario indicando qu\u00e9 hace la funci\u00f3n, significado de sus argumentos, etc. Si se escriben antes las funciones que son llamadas por otras, poniendo main() al final, los prototipos no son estrictamente necesarios. La comunicacio\u0301n entre funciones debe realizarse a trave\u0301s de para\u0301metros, y no de variables globales","title":"Estructura de un programa en C"},{"location":"Teoria/tema04-descomposicion-modular/tema04-descomposicion-modular.html#bibliotecas-del-lenguaje-c","text":"La mayori\u0301a de lenguajes de programacio\u0301n proporcionan una coleccio\u0301n de procedimientos y funciones de uso comu\u0301n (bibliotecas o libreri\u0301as). En lenguaje C, para hacer uso de los mo\u0301dulos incluidos en una biblioteca se utiliza la directiva del compilador #include . Existe una gran variedad de bibliotecas disponibles: - Funciones matema\u0301ticas - Manejo de caracteres y de cadenas de caracteres - Manejo de entrada y salida de datos - Manejo del tiempo (fecha, hora, ...)","title":"Bibliotecas del lenguaje C"},{"location":"Teoria/tema04-descomposicion-modular/tema04-descomposicion-modular.html#ejercicios","text":"Define un programa que pida un n\u00famero impar y dibuje una T de ese tama\u00f1o. Define las funciones que consideres necesarias. Define un programa que permita leer y validar dos datos de entrada de manera que en uno de ellos el valor sea mayor que 0 y menor que 100 y el otro impar y mayor que el n\u00famero anterior. El programa imprime la suma y la cuenta de los nu\u0301meros entre los dos valores. Escribe un programa en C que permita convertir grados Celsius a Fahrenheit y viceversa. El programa debe mostrar un menu\u0301 para poder seleccionar que\u0301 opcio\u0301n se desea (ma\u0301s la opcio\u0301n terminar) y preguntar la temperatura que desea convertir. Cada una de las conversiones se debe realizar en una funci\u00f3n distinta . La conversio\u0301n de grados Celsius a grados Fahrenheit se obtiene multiplicando la temperatura en Celsius por 1,8 y sumando 32. La conversio\u0301n de grados Fahrenheit a grados Celsius se obtiene resta\u0301ndole 32 a la temperatura en grados Fahrenheit y dividie\u0301ndolo por 1,8. Escribe la funci\u00f3n binarioADecimal que reciba como par\u00e1metro un n\u00famero en binario y devuelva su correspondiente n\u00famero en decimal. Despu\u00e9s, pru\u00e9bala desde main . Escribe un programa que realice dos operaciones a partir de un n\u00famero entero n. Las operaciones a realizar son: - Calcular de cu\u00e1ntas cifras se compone - Mostrar la cifra i-\u00e9sima de dicho n\u00famero (la posici\u00f3n i debe pedirse al usuario). Ejemplo de ejecuci\u00f3n: 1 2 3 Introduce num : 5634 El num 5634 tiene 4 cifras La cifra 2 del n\u00famero 5634 es 3 Escribe un programa que pida caracteres hasta introducir el '.'. El programa deber\u00e1 mostrar el primer car\u00e1cter introducido, el \u00faltimo y el total de caracteres (incluido el '.'). Dada la siguiente funci\u00f3n que calcula y muestra por pantalla la suma de los n\u00fameros enteros que hay entre un intervalo y que se lleva a cabo para 3 intervalos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void SumaIntervalos () { int suma , i ; suma = 0 ; printf ( \"La suma de los n\u00fameros entre 2 y 5 es: \" ); for ( i = 2 ; i <= 5 ; i ++ ) { suma = suma + i ; } printf ( \"%d \\n \" , suma ); suma = 0 ; printf ( \"La suma de los n\u00fameros entre 0 y 3 es: \" ); for ( i = 0 ; i <= 3 ; i ++ ) { suma = suma + i ; } printf ( \"%d \\n \" , suma ); suma = 0 ; printf ( \"La suma de los n\u00fameros entre 1 y 4 es: \" ); for ( i = 1 ; i <= 4 ; i ++ ) { suma = suma + i ; } printf ( \"%d \\n \" , suma ); } La ejecuci\u00f3n de dicha funci\u00f3n, muestra por pantalla los siguientes mensajes: 1 2 3 La suma de los n\u00fameros entre 2 y 5 es : 14 La suma de los n\u00fameros entre 0 y 3 es : 6 La suma de los n\u00fameros entre 1 y 4 es : 10 Se pide definir las funciones necesarias (al menos 2) que permitan generalizar y evitar c\u00f3digo duplicado, pidiendo por teclado los datos necesarios. Un ejemplo de ejecuci\u00f3n equivalente a la anterior, pero solicitando datos por teclado ser\u00eda: 1 2 3 4 5 6 7 Introduce el n\u00famero de intervalos : 3 Introduce el intervalo : 2 5 la suma de los n\u00fameros entre 2 y 5 es : 14 Introduce el intervalo : 0 3 la suma de los n\u00fameros entre 0 y 3 es : 6 Introduce el intervalo : 1 4 la suma de los n\u00fameros entre 1 y 4 es : 10","title":"Ejercicios"},{"location":"Teoria/tema05-datos-estructurados-Arrays/tema05-datos-estructurados-Arrays.html","text":"Tema 5: Datos estructurados: Arrays \u00b6 Contenidos \u00b6 1. Tipos de datos estructurados 2. Tipo Array 2-1. Definici\u00f3n 2-2. Arrays y funciones 3. Arrays multidimensionales 4. Cadenas de caracteres 5. Algoritmos de ordenaci\u00f3n 1. Tipos de datos estructurados \u00b6 A partir de los tipos de datos simples que hemos visto, se pueden definir en C otros tipos de datos compuestos por colecciones o agrupaciones de elementos de tipos simples. Los tipos estructurados o compuestos pueden almacenar m\u00e1s de un elemento (valor) a la vez. Se dividen en: Arrays : todos los elementos que almacena una variable de tipo array deben ser del mismo tipo . Pueden ser: Unidimensionales Multidimensionales Cadenas de caracteres Registros o estructuras: una variable de tipo registro puede almacenar elementos de distinto tipo . En C, se utiliza el tipo struct equivalente al record de otros lenguajes. 2. Tipo Array \u00b6 Es una estructura de datos que contiene una coleccio\u0301n de datos finita, homoge\u0301nea y ordenada de elementos, y se almacena en posiciones de memoria contiguas. finita : debe determinarse cua\u0301l sera\u0301 el nu\u0301mero ma\u0301ximo de elementos que podra\u0301n almacenarse en el array homoge\u0301nea : todos los elementos deben ser del mismo tipo ordenada : se puede determinar cua\u0301l es el n-e\u0301simo elemento del array A un elemento espec\u00edfico de un array se accede mediante un \u00edndice , que siempre empieza en la posici\u00f3n 0 (la primera posici\u00f3n del array) y se numeran consecutivamente 0, 1, 2, 3, etc. La \u00faltima posici\u00f3n tendr\u00e1 como \u00edndice el n\u00famero de elementos del array menos uno. 2.1 Definici\u00f3n de un array \u00b6 Sintaxis para definir un array unidimensional en C: 1 tipoDato nombreArray [ dimension ]; donde tipoDato representa el tipo de los elementos que constituyen el array, nombreArray el nombre de la variable utilizada para el array y dimension el n\u00famero de elementos del array. Por ejemplo: 1 int numeros [ 10 ]; define un array llamado numeros que est\u00e1 formado por 10 elementos de tipo int . A cada elemento se acccede mediante un \u00edndice entre 0 y dimension-1 (0 y 9 en este caso). La declaraci\u00f3n anterior hace que el compilador reserve espacio sufuciente para contener 10 valores enteros. En C los enteros ocupan 2 bytes, por lo que un array de 10 enteros ocupa 20 bytes de memoria. Sintaxis para acceder a un elemento del array: 1 array [ indice ] As\u00ed, por ejemplo, numeros[0] representa el primer elemento del array, y numeros[6] el s\u00e9ptimo elemento. Hay que tener cuidado y no utilizar valores de i\u0301ndices fuera del rango ya que provocar\u00eda errores en la ejecucio\u0301n de nuestro programa. El compilador de C no comprueba que los \u00edndices de un array est\u00e9n dentro del rango definido, por lo que si se intenta acceder a un \u00edndice fuera del rango, tendremos un error durante la ejecuci\u00f3n de nuestro programa. Otro ejemplo: El tipo del valor de la variable a es un entero. Cada elemento del array b (b[0], ...,b[9]) es un entero y puede ser usado en cualquier contexto donde es usado un entero Si nos referimos a b sin corchetes, obtenemos la direcci\u00f3n de memoria donde empieza el array (veremos los punteros m\u00e1s adelante) Inicializaci\u00f3n de un Array Si se conocen los valores que toman las componentes del array al definirlo, podemos definir y asignar valores simulta\u0301neamente. Un array se puede inicializar en su declaraci\u00f3n utilizando llaves {}: 1 int vector [ 5 ] = { 10 , 20 , 30 , 40 , 50 }; Los valores se asignan uno a uno consecutivamente: Tama\u00f1o autom\u00e1tico: si no especificamos el tama\u00f1o del array, el compilador cuenta el n\u00famero de elementos de la inicializaci\u00f3n y \u00e9se es el tama\u00f1o del array 1 int vectorB [] = { 11 , 23 , 3 , 10 }; Inicializaci\u00f3n incompleta: 1 2 // Se inicializan s\u00f3lo los 4 primeros elementos int vectorC [ 10 ] = { 7 , 7 , 7 , 7 }; 1 2 // Si hay m\u00e1s valores, da ERROR: int vectorD [ 5 ] = { 1 , 20 , 3 , 40 , 5 , 60 }; Tambi\u00e9n podemos inicializar un array haciendo que el usuario introduzca los datos por teclado: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #define TAM 10 void inicializarArray ( float calificaciones []); int main () { float calificaciones [ TAM ]; inicializarArray ( calificaciones ); } // funci\u00f3n para inicializar el array void inicializarArray ( float calificaciones []) { int i ; for ( i = 0 ; i < TAM ; i ++ ) { printf ( \"Introduce la calificacio\u0301n %d: \" , i ); scanf ( \"%f\" , & calificaciones [ i ]); } } 2.2 Arrays y funciones \u00b6 En lenguaje C, el paso de para\u0301metros de los arrays siempre es por referencia . En lenguaje C, las funciones no pueden devolver un tipo array est\u00e1tico. Para modificar un array, ha de ser pasado como para\u0301metro (siempre es por referencia y por tanto se modificar\u00e1 el array original) Es imposible que la funci\u00f3n determine el tama\u00f1o del array. Si se necesita el tama\u00f1o en la funci\u00f3n, se tiene que pasar como argumento Si el n\u00famero de elementos es fijo, se puede utilizar una constante Ejemplos Ejemplo 1: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #define TAM 20 float calculaMedia ( float [], int ); int rellenaDatos ( float []); int main () { int longitud ; float v [ TAM ]; float media ; longitud = rellenaDatos ( v ); media = calculaMedia ( v , longitud ); printf ( \"La nota media es %.2f \\n \" , media ); } float calculaMedia ( float a [], int len ) { int i ; float suma ; suma = 0.0 ; for ( i = 0 ; i < len ; i ++ ) suma = suma + a [ i ]; // suponemos len > 0 return ( suma / len ); } int rellenaDatos ( float vector []) { int indice = 0 ; float nota ; do { printf ( \"Introduce nota: \" ); scanf ( \"%f\" , & nota ); if ( nota != - 1 ) { vector [ indice ] = nota ; indice ++ ; } } while ( nota != - 1 ); return indice ; } Ejemplo 2: 1 2 3 4 5 6 void printArray ( float array [], int len ){ int i ; for ( i = 0 ; i < len ; i ++ ) printf ( \"[%.2f] \\n \" , array [ i ]); } Ejemplo 3: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* Dado un array de enteros, mover todos sus elementos una posicio\u0301n a la derecha. El desplazamiento sera\u0301 circular, es decir, el u\u0301ltimo elemento pasara\u0301 a ser el primero*/ void moverEnCircular ( int v []) { int i , ult ; // guardar el valor de la u\u0301ltima posicio\u0301n del array ult = v [ LMAX - 1 ]; // mover todos los elementos una posicio\u0301n a la derecha, excepto el u\u0301ltimo for ( i = LMAX - 1 ; i > 0 ; i -- ) v [ i ] = v [ i - 1 ]; // actualizar la primera posicio\u0301n con el valor que teni\u0301amos en la u\u0301ltima v [ 0 ] = ult ; } Ejemplo 4: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* Dado un array de enteros, devolver el mayor valor, el nu\u0301mero de ocurrencias de dicho valor, y la posicio\u0301n de la primera y u\u0301ltima aparicio\u0301n en la que se encuentra almacenada*/ void ocurrencias ( int v [], int * mayor , int * num_ocur , int * pos_pri , int * pos_ult ) { int i ; * mayor = v [ 0 ]; // inicialmente el nu\u0301mero mayor sera\u0301 el que esta\u0301 en la primera posicio\u0301n num_ocur = 1; * pos_pri = 0 ; * pos_ult = 0 ; // recorrer el array: desde la segunda posicio\u0301n hasta la posicio\u0301n final (constante LMAX) for ( i = 1 ; i < LMAX ; i ++ ) { if ( v [ i ] > * mayor ) { // encontramos un nuevo nu\u0301mero mayor * mayor = v [ i ]; * num_ocur = 1 ; * pos_pri = i ; * pos_ult = i ; } else if ( v [ i ] == * mayor ) { // encontramos una nueva ocurrencia del nu\u0301mero mayor hasta el momento * num_ocur = * num_ocur + 1 ; * pos_ult = i ; } } } int main () { int mayor , num_ocur , pos_pri , pos_ult ; int v [] = { 1 , 3 , 5 , 1 , 3 , 5 }; ocurrencias ( v , & mayor , & num_ocur , & pos_pri , & pos_ult ); } 3. Arrays multidimensionales \u00b6 Hemos visto los arrays unidimensionales, cuyos elementos se almacenan en posiciones contiguas de memoria, a cada una de las cuales se puede acceder directamente mediante un i\u0301ndice. A los arrays de m\u00e1s de una dimensi\u00f3n se les denomina multidimensionales . Sintaxis: 1 tipo_elemento nombre_array [ a ][ b ][ c ]...[ z ]; Una matriz es un array de 2 dimensiones, es decir un array unidimensional de arrays unidimensionales. En general, un array de dimensi\u00f3n n es un array unidimensional de arrays de dimensi\u00f3n n\u20131. Ejemplos: 1 2 3 4 // Array bidimensional de 6*10 enteros (matriz de 60 elems): int matriz [ 6 ][ 10 ]; //Array tridimensional de 3*2*5 reales (cubo de 30 elems): float cubo [ 3 ][ 2 ][ 5 ]; Almacenamiento en memoria arrays multidimensionales Los elementos se almacenan contiguos en memoria: Inicializaci\u00f3n arrays multidimensionales Si se conocen todos los elementos al declarar el array, hay dos modos de escribir la lista de inicializaciones: Todos los valores seguidos: 1 int matriz [ 2 ][ 3 ] = { 0 , 1 , 2 , 10 , 11 , 12 }; Por partes (mejor, mayor claridad): 1 2 int matriz [ 2 ][ 3 ] = { { 0 , 1 , 2 }, { 10 , 11 , 12 } } ; Si no se conocen, es \u00fatil recorrer el array (un bucle por cada dimensi\u00f3n) e ir asignando los valores Arrays multidimensionales y funciones Un array multidimensional, al igual que uno unidimensional, tambi\u00e9n puede pasarse como argumento a una funci\u00f3n. Se pasa la direcci\u00f3n del primer elemento del array. Ese primer elemento es otro array (de 1 dimensi\u00f3n menos). Se puede usar el siguiente prototipo: 1 2 3 // Recibe una matriz en la cual cada fila // tiene 10 enteros y con cualquier n\u00famero de filas void func ( int mat [][ 10 ]); Acceso a los elementos (por \u00edndices) Para identificar un elemento de un array multidimensional, se debe dar un \u00edndice para cada dimensi\u00f3n, en el mismo orden que en la declaraci\u00f3n. Cada \u00edndice se encierra en sus propios corchetes Ejemplo 1: 1 2 3 4 5 6 7 8 9 // Array bidimensional con los n\u00fameros del 1 al 12 void main (){ int num [ 3 ][ 4 ], i , j ; for ( i = 0 ; i < 3 ; i ++ ) for ( j = 0 ; j < 4 ; j ++ ) num [ i ][ j ] = ( i * 4 ) + j + 1 ; } Ejemplo 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //Programa que muestra los valores almacenados en //un array bidimensional 2 x 3 #define FILAS 2 #define COLUMNAS 3 int main () { int matriz [ FILAS ][ COLUMNAS ] = { { 1 , 2 , 3 }, { 4 , 5 , 6 } }; int fil , col ; for ( fil = 0 ; fil < FILAS ; fil ++ ) for ( col = 0 ; col < COLUMNAS ; col ++ ) printf ( \"El valor de [%d][%d] es %d \\n \" , fil , col , matriz [ fil ][ col ]); } // Salida por pantalla: /* El valor de [0][0] es 1 El valor de [0][1] es 2 El valor de [0][2] es 3 El valor de [1][0] es 4 El valor de [1][1] es 5 El valor de [1][2] es 6 */ Ejemplo 3: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // Suma de matrices #define FILAS 5 #define COLUMNAS 7 /* Funci\u00f3n que rellena los valores de una matriz */ void rellena ( int m [][ COLUMNAS ]) { int i , j ; for ( i = 0 ; i < FILAS ; i ++ ) for ( j = 0 ; j < COLUMNAS ; j ++ ) { printf ( \"Valor [%d,%d]: \" , i , j ); scanf ( \"%d\" , & m [ i ][ j ]); } } /* Suma dos matrices */ void suma ( int m1 [][ COLUMNAS ], int m2 [][ COLUMNAS ], int r [][ COLUMNAS ]) { int i , j ; for ( i = 0 ; i < FILAS ; i ++ ) for ( j = 0 ; j < COLUMNAS ; j ++ ) { r [ i ][ j ] = m1 [ i ][ j ] + m2 [ i ][ j ]; } } /* Muestra una matriz*/ void imprime ( int m [][ COLUMNAS ]) { int i , j ; for ( i = 0 ; i < FILAS ; i ++ ) { for ( j = 0 ; j < COLUMNAS ; j ++ ) printf ( \" %d\" , m [ i ][ j ]); printf ( \" \\n \" ); } } int main () { int a [ FILAS ][ COLUMNAS ], b [ FILAS ][ COLUMNAS ], c [ FILAS ][ COLUMNAS ]; rellena ( a ); rellena ( b ); suma ( a , b , c ); imprime ( c ); } Ejemplo donde pasamos como par\u00e1metro a una funci\u00f3n s\u00f3lo una fila de una matriz: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 void Funcion ( int v []){ //Recibe una fila (vector) int i ; for ( i = 0 ; i < 5 ; i ++ ){ v [ i ] = 100 ; } } void imprimir ( int m [][ 5 ]) { int i , j ; for ( i = 0 ; i < 5 ; i ++ ){ for ( j = 0 ; j < 5 ; j ++ ){ printf ( \"%d \" , m [ i ][ j ]); } printf ( \" \\n \" ); } } void rellenar ( int m [][ 5 ]) { int i , j ; for ( i = 0 ; i < 5 ; i ++ ){ for ( j = 0 ; j < 5 ; j ++ ){ m [ i ][ j ] = 20 ; } } printf ( \" \\n \" ); } int main (){ int vec [ 5 ][ 5 ]; int cont ; cont = 3 ; rellenar ( vec ); Funcion ( vec [ cont ]); //Modifica la fila 3 (vector) imprimir ( vec ); } 4. Cadenas de caracteres \u00b6 En C no existe un tipo especi\u0301fico para trabajar con cadenas de caracteres (en otros lenguajes es el tipo String ). En C, una cadena de caracteres es un array unidimensional de tipo char . El \u00faltimo car\u00e1cter visible de la cadena debe estar seguido del car\u00e1cter nulo que se representa por '\\0' . Este car\u00e1cter marca el final de la cadena de caracteres Existen librer\u00edas con funciones para realizar la mayor parte de las operaciones b\u00e1sicas sobre cadenas. Ejemplos: 1 2 char cadena [ 20 ]; char cadena [] = \"Adios\" ; En las dos \u00faltimas declaraciones el tama\u00f1o del array ser\u00e1 el n\u00famero de caracteres dado en la inicializaci\u00f3n m\u00e1s 1 (que corresponde al car\u00e1cter \u2018\\0\u2019). printf y scanf con cadenas Las funciones printf y scanf tratan el '\\0' automa\u0301ticamente con %s 1 2 3 printf ( \"%s \\n \" , cadena ); scanf ( \"%s\" , cadena ); scanf ( \"%[^ \\n ]s\" , cadena ); //lee la entrada estandar hasta encontrar \\n, sin detenerse en espacios Librer\u00eda string.h Para trabajar con cadenas de caracteres, en C tenemos la libreri\u0301a string.h : 1 #include <string.h> Algunas de las funciones que incluye: int strlen(char *s); Devuelve el taman\u0303o de la cadena antes de '\\0' char *strcpy(char *dest, char *src); Copia la cadena origen src en la cadena destino dest . char *strcat(char *dest, char *src); Concatena la cadena origen src al final de la cadena destino dest int strcmp(char *s1, char *s2); Compara dos cadenas. Devuelve 0 en caso de que sean iguales. <0 si la primera cadena es menor y >0 si la primera cadena es mayor. Orden lexicogra\u0301fico strcpy y strcat devuelven un puntero a la cadena resultante. No comprueban si el resultado cabe en la cadena final. Ejemplos con cadenas de caracteres Ejemplo 1: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // devuelve la longitud de una cadena de caracteres // esta funcio\u0301n es equivalente a strlen() int longitudCadena ( char cad []) { int len ; len = 0 ; while ( cad [ len ] != '\\0' ) len ++ ; return ( len ); } Ejemplo 2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main () { int n ; char nombre1 [ 20 ], nombre2 [ 20 ]; printf ( \"Teclea el primer nombre: \" ); scanf ( \"%s\" , nombre1 ); printf ( \"Teclea el segundo nombre: \" ); scanf ( \"%s\" , nombre2 ); n = strcmp ( nombre1 , nombre2 ); if ( n == 0 ) printf ( \"Nombres iguales \\n \" ); else if ( n > 0 ) printf ( \"Primer nombre mayor que el segundo \\n \" ); else printf ( \"Primer nombre menor que el segundo \\n \" ); } Ejemplo 3: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int main () { char cad1 [ 10 ], cad2 [ 10 ]; strcpy ( cad1 , \"Hola \" ); /* Se guardan en cad1 6 caracteres (incluido el \u2018\\0\u2019)*/ strcpy ( cad2 , \"y adios\" ); /* Se guardan en cad2 8 caracteres (incluido el \u2018\\0\u2019) */ strcat ( cad1 , cad2 ); /* Se concatena la cadena cad2 al final de cad1. Observa que se intentan guardar en cad1 m\u00e1s caracteres que la longitud de la cadena. El compilador no da error y se escribe a continuaci\u00f3n de cad1, en memoria que no pertenece a cad1. */ printf ( \"cad1: %s \\n \" , cad1 ); /* ERROR. Se intenta escribir cad1 hasta que encuentre un \u2018\\0\u2019. El resultado es impredecible: puede escribir \"Hola y adios\" a pesar de que en total son m\u00e1s de 10 caracteres, puede escribir otra cosa o puede quedarse colgado el terminal. */ } Para solucionar el problema anterior (en cad1 no cabe la cadena), podemos comprobar si se puede concatenar antes de hacerlo: 1 2 3 // comprobar si se puede concatenar antes de hacerlo: if ( strlen ( cad1 ) + strlen ( cad2 ) < 10 ) strcat ( cad1 , cad2 ); Funciones relacionadas con cadenas de caracteres Algunas funciones de conversi\u00f3n incluidas en la librer\u00eda stdlib.h double atof(char *s) : convierte la cadena s a float 1 2 char numero [ 11 ] = \"123.456789\" ; printf ( \"Convertimos la cadena \\\" %s \\\" en un float: %f \\n \" , numPtr , atof ( numero ) ); int atoi(char *s) : convierte la cadena s a int 1 2 3 int num ; num = atoi ( \"123\" ); printf ( \"El int es: %d \\n \" , num ); long atol(char *s) : convierte la cadena s a long int 1 2 char numero [ 11 ] = \"1234567890\" ; printf ( \"Convertimos la cadena \\\" %s \\\" en un long int: %u \\n \" , numPtr , atol ( numero ) ); Ejemplos de arrays utilizando typedef \u00b6 Escribe un programa completo que lea un vector de enteros positivos e imprima el n\u00famero mayor. Para la realizacio\u0301n del programa utilizaremos tres funciones, una para leer el vector, otra para imprimir el vector por pantalla y otra para encontrar el elemento mayor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include <stdio.h> #include <stdlib.h> #include <stdbool.h> #define TAM 10 typedef int TVector [ TAM ]; void leerVector ( TVector vector ); void imprimirVector ( TVector vector ); int mayorVector ( TVector vector ); int main () { TVector vector ; int mayor ; leerVector ( vector ); imprimirVector ( vector ); mayor = mayorVector ( vector ); printf ( \"El elemento mayor del vector es : %d \\n \" , mayor ); } //Funcio\u0301n para leer el contenido del vector. //Leeremos nu\u0301meros enteros positivos void leerVector ( TVector vector ) { int i ; i = 0 ; do { printf ( \"Introduce el numero de la posicio\u0301n %d: \" , i ); scanf ( \"%d\" , & vector [ i ]); if ( vector [ i ] < 0 ) printf ( \"N\u00famero incorrecto \\n \" ); else i ++ ; // Incrementamos contador } while ( i < TAM ); } //Imprime por pantalla los elementos del vector. void imprimirVector ( TVector vector ) { int i ; printf ( \"Valores del vector: \\n \" ); for ( i = 0 ; i < TAM ; i ++ ) printf ( \"%d \" , vector [ i ]); printf ( \" \\n \" ); } //Funcio\u0301n que devuelve el mayor nu\u0301mero del vector. int mayorVector ( TVector vector ) { int i , mayor ; mayor = vector [ 0 ]; // Al principio el mayor sera\u0301 el primer elemento. for ( i = 1 ; i < TAM ; i ++ ) if ( vector [ i ] > mayor ) mayor = vector [ i ]; return mayor ; } Escribe un programa que pida una cadena de caracteres (de ma\u0301ximo 15 caracteres) y devuelva la cadena escrita al reve\u0301s. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #define TAM 15 typedef char TCadena [ TAM ]; void alReves ( TCadena , TCadena , int ); int main (){ TCadena palabra , palabra_reves ; int i , cont , longitud_palabra ; printf ( \"Introduzca una palabra: \" ); scanf ( \"%s\" , palabra ); longitud_palabra = strlen ( palabra ); alReves ( palabra , palabra_reves , longitud_palabra ); printf ( \"Palabra escrita al reve\u0301s: %s \\n \" , palabra_reves ); } void alReves ( TCadena palabra , TCadena palabra_reves , int longitud ){ int i , cont = 0 ; for ( i = longitud - 1 ; i >= 0 ; i -- ) { palabra_reves [ cont ] = palabra [ i ]; cont ++ ; } palabra_reves [ cont ] = '\\0' ; } Escribe un programa que lea los datos de un array bidimensional o matriz de 5 filas por 4 columnas y luego imprima esta matriz por pantalla. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #define FILS 5 #define COLS 4 typedef int TMatriz [ FILS ][ COLS ]; void leerMatriz ( TMatriz matriz ); void escribirMatriz ( TMatriz matriz ); int main () { TMatriz matriz ; leerMatriz ( matriz ); escribirMatriz ( matriz ); } void leerMatriz ( TMatriz matriz ) { int i , j ; for ( i = 0 ; i < FILS ; i ++ ) for ( j = 0 ; j < COLS ; j ++ ) { printf ( \"Introduzca el elemento (%d,%d): \" , i , j ); scanf ( \"%d\" , & matriz [ i ][ j ]); } } void escribirMatriz ( TMatriz matriz ) { int i , j ; for ( i = 0 ; i < FILS ; i ++ ) { for ( j = 0 ; j < COLS ; j ++ ) { // %5d formatea rellenando con espacios a tam 5 printf ( \"%5d\" , matriz [ i ][ j ]); } printf ( \" \\n \" ); } } Implementa un programa que rellene una matriz que contenga las tablas de multiplicar. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #define TAM 11 typedef int TMatriz [ TAM ][ TAM ]; void rellenaTablaMultiplicar ( TMatriz A ); void imprimir ( TMatriz matriz ); int main () { TMatriz tabla ; rellenaTablaMultiplicar ( tabla ); imprimir ( tabla ); } void rellenaTablaMultiplicar ( TMatriz A ) { int i , j ; A [ 0 ][ 0 ] = 0 ; // Rellenamos la tabla for ( i = 0 ; i < TAM ; i ++ ) { for ( j = 0 ; j < TAM ; j ++ ) { A [ i ][ j ] = i * j ; } A [ 0 ][ i ] = i ; A [ i ][ 0 ] = i ; } } void imprimir ( TMatriz matriz ) { int i , j ; for ( i = 0 ; i < TAM ; i ++ ) { for ( j = 0 ; j < TAM ; j ++ ) { printf ( \"%d \\t \" , matriz [ i ][ j ]); } printf ( \" \\n \" ); } } 5. Algoritmos de ordenaci\u00f3n \u00b6 Es interesante y habitual la operacio\u0301n de ordenacio\u0301n en un array. La b\u00fasqueda de un dato dentro de un conjunto es otro de los procesos m\u00e1s habituales en el tratamiento de informaci\u00f3n. Si los datos est\u00e1n ordenados, la localizaci\u00f3n de uno de ellos puede acelerarse. Por ejemplo, si quereos mantener ordenado un vector de calificaciones para poder consultar ra\u0301pidamente las cinco mejores notas, tendri\u0301amos que ordenar nuestro vector de mayor a menor (en orden decreciente) y acceder a las cinco primeras posiciones del vector. Imaginemos que tenemos declarado el siguiente vector: 1 int vec [ 5 ] = { 1 , 5 , 6 , 4 , 2 }; Ahora queremos saber si un determinado valor, 3 por ejemplo, se encuentra en dicho vector, o queremos devolver el valor ma\u0301s parecido \u00bfque\u0301 hari\u0301amos? Lo mismo podemos hacer para cadenas de caracteres (que es donde ma\u0301s se usa la ordenacio\u0301n). Vamos a ver varios me\u0301todos (algoritmos) de ordenacio\u0301n de vectores. Aunque los veamos para enteros, son perfectamente extensibles a otros tipos de datos (incluso registros). So\u0301lo tendri\u0301amos que definir la manera de comparar datos (<, >, =) Podemos ordenar de mayor a menor o de menor a mayor. Cada algoritmo tiene su complejidad . Son m\u00e9tricas que permiten conocer el tiempo de procesamiento de cada algoritmo. La forma esta\u0301ndar es utilizar ordenes de complejidad, que relacionan el tiempo de computacio\u0301n con el taman\u0303o del problema a tratar. La jerarqui\u0301a de ordenes de complejidad seri\u0301a O(1)<O(log n)<O(n)<O(n logn)<O(n2)<O(n3)<O(n4).. 5.1 Algoritmo de la burbuja \u00b6 El m\u00e9todo de la burbuja funciona revisando cada elemento del vector que va a ser ordenado con el siguiente, intercambi\u00e1ndolos de posici\u00f3n si est\u00e1n en el orden equivocado. Es necesario revisar varias veces todo el vector hasta que no se necesiten m\u00e1s intercambios, lo cual significa que est\u00e1 ordenado. Este algoritmo obtiene su nombre de la forma con la que suben por la lista los elementos durante los intercambios, como si fueran peque\u00f1as burbujas. Tambi\u00e9n es conocido como el m\u00e9todo del intercambio directo. Caracter\u00edsticas: Ma\u0301s sencillo e intuitivo de aplicar En el peor de los casos tenemos una complejidad cuadra\u0301tica (si tenemos n datos, O(n2)) Se empieza por el primer elemento de la lista y se recorre toda la lista. Dado un elemento, este se compara con el siguiente y si no esta\u0301 en el orden adecuado (por ejemplo, es mayor) se intercambia. Hay que recorrer n-1 veces la lista. Si es la iteracio\u0301n k, el punto anterior lo hacemos hasta n-k Pseudoc\u00f3digo: 1 2 3 4 5 6 7 8 9 10 desde i = 1 hasta n hacer desde j = 0 hasta n - i hacer si elemento [ j ] > elemento [ j + 1 ] entonces // Intercambiar los elementos aux = V [ j ] V [ j ] = V [ j + 1 ] V [ j + 1 ] = aux fin_si fin_desde fin_desde Implementaci\u00f3n en C: 1 2 3 4 5 6 7 8 9 10 11 12 13 void burbuja ( int v [], int elems ) { int temp , i , j ; for ( i = 1 ; i < elems ; i ++ ) { for ( j = 0 ; j < elems - i ; j ++ ) { if ( v [ j ] > v [ j + 1 ]) { temp = v [ j ]; v [ j ] = v [ j + 1 ]; v [ j + 1 ] = temp ; } } } } 5.2 Algoritmo de selecci\u00f3n \u00b6 Consiste en encontrar el menor de todos los elementos del vector e intercambiarlo con el que est\u00e1 en la primera posici\u00f3n. Luego el segundo mas peque\u00f1o, y as\u00ed sucesivamente hasta ordenarlo todo. Su implementaci\u00f3n requiere O(n2) comparaciones e intercambios para ordenar una secuencia de elementos. Mejora algo el anterior, aunque todavi\u0301a tiene una complejidad O(n2) Realizamos n iteraciones Para cada iteracio\u0301n, buscamos el elemento con menor (mayor) valor del vector. Intercambiamos ese valor por la posicio\u0301n actual del vector En la primera iteracio\u0301n, buscamos el menor valor de todo el vector En la segunda, el segundo menor valor o el menor valor del resto del vector Pseudoc\u00f3digo: 1 2 3 4 5 6 7 8 9 para i = 1 hasta n - 1 ; minimo = i ; para j = i + 1 hasta n si lista [ j ] < lista [ minimo ] entonces minimo = j fin si fin para intercambiar ( lista [ i ], lista [ minimo ]) fin para Implementaci\u00f3n en C: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void seleccion ( int v [], int tam ) { int minimo = 0 , i , j ; int swap ; for ( i = 0 ; i < tam - 1 ; i ++ ) { minimo = i ; for ( j = i + 1 ; j < tam ; j ++ ) if ( v [ minimo ] > v [ j ]) minimo = j ; swap = v [ minimo ]; v [ minimo ] = v [ i ]; v [ i ] = swap ; } } 5.3 Algoritmo de inserci\u00f3n \u00b6 Este m\u00e9todo consiste en insertar un elemento del vector en la parte izquierda del mismo que ya se encuentra ordenada. Este proceso se repite desde el segundo hasta el n-esimo elemento. Seguimos teniendo una complejidad O(n2) Es lo ma\u0301s parecido a ordenar un mazo de cartas El primer elemento de la lista lo consideramos ordenado Para el resto, vamos analizando uno a uno cada valor Cogemos el valor y lo insertamos en la posicio\u0301n correcta del vector que nos queda a la izquierda de dicho valor, desplazando los valores hacia la derecha Implementaci\u00f3n en C: 1 2 3 4 5 6 7 8 9 10 11 12 void insercion ( int numbers [], int array_size ) { int i , a , index ; for ( i = 1 ; i < array_size ; i ++ ) { index = numbers [ i ]; a = i - 1 ; while ( a >= 0 && numbers [ a ] > index ) { numbers [ a + 1 ] = numbers [ a ]; a -- ; } numbers [ a + 1 ] = index ; } } Ejercicios propuestos de Arrays \u00b6 Implementa una funci\u00f3n que rellene una matriz con los primeros N n\u00fameros en zigzag, como indica la figura: Matriz 4x4 resultante: Implementa las funciones sobre cadenas de caracteres strcmp y atoi . Implementa una funci\u00f3n que reciba dos arrays ordenados de manera ascendente de 10 nu\u0301meros y devuelva un vector de 20 nu\u0301meros formado por los nu\u0301meros de los vectores de entrada. Este array resultante tambie\u0301n debe estar ordenado. Implementa una funci\u00f3n que reciba como para\u0301metro una matriz de enteros de M filas y N columnas. La funci\u00f3n debe cambiar el valor de la primera y u\u0301ltima celda de cada fila de la siguiente manera: primera celda \u2192 valor ma\u0301s pequen\u0303o de las celdas adyacentes u\u0301ltima celda \u2192 valor ma\u0301s grande de las celdas adyacentes. Por ejemplo, para la matriz: La matriz resultante ser\u00eda: Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares Puig","title":"Tema 5: Datos estructurados: Arrays"},{"location":"Teoria/tema05-datos-estructurados-Arrays/tema05-datos-estructurados-Arrays.html#tema-5-datos-estructurados-arrays","text":"","title":"Tema 5: Datos estructurados: Arrays"},{"location":"Teoria/tema05-datos-estructurados-Arrays/tema05-datos-estructurados-Arrays.html#contenidos","text":"1. Tipos de datos estructurados 2. Tipo Array 2-1. Definici\u00f3n 2-2. Arrays y funciones 3. Arrays multidimensionales 4. Cadenas de caracteres 5. Algoritmos de ordenaci\u00f3n","title":"Contenidos"},{"location":"Teoria/tema05-datos-estructurados-Arrays/tema05-datos-estructurados-Arrays.html#ejemplos-de-arrays-utilizando-typedef","text":"Escribe un programa completo que lea un vector de enteros positivos e imprima el n\u00famero mayor. Para la realizacio\u0301n del programa utilizaremos tres funciones, una para leer el vector, otra para imprimir el vector por pantalla y otra para encontrar el elemento mayor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include <stdio.h> #include <stdlib.h> #include <stdbool.h> #define TAM 10 typedef int TVector [ TAM ]; void leerVector ( TVector vector ); void imprimirVector ( TVector vector ); int mayorVector ( TVector vector ); int main () { TVector vector ; int mayor ; leerVector ( vector ); imprimirVector ( vector ); mayor = mayorVector ( vector ); printf ( \"El elemento mayor del vector es : %d \\n \" , mayor ); } //Funcio\u0301n para leer el contenido del vector. //Leeremos nu\u0301meros enteros positivos void leerVector ( TVector vector ) { int i ; i = 0 ; do { printf ( \"Introduce el numero de la posicio\u0301n %d: \" , i ); scanf ( \"%d\" , & vector [ i ]); if ( vector [ i ] < 0 ) printf ( \"N\u00famero incorrecto \\n \" ); else i ++ ; // Incrementamos contador } while ( i < TAM ); } //Imprime por pantalla los elementos del vector. void imprimirVector ( TVector vector ) { int i ; printf ( \"Valores del vector: \\n \" ); for ( i = 0 ; i < TAM ; i ++ ) printf ( \"%d \" , vector [ i ]); printf ( \" \\n \" ); } //Funcio\u0301n que devuelve el mayor nu\u0301mero del vector. int mayorVector ( TVector vector ) { int i , mayor ; mayor = vector [ 0 ]; // Al principio el mayor sera\u0301 el primer elemento. for ( i = 1 ; i < TAM ; i ++ ) if ( vector [ i ] > mayor ) mayor = vector [ i ]; return mayor ; } Escribe un programa que pida una cadena de caracteres (de ma\u0301ximo 15 caracteres) y devuelva la cadena escrita al reve\u0301s. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #define TAM 15 typedef char TCadena [ TAM ]; void alReves ( TCadena , TCadena , int ); int main (){ TCadena palabra , palabra_reves ; int i , cont , longitud_palabra ; printf ( \"Introduzca una palabra: \" ); scanf ( \"%s\" , palabra ); longitud_palabra = strlen ( palabra ); alReves ( palabra , palabra_reves , longitud_palabra ); printf ( \"Palabra escrita al reve\u0301s: %s \\n \" , palabra_reves ); } void alReves ( TCadena palabra , TCadena palabra_reves , int longitud ){ int i , cont = 0 ; for ( i = longitud - 1 ; i >= 0 ; i -- ) { palabra_reves [ cont ] = palabra [ i ]; cont ++ ; } palabra_reves [ cont ] = '\\0' ; } Escribe un programa que lea los datos de un array bidimensional o matriz de 5 filas por 4 columnas y luego imprima esta matriz por pantalla. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #define FILS 5 #define COLS 4 typedef int TMatriz [ FILS ][ COLS ]; void leerMatriz ( TMatriz matriz ); void escribirMatriz ( TMatriz matriz ); int main () { TMatriz matriz ; leerMatriz ( matriz ); escribirMatriz ( matriz ); } void leerMatriz ( TMatriz matriz ) { int i , j ; for ( i = 0 ; i < FILS ; i ++ ) for ( j = 0 ; j < COLS ; j ++ ) { printf ( \"Introduzca el elemento (%d,%d): \" , i , j ); scanf ( \"%d\" , & matriz [ i ][ j ]); } } void escribirMatriz ( TMatriz matriz ) { int i , j ; for ( i = 0 ; i < FILS ; i ++ ) { for ( j = 0 ; j < COLS ; j ++ ) { // %5d formatea rellenando con espacios a tam 5 printf ( \"%5d\" , matriz [ i ][ j ]); } printf ( \" \\n \" ); } } Implementa un programa que rellene una matriz que contenga las tablas de multiplicar. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #define TAM 11 typedef int TMatriz [ TAM ][ TAM ]; void rellenaTablaMultiplicar ( TMatriz A ); void imprimir ( TMatriz matriz ); int main () { TMatriz tabla ; rellenaTablaMultiplicar ( tabla ); imprimir ( tabla ); } void rellenaTablaMultiplicar ( TMatriz A ) { int i , j ; A [ 0 ][ 0 ] = 0 ; // Rellenamos la tabla for ( i = 0 ; i < TAM ; i ++ ) { for ( j = 0 ; j < TAM ; j ++ ) { A [ i ][ j ] = i * j ; } A [ 0 ][ i ] = i ; A [ i ][ 0 ] = i ; } } void imprimir ( TMatriz matriz ) { int i , j ; for ( i = 0 ; i < TAM ; i ++ ) { for ( j = 0 ; j < TAM ; j ++ ) { printf ( \"%d \\t \" , matriz [ i ][ j ]); } printf ( \" \\n \" ); } }","title":"Ejemplos de arrays utilizando typedef"},{"location":"Teoria/tema05-datos-estructurados-Arrays/tema05-datos-estructurados-Arrays.html#ejercicios-propuestos-de-arrays","text":"Implementa una funci\u00f3n que rellene una matriz con los primeros N n\u00fameros en zigzag, como indica la figura: Matriz 4x4 resultante: Implementa las funciones sobre cadenas de caracteres strcmp y atoi . Implementa una funci\u00f3n que reciba dos arrays ordenados de manera ascendente de 10 nu\u0301meros y devuelva un vector de 20 nu\u0301meros formado por los nu\u0301meros de los vectores de entrada. Este array resultante tambie\u0301n debe estar ordenado. Implementa una funci\u00f3n que reciba como para\u0301metro una matriz de enteros de M filas y N columnas. La funci\u00f3n debe cambiar el valor de la primera y u\u0301ltima celda de cada fila de la siguiente manera: primera celda \u2192 valor ma\u0301s pequen\u0303o de las celdas adyacentes u\u0301ltima celda \u2192 valor ma\u0301s grande de las celdas adyacentes. Por ejemplo, para la matriz: La matriz resultante ser\u00eda: Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares Puig","title":"Ejercicios propuestos de Arrays"},{"location":"Teoria/tema06-datos-estructurados-Registros/tema06-datos-estructurados-Registros.html","text":"Tema 6: Tipos de datos estructurados: Registros \u00b6 Contenidos \u00b6 1. Registros 1-1. Definici\u00f3n 1-2. Operadores 1-3. Registros y funciones 1-4. Estructuras anidadas 1-5. Arrays de registros 2. Uniones 1. Registros \u00b6 Los tipos de datos compuestos o estructurados, son tipos compuestos por otros tipos. Vimos que hab\u00edan dos tipos: Array: Est\u00e1 compuesto por elementos del mismo tipo. Por ejemplo, un array de enteros, todos sus elementos son enteros. Registro o estructura: Est\u00e1 compuesto por elementos heterog\u00e9neos, pueden tener distintos tipos. Definici\u00f3n Un registro es un tipo de datos que permite agrupar bajo un mismo nombre elementos del mismo o de distinto tipo de datos, que se encuentran relacionados entre s\u00ed. Cada elemento se denomina campo o miembro de la estructura. Un registro permite encapsular entidades donde cada campo representa los atributos o propiedades de dicha entidad. Carater\u00edsticas: Un registro o estructura es la manera que tenemos de encapsular variables de diferentes tipos bajo una u\u0301nica entidad: nos referimos a ellos con un identificador u\u0301nico. Tienen la peculiaridad de que las variables que forman parte del registro estara\u0301n alineadas en memoria: eficiencia En un registro se agrupan atributos de una entidad Cada uno de los elementos de un registro se denomina campo . Para referirse a un determinado elemento de un registro se debera\u0301 utilizar el identificador del registro, seguido de un punto \u2018.\u2019 y del identificador del campo correspondiente Persona: Nombre Apellidos NIF edad g\u00e9nero Direcci\u00f3n: Calle N\u00famero CP Poblaci\u00f3n Provincia Cliente: NumCliente Persona Direcci\u00f3n Empresa Diferencias respecto a los arrays: Los elementos de un array son todos del mismo tipo, en una estructura no. En un array se selecciona un elemento por su posici\u00f3n dentro del array, en una estructura cada elemento tiene su identificador 1.1 Definici\u00f3n de un registro \u00b6 La sintaxis es: struct nombreRegistro { tipo-campo1 nombre-campo1 tipo-campo2 nombre-campo2 ... }; Pueden utilizarse arrays como campos. Ejemplo: 1 2 3 4 5 6 struct CD { char titulo [ 20 ]; char artista [ 25 ]; int num_canciones ; float precio ; }; Sintaxis utilizando typedef : typedef struct {...} nombreRegistro; Dentro de las llaves escribiremos los campos que va a contener el registro. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 typedef struct { char nombre [ 20 ]; char apellidos [ 30 ]; char nif [ 10 ]; int edad ; char genero ; } TPersona ; int main () { // Declaraci\u00f3n de variables de estructuras struct CD cd1 ; struct CD cd2 ; // Declaraci\u00f3n de variables de estructuras definidas con typedef TPersona persona1 ; } Uso de los registros Con un registro se puede trabajar a dos niveles: con el registro completo y con sus campos. Podemos utilizar la operaci\u00f3n de asignaci\u00f3n entre registros, pero no la de comparaci\u00f3n. Es decir, podemos asignar a una variable de tipo struct el valor de otra del mismo tipo. Tambi\u00e9n es posible pasar un registro como par\u00e1metro a una funci\u00f3n y que una funci\u00f3n devuelva un registro. En el siguiente ejemplo, asignamos una estructura a otra: 1 cd1 = cd2 ; Inicializaci\u00f3n de registros Podemos inicializar los registros al definir las variables o dejarlos vac\u00edos para manejarlos m\u00e1s adelante: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct CD cd1 = { \"Wish\" , // album \"The Cure\" , // artista 7 , // num_canciones 21.5 // precio }; TPersona persona1 = { // definido con typedef \"Pepe\" , \"Garc\u00eda\" , \"32112234z\" , 55 , 'V' }; 1.2 Operadores para manejo de registros \u00b6 El operador . Para acceder a los campos de una variable de tipo registro utilizamos el operador punto . . Este opeador proporciona el camino directo al campo correspondiente. Los datos deben ser del mismo tipo que el tipo declarado para ese campo. 1 2 3 4 5 6 7 TPersona persona2 ; strcpy ( persona2 . nombre , \"Mar\u00eda\" ); strcpy ( persona2 . apellidos , \"S\u00e1nchez\" ); strcpy ( persona2 . nif , \"11222433A\" ); persona2 . edad = 25 ; persona2 . genero = 'M' ; El operador -> Para acceder a los campos de una variable de tipo puntero (lo veremos en el siguiente tema) a registro utilizamos el operador puntero -> . Este operador indica que en la parte izquierda est\u00e1 la direcci\u00f3n de memoria de un registro, y la parte derecha los campos del mismo. 1 < puntero_estructura > -> < nombre_campo > = datos ; Es el caso, por ejemplo, de los registros pasados como par\u00e1metro por referencia a una funci\u00f3n. La funci\u00f3n recibe como argumento la direcci\u00f3n de memoria (puntero) del registro. 1 2 3 4 5 void imprimir ( TPersona * p ) { printf ( \"El nombre es: %s \\n \" , p -> nombre ); printf ( \"Apellidos: %s \\n \" , p -> apellidos ); printf ( \"Edad: %d \\n \" , p -> edad ); } 1.3 Registros y funciones \u00b6 Paso de registros como par\u00e1metros a funciones De forma general: Paso por valor cuando se use la informacio\u0301n del registro sin modificarlo Paso por referencia cuando modifiquemos algu\u0301n campo del registro, pasando la direcci\u00f3n de memoria utilizando el operador & . De forma excepcional, tendremos en cuenta que en algunos casos el taman\u0303o del registro en memoria puede ser elevado, por lo que valoraremos en la implementaci\u00f3n cu\u00e1ndo nos conviene pasarlo por valor o por referencia, independientemente de si se modifican o no sus campos. Funciones que devuelven registros Vamos a seguir la misma norma que cuando tratamos tipos de datos simples, es decir, cuando s\u00f3lo se va a devolver un dato (en este caso un registro), se har\u00e1 a trav\u00e9s de return. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 typedef struct { int x ; int y ; } TPunto ; // prototipos de funciones TPunto leerPunto (); void imprimePunto ( TPunto ); void swap ( TPunto * , TPunto * ); int main () { TPunto p1 , p2 ; p1 = leerPunto (); p2 = leerPunto (); imprimePunto ( p1 ); imprimePunto ( p2 ); swap ( & p1 , & p2 ); imprimePunto ( p1 ); imprimePunto ( p2 ); } TPunto leerPunto () { TPunto p ; printf ( \"Coordenada x del punto:\" ); scanf ( \"%d\" , & p . x ); printf ( \"Coordenada y del punto:\" ); scanf ( \"%d\" , & p . y ); return p ; } void imprimePunto ( TPunto punto ) { printf ( \"[X:%d, Y:%d] \\n \" , punto . x , punto . y ); } void swap ( TPunto * p1 , TPunto * p2 ) { TPunto aux ; aux . x = p1 -> x ; aux . y = p1 -> y ; p1 -> x = p2 -> x ; p1 -> y = p2 -> y ; p2 -> x = aux . x ; p2 -> y = aux . y ; } 1.4 Estructuras anidadas \u00b6 Un registro puede contener otros registros. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 typedef struct { char nombre [ 20 ]; char apellidos [ 30 ]; char nif [ 10 ]; int edad ; char genero ; } TPersona ; typedef struct { int codCliente ; TPersona datosCliente ; char direccion [ 100 ]; char nombreEmpresa [ 50 ]; } TCliente ; 1.5 Arrays de registros \u00b6 Podemos definir arrays donde su tipo base sea un registro, es decir, cada elemento del vector es un registro, con memoria reservada para su uso. Ya que en los arrays s\u00f3lo podemos almacenar diversos valores de un mismo tipo, los arrays de estructuras permiten almacenar diversos valores de diferentes tipos agrupados en registros. 1 2 3 4 5 6 7 typedef struct { char nombre [ 50 ]; float precio ; int stock ; } TProducto ; TProducto vectorProductos [ 100 ]; Para acceder a los campos de cada uno de los elementos, se recorre el array y se accede a cada elemento como lo hacemos con otros tipos de dato: 1 2 3 strcpy ( vectorProductos [ 0 ]. nombre , \"Libro Programaci\u00f3n en C\" ); vectorProductos [ 0 ]. precio = 17.5 vectorProductos [ 0 ]. stock = 4 ; 2. Uniones \u00b6 Las uniones son similares a las estructuras en cuanto que agrupan una serie de datos, pero la forma de almacenamiento es diferente: Las estructuras almacenan variables relacionadas juntas y almacenadas en posiciones contiguas de memoria. Las uniones almacenan tambi\u00e9n m\u00faltiples campos, pero todos ellos se solapan entre s\u00ed en la misma posici\u00f3n. Para determinar el tama\u00f1o de una uni\u00f3n se analiza el tama\u00f1o de cada campo y el de mayor tama\u00f1o ser\u00e1 el tama\u00f1o de la uni\u00f3n. Una raz\u00f3n para usarlas es ahorrar memoria. Se usan cuando se tienen varios variables relacionadas de alguna forma, pero no se van a usar al mismo tiempo. Por ejemplo, si tenemos una estructura para almacenar una imagen de 256x256 p\u00edxeles, y cada imagen las tenemos codificada en un formato, podemos utilizar una misma estructura para almacenar una imagen, que puede estar en formatos diferentes y s\u00f3lo ocupar\u00eda el mayor tama\u00f1o. Sintaxis: union nombre-union { tipo1 campo1; tipo2 campo2; ... }; La forma de acceder a los campos de una uni\u00f3n es igual que en las estructuras. Tambi\u00e9n se pueden definir con typedef . Ejemplo: 1 2 3 4 5 6 7 8 9 10 union ejemplo { char letra ; double altura ; }; // Definido con typedef: typedef union { char letra ; double altura ; } TEjemplo ; La cantidad total de memoria utilizada por la union es de 8 bytes, ya que el campo double altura es el mayor. Ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 typedef union { int a ; char b ; } TPrueba ; int main () { TPrueba p1 ; p1 . a = 50 ; p1 . b = 'A' ; printf ( \"p1.a: %d p1.b: %c \\n \" , p1 . a , p1 . b ); } // Salida: // p1.a: 65 p1.b: A Las uniones tambi\u00e9n nos sirven para generalizar . En el siguiente ejemplo, tenemos una estructura para almacenar DVD y otra para almacenar CD. Queremos hacer un array gen\u00e9rico que almacene dispositivos tanto de DVD como de CD. Para ello creamos otra estructura TDispositivo gen\u00e9rica, que almacenar\u00e1 o un CD o un DVD. El array lo definimos de tipo TDispositivo, por lo que podr\u00e1 almacenar en cada posici\u00f3n un CD o un DVD. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #define TAM 2 typedef enum { CD , DVD } TTipoDisp ; typedef struct { char titulo [ 20 ]; char artista [ 25 ]; int num_canciones ; float precio ; } TCD ; typedef struct { char titulo [ 20 ]; char director [ 25 ]; float precio ; } TDVD ; typedef struct { TTipoDisp tipo ; union { TCD cd ; TDVD dvd ; } disp ; } TDispositivo ; void imprimeDisp ( TDispositivo []); int main () { TDispositivo disp [ TAM ]; TCD cd1 = { \"Hopes and fears\" , \"Keane\" , 7 , 17.99 }; TDVD dvd1 = { \"Spiderman\" , \"Sam Raimi\" , 9.99 }; disp [ 0 ]. disp . cd = cd1 ; disp [ 0 ]. tipo = CD ; disp [ 1 ]. disp . dvd = dvd1 ; disp [ 1 ]. tipo = DVD ; imprimeDisp ( disp ); } void imprimeDisp ( TDispositivo arrayDisp []) { int i ; for ( i = 0 ; i < TAM ; i ++ ) { printf ( \"Tipo: %d \\n \" , arrayDisp [ i ]. tipo ); switch ( arrayDisp [ i ]. tipo ) { printf ( \"Tipo: %d \\n \" , arrayDisp [ i ]. tipo ); case CD : printf ( \"*************** \\n \" ); printf ( \"T\u00edtulo: %s \\n \" , arrayDisp [ i ]. disp . cd . titulo ); printf ( \"Artista: %s \\n \" , arrayDisp [ i ]. disp . cd . artista ); break ; case DVD : printf ( \"*************** \\n \" ); printf ( \"T\u00edtulo: %s \\n \" , arrayDisp [ i ]. disp . dvd . titulo ); printf ( \"Director: %s \\n \" , arrayDisp [ i ]. disp . dvd . director ); break ; } } } Ejercicio 1 \u00b6 Define los tipos de datos necesarios que permitan almacenar los datos de 100 alumnos. De cada alumno se quiere almacenar su nombre, apellidos y direcci\u00f3n. Cada uno tiene 10 asignaturas compuestas de co\u0301digo de la asignatura y nota. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //En primer lugar definimos las constantes necesarias. #define TAMCAD 45 #define TAMASIG 3 #define NUMASIG 10 #define NUMALU 100 //Definimos las estructuras necesarias //Cada alumno tiene 10 asignaturas compuesto de co\u0301digo de la asignatura y nota typedef struct { char codigoAsignatura [ TAMASIG ]; float nota ; } TAsignatura ; //Estructura con la informacio\u0301n de los alumnos typedef struct { char nombre [ TAMCAD ]; char apellidos [ TAMCAD ]; char direccion [ TAMCAD ]; TAsignatura asig [ NUMASIG ]; } TFichaAlumno ; //Array que contendra\u0301 los datos de todos los alumnos typedef TFichaAlumno TAlumnos [ NUMALU ]; Ejercicio 2 \u00b6 Escribe un programa que guarde informacio\u0301n de 30 alumnos. De cada alumno leeremos su nu\u0301mero de expediente, nombre, fecha de nacimiento, fecha de ingreso y su nota media. El programa debe permitir dar de alta un alumno y mostrar todos los alumnos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 #define TAMCAD 45 #define NUMALU 30 typedef struct { int dia ; int mes ; int anyo ; } TFecha ; typedef struct { int exp ; char nombre [ TAMCAD ]; TFecha fechaNac ; TFecha fechaIng ; float notaMedia ; } TFichaAlumno ; //Array de alumnos typedef TFichaAlumno TAlumnos [ NUMALU ]; //Prototipos funciones void mostrarFecha ( TFecha ); void mostrarAlumnos ( TAlumnos , int ); void darDeAltaAlumno ( TAlumnos , int * ); void pedirFecha ( TFecha * ); int pedirOpcion (); int main (){ TAlumnos alumnos ; int opcion , numAlumnos ; numAlumnos = 0 ; do { opcion = pedirOpcion (); switch ( opcion ){ case 1 : if ( numAlumnos < NUMALU ) darDeAltaAlumno ( alumnos , & numAlumnos ); else printf ( \"No es posible introducir ma\u0301s alumnos\" ); break ; case 2 : mostrarAlumnos ( alumnos , numAlumnos ); break ; case 3 : printf ( \"Terminado \\n \" ); break ; default : printf ( \"Opcio\u0301n incorrecta \\n \" ); } } while ( opcion != 3 ); } int pedirOpcion () { int opcion ; printf ( \"******Gestio\u0301n de alumnos****** \\n \" ); printf ( \"Opciones disponibles: \\n \" ); printf ( \"1. Dar de alta un alumno \\n \" ); printf ( \"2. Mostrar listado alumnos \\n \" ); printf ( \"3. Salir \\n \" ); printf ( \"Seleccione una opcio\u0301n: \" ); scanf ( \"%d\" , & opcion ); return opcion ; } //Muestra la fecha separada por / void mostrarFecha ( TFecha fecha ){ printf ( \"%d / %d / %d \\n \" , fecha . dia , fecha . mes , fecha . anyo ); } void mostrarAlumnos ( TAlumnos alumnos , int numAlumnos ) { int i ; for ( i = 0 ; i < numAlumnos ; i ++ ) { printf ( \"Alumno: %d \\n \" , alumnos [ i ]. exp ); printf ( \"Nombre: %s \\n \" , alumnos [ i ]. nombre ); printf ( \"Fecha de nacimiento: \" ); mostrarFecha ( alumnos [ i ]. fechaNac ); printf ( \"Fecha de ingreso: \" ); mostrarFecha ( alumnos [ i ]. fechaIng ); printf ( \"Nota media: %.2f \\n \" , alumnos [ i ]. notaMedia ); } } //Solicita la fecha void pedirFecha ( TFecha * fecha ) { printf ( \" \\t Introduce di\u0301a:\" ); scanf ( \"%d\" , & fecha -> dia ); printf ( \" \\t Introduce mes: \" ); scanf ( \"%d\" , & fecha -> mes ); printf ( \" \\t Introduce an\u0303o: \" ); scanf ( \"%d\" , & fecha -> anyo ); } //Solicita los datos de los alumnos void darDeAltaAlumno ( TAlumnos alumnos , int * numAlumnos ) { int i ; i = * numAlumnos ; printf ( \"Introduce el nu\u0301mero de expediente: \" ); scanf ( \"%d\" , & alumnos [ i ]. exp ); printf ( \"Introduce el nombre: \" ); scanf ( \"%s\" , alumnos [ i ]. nombre ); printf ( \"Fecha de nacimiento: \\n \" ); pedirFecha ( & alumnos [ i ]. fechaNac ); printf ( \"Fecha de ingreso: \\n \" ); pedirFecha ( & alumnos [ i ]. fechaIng ); printf ( \"Introduce la nota media: \" ); scanf ( \"%f\" , & alumnos [ i ]. notaMedia ); ( * numAlumnos ) ++ ; } Ejercicio 3 \u00b6 Escribe los tipos de datos adecuados para almacenar tri\u00e1ngulos. De cada tri\u00e1ngulo se quiere guardar los tres puntos de sus v\u00e9rtices, su \u00e1rea y su per\u00edmetro. Se pide leer un tri\u00e1ngulo por teclado: \u00fanicamente se leer\u00e1n sus tres puntos. Su \u00e1rea y su per\u00edmetro se calcular\u00e1n autom\u00e1ticamente despu\u00e9s de la lectura. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include <stdio.h> #include <math.h> typedef struct { int x ; int y ; } TPunto ; typedef struct { TPunto p1 ; TPunto p2 ; TPunto p3 ; float area ; float perimetro ; } TTriangulo ; TTriangulo leerTriangulo (); void calculaLados ( TTriangulo , float * , float * , float * ); void calculaPerimetroYArea ( TTriangulo * ); int main () { TTriangulo triangulo ; triangulo = leerTriangulo (); printf ( \"El per\u00edmetro del tri\u00e1ngulo es: %.2f \\n \" , triangulo . perimetro ); printf ( \"El \u00e1rea del tri\u00e1ngulo es: %.2f \\n \" , triangulo . area ); } TTriangulo leerTriangulo () { TTriangulo triangulo ; printf ( \"Introduzca las coordenadas del punto 1: \\n \" ); scanf ( \"%d %d\" , & triangulo . p1 . x , & triangulo . p1 . y ); printf ( \"Introduzca las coordenadas del punto 2: \\n \" ); scanf ( \"%d %d\" , & triangulo . p2 . x , & triangulo . p2 . y ); printf ( \"Introduzca las coordenadas del punto 3: \\n \" ); scanf ( \"%d %d\" , & triangulo . p3 . x , & triangulo . p3 . y ); calculaPerimetroYArea ( & triangulo ); return triangulo ; } void calculaPerimetroYArea ( TTriangulo * triangulo ) { float s , lado1 , lado2 , lado3 ; calculaLados ( * triangulo , & lado1 , & lado2 , & lado3 ); triangulo -> perimetro = lado1 + lado2 + lado3 ; // F\u00f3rmula de Her\u00f3n s = 1.0 / 2.0 * triangulo -> perimetro ; triangulo -> area = sqrt ( s * ( s - lado1 ) * ( s - lado2 ) * ( s - lado3 )); } void calculaLados ( TTriangulo triangulo , float * lado1 , float * lado2 , float * lado3 ) { * lado1 = sqrt ( pow ( triangulo . p1 . x - triangulo . p2 . x , 2 ) + pow ( triangulo . p1 . y - triangulo . p2 . y , 2 )); * lado2 = sqrt ( pow ( triangulo . p1 . x - triangulo . p3 . x , 2 ) + pow ( triangulo . p1 . y - triangulo . p3 . y , 2 )); * lado3 = sqrt ( pow ( triangulo . p3 . x - triangulo . p2 . x , 2 ) + pow ( triangulo . p3 . y - triangulo . p2 . y , 2 )); } Ejercicios propuestos \u00b6 Ejercicio 4 \u00b6 Vamos a partir del ejercicio de los tri\u00e1ngulos. Queremos almacenar 10 tri\u00e1ngulos y ordenarlos de menor a mayor per\u00edmetro. Mu\u00e9stralos ordenados por pantalla, puedes usar el algoritmo de ordenaci\u00f3n que prefieras. Puedes hacer una funci\u00f3n que imprima los datos de un tri\u00e1ngulo por pantalla. Ejercicio 5 \u00b6 Define un nuevo tipo TRectangulo y a\u00f1ade la misma funcionalidad que para los tri\u00e1ngulos: \u00e1rea y per\u00edmetro. Ejercicio 6 \u00b6 Dada la siguiente definici\u00f3n de tipos de datos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 typedef enum { TRIANGULO , RECTANGULO } TTipoFigura ; typedef struct { int x ; int y ; } TPunto ; typedef struct { TPunto p1 ; TPunto p2 ; TPunto p3 ; float area ; float perimetro ; } TTriangulo ; typedef struct { TPunto p1 ; //esquina inferior izquierda TPunto p2 ; //esquina superior derecha float area ; float perimetro ; } TRectangulo ; typedef struct { TTipoFigura tipo ; union { TTriangulo triangulo ; TRectangulo rectangulo ; } fig ; } TFigura ; Define un array gen\u00e9rico de figuras de tipo TFigura. Podr\u00e1 contener tanto tri\u00e1ngulos como rect\u00e1ngulos. Implementa una funci\u00f3n que reciba dicho array e imprima los datos de la figura que contiene en cada posici\u00f3n. Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares Puig","title":"Tema 6: Tipos de datos estructurados: Registros"},{"location":"Teoria/tema06-datos-estructurados-Registros/tema06-datos-estructurados-Registros.html#tema-6-tipos-de-datos-estructurados-registros","text":"","title":"Tema 6: Tipos de datos estructurados: Registros"},{"location":"Teoria/tema06-datos-estructurados-Registros/tema06-datos-estructurados-Registros.html#contenidos","text":"1. Registros 1-1. Definici\u00f3n 1-2. Operadores 1-3. Registros y funciones 1-4. Estructuras anidadas 1-5. Arrays de registros 2. Uniones","title":"Contenidos"},{"location":"Teoria/tema06-datos-estructurados-Registros/tema06-datos-estructurados-Registros.html#ejercicio-1","text":"Define los tipos de datos necesarios que permitan almacenar los datos de 100 alumnos. De cada alumno se quiere almacenar su nombre, apellidos y direcci\u00f3n. Cada uno tiene 10 asignaturas compuestas de co\u0301digo de la asignatura y nota. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //En primer lugar definimos las constantes necesarias. #define TAMCAD 45 #define TAMASIG 3 #define NUMASIG 10 #define NUMALU 100 //Definimos las estructuras necesarias //Cada alumno tiene 10 asignaturas compuesto de co\u0301digo de la asignatura y nota typedef struct { char codigoAsignatura [ TAMASIG ]; float nota ; } TAsignatura ; //Estructura con la informacio\u0301n de los alumnos typedef struct { char nombre [ TAMCAD ]; char apellidos [ TAMCAD ]; char direccion [ TAMCAD ]; TAsignatura asig [ NUMASIG ]; } TFichaAlumno ; //Array que contendra\u0301 los datos de todos los alumnos typedef TFichaAlumno TAlumnos [ NUMALU ];","title":"Ejercicio 1"},{"location":"Teoria/tema06-datos-estructurados-Registros/tema06-datos-estructurados-Registros.html#ejercicio-2","text":"Escribe un programa que guarde informacio\u0301n de 30 alumnos. De cada alumno leeremos su nu\u0301mero de expediente, nombre, fecha de nacimiento, fecha de ingreso y su nota media. El programa debe permitir dar de alta un alumno y mostrar todos los alumnos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 #define TAMCAD 45 #define NUMALU 30 typedef struct { int dia ; int mes ; int anyo ; } TFecha ; typedef struct { int exp ; char nombre [ TAMCAD ]; TFecha fechaNac ; TFecha fechaIng ; float notaMedia ; } TFichaAlumno ; //Array de alumnos typedef TFichaAlumno TAlumnos [ NUMALU ]; //Prototipos funciones void mostrarFecha ( TFecha ); void mostrarAlumnos ( TAlumnos , int ); void darDeAltaAlumno ( TAlumnos , int * ); void pedirFecha ( TFecha * ); int pedirOpcion (); int main (){ TAlumnos alumnos ; int opcion , numAlumnos ; numAlumnos = 0 ; do { opcion = pedirOpcion (); switch ( opcion ){ case 1 : if ( numAlumnos < NUMALU ) darDeAltaAlumno ( alumnos , & numAlumnos ); else printf ( \"No es posible introducir ma\u0301s alumnos\" ); break ; case 2 : mostrarAlumnos ( alumnos , numAlumnos ); break ; case 3 : printf ( \"Terminado \\n \" ); break ; default : printf ( \"Opcio\u0301n incorrecta \\n \" ); } } while ( opcion != 3 ); } int pedirOpcion () { int opcion ; printf ( \"******Gestio\u0301n de alumnos****** \\n \" ); printf ( \"Opciones disponibles: \\n \" ); printf ( \"1. Dar de alta un alumno \\n \" ); printf ( \"2. Mostrar listado alumnos \\n \" ); printf ( \"3. Salir \\n \" ); printf ( \"Seleccione una opcio\u0301n: \" ); scanf ( \"%d\" , & opcion ); return opcion ; } //Muestra la fecha separada por / void mostrarFecha ( TFecha fecha ){ printf ( \"%d / %d / %d \\n \" , fecha . dia , fecha . mes , fecha . anyo ); } void mostrarAlumnos ( TAlumnos alumnos , int numAlumnos ) { int i ; for ( i = 0 ; i < numAlumnos ; i ++ ) { printf ( \"Alumno: %d \\n \" , alumnos [ i ]. exp ); printf ( \"Nombre: %s \\n \" , alumnos [ i ]. nombre ); printf ( \"Fecha de nacimiento: \" ); mostrarFecha ( alumnos [ i ]. fechaNac ); printf ( \"Fecha de ingreso: \" ); mostrarFecha ( alumnos [ i ]. fechaIng ); printf ( \"Nota media: %.2f \\n \" , alumnos [ i ]. notaMedia ); } } //Solicita la fecha void pedirFecha ( TFecha * fecha ) { printf ( \" \\t Introduce di\u0301a:\" ); scanf ( \"%d\" , & fecha -> dia ); printf ( \" \\t Introduce mes: \" ); scanf ( \"%d\" , & fecha -> mes ); printf ( \" \\t Introduce an\u0303o: \" ); scanf ( \"%d\" , & fecha -> anyo ); } //Solicita los datos de los alumnos void darDeAltaAlumno ( TAlumnos alumnos , int * numAlumnos ) { int i ; i = * numAlumnos ; printf ( \"Introduce el nu\u0301mero de expediente: \" ); scanf ( \"%d\" , & alumnos [ i ]. exp ); printf ( \"Introduce el nombre: \" ); scanf ( \"%s\" , alumnos [ i ]. nombre ); printf ( \"Fecha de nacimiento: \\n \" ); pedirFecha ( & alumnos [ i ]. fechaNac ); printf ( \"Fecha de ingreso: \\n \" ); pedirFecha ( & alumnos [ i ]. fechaIng ); printf ( \"Introduce la nota media: \" ); scanf ( \"%f\" , & alumnos [ i ]. notaMedia ); ( * numAlumnos ) ++ ; }","title":"Ejercicio 2"},{"location":"Teoria/tema06-datos-estructurados-Registros/tema06-datos-estructurados-Registros.html#ejercicio-3","text":"Escribe los tipos de datos adecuados para almacenar tri\u00e1ngulos. De cada tri\u00e1ngulo se quiere guardar los tres puntos de sus v\u00e9rtices, su \u00e1rea y su per\u00edmetro. Se pide leer un tri\u00e1ngulo por teclado: \u00fanicamente se leer\u00e1n sus tres puntos. Su \u00e1rea y su per\u00edmetro se calcular\u00e1n autom\u00e1ticamente despu\u00e9s de la lectura. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include <stdio.h> #include <math.h> typedef struct { int x ; int y ; } TPunto ; typedef struct { TPunto p1 ; TPunto p2 ; TPunto p3 ; float area ; float perimetro ; } TTriangulo ; TTriangulo leerTriangulo (); void calculaLados ( TTriangulo , float * , float * , float * ); void calculaPerimetroYArea ( TTriangulo * ); int main () { TTriangulo triangulo ; triangulo = leerTriangulo (); printf ( \"El per\u00edmetro del tri\u00e1ngulo es: %.2f \\n \" , triangulo . perimetro ); printf ( \"El \u00e1rea del tri\u00e1ngulo es: %.2f \\n \" , triangulo . area ); } TTriangulo leerTriangulo () { TTriangulo triangulo ; printf ( \"Introduzca las coordenadas del punto 1: \\n \" ); scanf ( \"%d %d\" , & triangulo . p1 . x , & triangulo . p1 . y ); printf ( \"Introduzca las coordenadas del punto 2: \\n \" ); scanf ( \"%d %d\" , & triangulo . p2 . x , & triangulo . p2 . y ); printf ( \"Introduzca las coordenadas del punto 3: \\n \" ); scanf ( \"%d %d\" , & triangulo . p3 . x , & triangulo . p3 . y ); calculaPerimetroYArea ( & triangulo ); return triangulo ; } void calculaPerimetroYArea ( TTriangulo * triangulo ) { float s , lado1 , lado2 , lado3 ; calculaLados ( * triangulo , & lado1 , & lado2 , & lado3 ); triangulo -> perimetro = lado1 + lado2 + lado3 ; // F\u00f3rmula de Her\u00f3n s = 1.0 / 2.0 * triangulo -> perimetro ; triangulo -> area = sqrt ( s * ( s - lado1 ) * ( s - lado2 ) * ( s - lado3 )); } void calculaLados ( TTriangulo triangulo , float * lado1 , float * lado2 , float * lado3 ) { * lado1 = sqrt ( pow ( triangulo . p1 . x - triangulo . p2 . x , 2 ) + pow ( triangulo . p1 . y - triangulo . p2 . y , 2 )); * lado2 = sqrt ( pow ( triangulo . p1 . x - triangulo . p3 . x , 2 ) + pow ( triangulo . p1 . y - triangulo . p3 . y , 2 )); * lado3 = sqrt ( pow ( triangulo . p3 . x - triangulo . p2 . x , 2 ) + pow ( triangulo . p3 . y - triangulo . p2 . y , 2 )); }","title":"Ejercicio 3"},{"location":"Teoria/tema06-datos-estructurados-Registros/tema06-datos-estructurados-Registros.html#ejercicios-propuestos","text":"","title":"Ejercicios propuestos"},{"location":"Teoria/tema06-datos-estructurados-Registros/tema06-datos-estructurados-Registros.html#ejercicio-4","text":"Vamos a partir del ejercicio de los tri\u00e1ngulos. Queremos almacenar 10 tri\u00e1ngulos y ordenarlos de menor a mayor per\u00edmetro. Mu\u00e9stralos ordenados por pantalla, puedes usar el algoritmo de ordenaci\u00f3n que prefieras. Puedes hacer una funci\u00f3n que imprima los datos de un tri\u00e1ngulo por pantalla.","title":"Ejercicio 4"},{"location":"Teoria/tema06-datos-estructurados-Registros/tema06-datos-estructurados-Registros.html#ejercicio-5","text":"Define un nuevo tipo TRectangulo y a\u00f1ade la misma funcionalidad que para los tri\u00e1ngulos: \u00e1rea y per\u00edmetro.","title":"Ejercicio 5"},{"location":"Teoria/tema06-datos-estructurados-Registros/tema06-datos-estructurados-Registros.html#ejercicio-6","text":"Dada la siguiente definici\u00f3n de tipos de datos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 typedef enum { TRIANGULO , RECTANGULO } TTipoFigura ; typedef struct { int x ; int y ; } TPunto ; typedef struct { TPunto p1 ; TPunto p2 ; TPunto p3 ; float area ; float perimetro ; } TTriangulo ; typedef struct { TPunto p1 ; //esquina inferior izquierda TPunto p2 ; //esquina superior derecha float area ; float perimetro ; } TRectangulo ; typedef struct { TTipoFigura tipo ; union { TTriangulo triangulo ; TRectangulo rectangulo ; } fig ; } TFigura ; Define un array gen\u00e9rico de figuras de tipo TFigura. Podr\u00e1 contener tanto tri\u00e1ngulos como rect\u00e1ngulos. Implementa una funci\u00f3n que reciba dicho array e imprima los datos de la figura que contiene en cada posici\u00f3n. Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares Puig","title":"Ejercicio 6"},{"location":"Teoria/tema07-punteros-y-memoria-dinamica/tema07-punteros-y-memoria-dinamica.html","text":"Tema 7: Punteros y memoria din\u00e1mica \u00b6 Contenidos \u00b6 1. Punteros 1.1 Operadores para el manejo de punteros 1.2 Punteros y arrays 1.3 Punteros a estructuras 2. Gesti\u00f3n de memoria din\u00e1mica 2.1. Memoria din\u00e1mica 2.2. Funciones para gestionar la memoria din\u00e1mica 2.3 Arrays din\u00e1micos multidimensionales 3. Punteros y funciones 4. Arrays de punteros 1. Punteros \u00b6 Ya hemos visto que la memoria del ordenador es el lugar donde se almacenan los datos y las instrucciones de un programa. Se llama memoria RAM, que es diferente a la memoria de almacenamiento como discos duros, etc. Est\u00e1 compuesta por un gran n\u00famero de celdas (bytes) de informaci\u00f3n. A cada una de estas celdas se le asigna una direcci\u00f3n de memoria , que permite distinguir unas celdas de otras. De forma que, dada la direcci\u00f3n de memoria de una celda, se podr\u00e1 obtener su valor actual y modificarlo, como ya hemos visto por ejemplo en el paso de par\u00e1metros por referencia. Cuando se accede a una variable almacenada en memoria el compilador necesita saber: n\u00famero de bytes que componen la variable direcci\u00f3n de memoria del byte inicial de la variable Estos t\u00e9rminos ya los hemos utilizado al definir una variable: la direcci\u00f3n de memoria se representa con el nombre de la variable (el compilador se encarga de sustituir el nombre por su direcci\u00f3n de memoria) El tama\u00f1o se define con el tipo de datos de la variable ( int , char ...). El compilador se encarga de reservar los bytes necesarios. Los punteros son un nuevo tipo de datos. La diferencia con el resto es que los que hemos visto hasta ahora almacenan datos y los punteros almacenan direcciones de memoria . Es decir, hacen referencia a otra zona de memoria donde se encuentran los datos. Se dice que un puntero apunta a un dato. Caracter\u00edsticas: Un puntero es una variable que almacena una direcci\u00f3n de memoria. Una variable contiene siempre un valor (de un tipo). Un puntero contiene la direcci\u00f3n de una variable que contiene un valor. El valor de un puntero es una direcci\u00f3n de memoria. Un puntero puede apuntar a una variable de cualquier tipo: tipos ba\u0301sicos, tipos definidos por el usuario, estructuras de datos, o incluso a funciones. Los punteros se pueden utilizar para referenciar y manipular estructuras de datos, y para referenciar bloques de memoria asignados dina\u0301micamente. Sintaxis: 1 tipo * nombre_variable ; La variable declarada es un puntero al tipo de dato especificado: nombre_variable almacenar\u00e1 la direcci\u00f3n de memoria en la cual se almacenar\u00e1 un dato de ese tipo. Con esa declaraci\u00f3n se reserva memoria S\u00d3LO para el puntero, NUNCA para la variable a la que apunta . Ejemplos: 1 2 3 int * entero ; /* entero es un puntero a int */ float * res ; /* res es un puntero a float */ char * mensaje ; /* mensaje es un puntero a char */ 1.1 Operadores para el manejo de punteros \u00b6 Existen dos operadores unarios para trabajar con punteros: * y & *puntero : operador indirecci\u00f3n. Devuelve el contenido de la direccio\u0301n de memoria apuntado por puntero &variable : operador direcci\u00f3n: Devuelve la direccio\u0301n de memoria de una variable Ejemplo 1: 1 2 3 4 5 6 7 8 9 10 11 int main () { int a = 0 ; //Declaraci\u00f3n de variable entera de tipo entero int * p ; //Declaraci\u00f3n de variable puntero de tipo entero p = & a ; //Asignaci\u00f3n de la direcci\u00f3n memoria de a printf ( \"El valor de a es: %d. \\n El valor de *p es: %d. \\n \" , a , * p ); printf ( \"La direccion de memoria de *p es: %p \\n \" , p ); return 0 ; } Ejemplo 2: 1 2 3 4 5 6 7 8 9 int y , * yPtr ; /* yPtr es puntero a entero */ y = 5 ; yPtr = & y ; /* yPtr toma la direcci\u00f3n de y */ printf ( \"y: %d, yPtr: %p, &y: %p, &yPtr: %p, *yPtr: %d \\n \" , y , yPtr , & y , & yPtr , * yPtr ); /* Salida por pantalla: y: 5, yPtr: 0x7fff5d9829ec (1050), &y: 0x7fff5d9829ec (1050), &yPtr: 0x7fff5d9829e0 (1200), *yPtr: 5 */ Una variable se refiere directamente a un valor y un puntero se refiere indirectamente a un valor. El puntero, al tener una direcci\u00f3n de memoria es como si apuntara a dicha direcci\u00f3n. Las direcciones de memoria de cada variable las asigna el sistema operativo y el programa no puede ni cambiarlas ni usar otras posiciones distintas. Ejemplo 3: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void main () { int x , y , * py ; printf ( \" \\n - Introduzca un n\u00famero: \" ); scanf ( \"%i\" , & y ); py = & y ; x = * py + 10 ; /* Suma 10 con el contenido de la direcci\u00f3n py */ printf ( \" \\n - Enteros: %d, %d y %d.\" , y , * py , x ); printf ( \" \\n - Direcciones: %p y %p.\" , & y , py ); } /* Salida por pantalla: - Introduzca un n\u00famero: 4 - Enteros: 4, 4 y 14. - Direcciones: 0x7fff5afeb9e8 y 0x7fff5afeb9e8 */ Ejemplo 4: 1 2 3 4 5 6 7 8 9 10 11 int * punteroInt ; int valor = 8 ; punteroInt = & valor ; printf ( \"Puntero: dir: %p, valor: %d, referencia: %p \\n \" , punteroInt , * punteroInt , & punteroInt ); printf ( \"Variable: valor: %d, referencia: %p \\n \" , valor , & valor ); /* Salida por pantalla: Puntero: dir: 0x7fff523e19e4, valor: 8, referencia:0x7fff523e19e8 Variable: valor: 8, referencia: 0x7fff523e19e4 */ Muchas de las funciones est\u00e1ndares de C trabajan con punteros, como es el caso del scanf . A scanf se le pasa la direcci\u00f3n de memoria del dato a leer. 1 2 char a ; scanf ( \"%c\" , & a ); Ejemplo 5: El siguiente programa muestra el concepto de creaci\u00f3n, inicializaci\u00f3n e indirecci\u00f3n de una variable puntero: 1 2 3 4 5 6 7 8 9 10 11 int main () { char c ; char * pc ; pc = & c ; for ( c = 'A' ; c <= 'Z' ; c ++ ) printf ( \"%c \" , * pc ); } //Salida: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z Punteros a punteros Un puntero puede apuntar a otra variable puntero. Este concepto se utiliza mucho en programas complejos en C y en la definici\u00f3n de estructuras de datos multidimensionales. Para declarar un puntero a un puntero se precede a la variable con dos asteriscos ** . Ejemplo: 1 2 3 int valor = 100 ; int * ptr1 = & valor ; int ** ptr5 = & ptr1 ; ptr1 y ptr5 son punteros. ptr1 apunta a la variable valor de tipo int . ptr5 contiene la direcci\u00f3n de ptr1 . Se pueden asignar valores a valor con cualquiera de las siguientes sentencias: 1 2 3 valor = 95 ; * ptr1 = 105 ; // Asigna 105 a valor ** ptr5 = 99 ; // Asigna 99 a valor 1.2 Punteros y arrays \u00b6 En C los punteros y los arrays est\u00e1n fuertemente relacionados. Se pueden direccionar arrays como si fueran punteros y punteros como si fueran arrays. Nombres de arrays como punteros El nombre de un vector es en s\u00ed mismo un puntero a la primera posici\u00f3n del vector. Todas las operaciones que utilizan vectores e \u00edndices pueden realizarse mediante punteros. 1 int v [ 10 ]; v : designa 10 posiciones consecutivas de memoria donde se pueden almacenar enteros. Si visualizamos v[0] veremos 1. \u00bfY si visualizamos *v ? Como el nombre del array tambi\u00e9n es un puntero, tambi\u00e9n se ver\u00e1 1. Esto significa que: 1 2 3 4 5 v + 0 apunta a v [ 0 ] v + 1 apunta a v [ 1 ] v + 2 apunta a v [ 2 ] v + 3 apunta a v [ 3 ] ... Por tanto, para manejar los elementos de un array, se puede utilizar la notaci\u00f3n de sub\u00edndices o la notaci\u00f3n de punteros. Dado que el nombre del array contiene la direcci\u00f3n del primer elemento del array, se debe indireccionar el puntero para obtener el valor del elemento. Arrays de caracteres Podemos hacer un array de caracteres usando punteros. 1 2 char * nombre = \"Hola que tal\" ; //Es una cadena de 13 caracteres (12 + '\\0') printf ( \"%s\" , nombre ); Realmente se define como una constante de caracteres y no podemos modificarla despues de definir sus valores. Como por ejemplo no podemos reemplazar un car\u00e1cter, o leer un nuevo valor. 1 2 //Error de ejecuci\u00f3n: strcpy ( nombre , \"hola\" ); Se soluciona utilizando memoria din\u00e1mica (lo veremos m\u00e1s adelante). 1.3 Punteros a estructuras \u00b6 Un puntero tambi\u00e9n puede apuntar a un registro. Se puede declarar el puntero a una estructura tal y como se declara un puntero a cualquier otro tipo. 1 2 3 4 5 6 7 8 9 typedef struct { int x ; int y ; } TPunto ; typedef struct { TPunto * p1 ; TPunto * p2 ; } TSegmento ; TSegmento tiene como campos dos punteros a TPunto . Ejemplo completo, donde dos segmentos comparten el mismo punto: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 typedef struct { int x ; int y ; } TPunto ; typedef struct { TPunto * p1 ; TPunto * p2 ; } TSegmento ; void imprimeSegmento ( TSegmento s ); int main () { TPunto a = { 2 , 3 }; TPunto b = { 10 , 10 }; TPunto c = { 5 , 6 }; TPunto d = { 9 , 12 }; TSegmento s1 , s2 ; s1 . p1 = & a ; s1 . p2 = & b ; s2 . p1 = & b ; s2 . p2 = & c ; imprimeSegmento ( s1 ); imprimeSegmento ( s2 ); // P1: [2,3] P2: [10,10] // P1: [10,10] P2: [5,6] } En el ejemplo anterior, los segmentos s1 y s2 comparten el punto b. Si \u00e9ste cambiase, afectar\u00eda a los dos puntos, porque apuntan al mismo punto. Al referenciar al mismo punto y no ser una copia, al modificar uno de los dos, el otro se modifica. 1 2 3 4 5 6 7 8 9 10 11 12 // Seguimos con el c\u00f3digo anterior // Modificamos el punto compartido por ambos segmentos // Cambiamos el p2 del s1: s1 . p2 -> x = 100 ; s1 . p2 -> y = 100 ; imprimeSegmento ( s1 ); imprimeSegmento ( s2 ); // P1: [2,3] P2: [100,100] // P1: [100,100] P2: [5,6] Como podemos observar, cambiando p2 de s1 hace que cambie tambi\u00e9n el p1 de s2. Esto sucede porque est\u00e1n compartiendo una referencia al mismo punto, no son copias. Esta es la filosof\u00eda de funcionamiento en otros lenguajes, como Java, donde se utiliza el paradigma de programaci\u00f3n orientado a objetos. 2. Gesti\u00f3n de memoria din\u00e1mica \u00b6 2.1 Memoria din\u00e1mica \u00b6 La memoria est\u00e1tica es el espacio en memoria que se crea al declarar variables de cualquier tipo de dato. La memoria que estas variables ocupan no puede cambiarse durante la ejecuci\u00f3n y tampoco puede ser liberada manualmente. La memoria din\u00e1mica es memoria que se reserva en tiempo de ejecuci\u00f3n. Su principal ventaja frente a la est\u00e1tica, es que su tama\u00f1o puede variar durante la ejecuci\u00f3n del programa. En C, el programador es encargado de liberar esta memoria cuando no la utilice m\u00e1s. El uso de memoria din\u00e1mica es necesario cuando a priori no conocemos el n\u00famero de datos o elementos a tratar o cuando queremos optimizarla. Definimos las variables din\u00e1micas como zonas de memoria que pueden reservarse y liberarse durante el transcurso del programa. La \u00fanica forma de acceder a su contenido es mediante una variable puntero que almacene la direcci\u00f3n de memoria correspondiente. Las variables din\u00e1micas se guardan en la zona de memoria din\u00e1mica y se gestionan con las funciones de memoria din\u00e1mica ( malloc , calloc , realloc, free`). 2.2 Funciones para gestionar la memoria din\u00e1mica \u00b6 La biblioteca est\u00e1ndar de C proporciona las funciones malloc , calloc , realloc y free para el manejo de memoria din\u00e1mica. Estas funciones est\u00e1n definidas la librer\u00eda stdlib.h . malloc La funci\u00f3n malloc reserva un bloque de memoria y devuelve un puntero al inicio de la misma. Sintaxis: 1 void * malloc ( size_t size ); donde el par\u00e1metro size especifica el n\u00famero de bytes a reservar. En caso de que no se pueda realizar la asignaci\u00f3n, devuelve el valor nulo (definido en la macro NULL ), lo que permite saber si hubo errores en la asignaci\u00f3n de memoria. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <stdlib.h> int main () { int * vect1 , n ; printf ( \"N\u00famero de elementos del vector: \" ); scanf ( \"%d\" , & n ); /* reservamos memoria para almacenar n enteros */ vect1 = ( int * ) malloc ( n * sizeof ( int )); /* Verificamos que la asignaci\u00f3n se haya realizado correctamente */ if ( vect1 == NULL ) { /* Error al intentar reservar memoria */ } } El operador sizeof(tipo) nos devuelve el nu\u0301mero de bytes que ocupa el tipo de dato pasado como para\u0301metro. Uno de los usos m\u00e1s comunes de la memoria din\u00e1mica es la creaci\u00f3n de vectores/matrices cuyo n\u00famero de elementos se define en tiempo de ejecuci\u00f3n. calloc La funci\u00f3n calloc funciona de modo similar a malloc , pero adem\u00e1s de reservar memoria, inicializa a 0 la memoria reservada. Sintaxis: 1 void * calloc ( size_t num , size_t size ); Devuelve un puntero a una zona de memoria en la que se reservan num elementos de size bytes. La memoria se inicializa a 0. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <stdlib.h> #define TAM = 25 int main () { float * vectorFloat ; vectorFloat = ( float * ) calloc ( TAM , sizeof ( float )); /* Verificamos que la asignaci\u00f3n se haya realizado correctamente */ if ( vectorFloat == NULL ) { /* Error al intentar reservar memoria */ ... } } realloc La funci\u00f3n realloc redimensiona el espacio asignado de forma din\u00e1mica anteriormente a un puntero. Sintaxis: 1 void * realloc ( void * ptr , size_t size ); Donde ptr es el puntero a redimensionar, y size el nuevo tama\u00f1o, en bytes, que tendr\u00e1. Si el puntero que se le pasa tiene el valor NULL , esta funci\u00f3n act\u00faa como malloc . Si la reasignaci\u00f3n no se pudo hacer con \u00e9xito, devuelve un puntero nulo. 1 2 3 4 5 6 7 8 9 #include <stdlib.h> #define TAM = 20 int main () { float * vectorFloat ; vectorFloat = ( float * ) malloc ( sizeof ( float ) * TAM ); vectorFloat = ( float * ) realloc ( vectorFloat , sizeof ( float ) * 50 ); } 1 2 3 4 5 int main () { float * vectorFloat ; vectorFloat = NULL ; vectorFloat = ( float * ) realloc ( vectorFloat , sizeof ( float ) * 50 ); } Cuando se redimensiona la memoria con realloc , si el nuevo tama\u00f1o es mayor que el anterior, se conservan todos los valores originales, quedando los bytes restantes sin inicializar. Si el nuevo tama\u00f1o es menor, se conservan los valores de los primeros size bytes. Los restantes tambi\u00e9n se dejan intactos, pero no son parte del bloque que devuelve la funci\u00f3n. free La funci\u00f3n free sirve para liberar memoria que se asign\u00f3 din\u00e1micamente. Requiere como par\u00e1metro la direcci\u00f3n de memoria inicial de una zona de memoria reservada en la memoria din\u00e1mica (tal cual se reserv\u00f3 con malloc o realloc ). La funci\u00f3n free se encarga de marcar como libre esta memoria. Si el puntero es nulo, free no hace nada. Adem\u00e1s existe la funci\u00f3n cfree , que sirve para liberar memoria de los elementos que han sido reservados con calloc . Sintaxis: 1 2 void free ( void * ptr ); void cfree ( void * ptr ); Libera la memoria reservada para el puntero ptr No se ejecuta automa\u0301ticamente cuando se acaba el a\u0301mbito en el que se definio\u0301 el puntero Las llamadas a free han de ser expli\u0301citas NULL NULL hace referencia a una direccio\u0301n de memoria nula, no va\u0301lida Lo utilizamos cuando queremos indicar que un puntero no tiene memoria reservada o la que teni\u0301a ya ha sido liberada por medio de una llamada a free() NULL es tambie\u0301n el valor devuelto por funciones que han de devolver un puntero cuando no pueden realizar su labor. [m|c|re]alloc devuelven NULL cuando no hay memoria disponible 1 2 3 4 5 6 7 8 9 10 11 #include <stdlib.h> #define TAM = 20 int main () { float * vectorFloat ; vectorFloat = ( float * ) malloc ( sizeof ( float ) * TAM ); ... free ( vectorFloat ); vectorFloat = NULL ; } 2.3 Arrays din\u00e1micos multidimensionales \u00b6 Para definir un array multidimensional de manera dina\u0301mica utilizaremos punteros a punteros. En este caso vamos a definir una matriz de dos dimensiones: 1 int ** tabla2D // un puntero por cada dimensi\u00f3n Se interpreta como un puntero a un tipo que es un puntero a un entero 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include <stdlib.h> #define X 5 #define Y 7 void rellenarTabla2D ( int ** ); int main () { int ** tabla2D ; int dim1 , dim2 ; // Reservamos la memoria tabla2D = ( int ** ) malloc ( sizeof ( int * ) * X ); for ( dim1 = 0 ; dim1 < X ; dim1 ++ ){ tabla2D [ dim1 ] = ( int * ) malloc ( sizeof ( int ) * Y ); for ( dim2 = 0 ; dim2 < Y ; dim2 ++ ){ tabla2D [ dim1 ][ dim2 ] = 0 ; } } // Rellenamos sus valores en una funci\u00f3n rellenarTabla2D ( tabla2D ); printf ( \"%d \\n \" , tabla2D [ 2 ][ 3 ]); // comprobamos una posici\u00f3n al azar //Liberamos la memoria de la tabla3D for ( dim1 = 0 ; dim1 < X ; dim1 ++ ) free ( tabla2D [ dim1 ]); free ( tabla2D ); tabla2D = NULL ; } void rellenarTabla2D ( int ** tabla ) { int x , y ; for ( x = 0 ; x < X ; x ++ ){ for ( y = 0 ; y < Y ; y ++ ){ tabla [ x ][ y ] = 100 ; } } } 3. Punteros y funciones \u00b6 Uno de los usos de los punteros es el paso de par\u00e1metros por referencia a una funci\u00f3n. Recordemos que los par\u00e1metros de una funci\u00f3n se pueden pasar por valor o por referencia. En C todos los par\u00e1metros de las funciones se pasan por valor. Para simular un paso de par\u00e1metro por referencia en C, lo que se hace es pasar un puntero al objeto que se pasa. As\u00ed, la funci\u00f3n tiene acceso no s\u00f3lo al valor del par\u00e1metro sino tambi\u00e9n a su situaci\u00f3n en memoria, lo que permite su modificaci\u00f3n. Ya vimos que para que un par\u00e1metro de una funci\u00f3n pueda ser modificado, ha de pasarse por referencia, y en C eso s\u00f3lo es posible pasando la direcci\u00f3n de la variable en lugar de la propia variable. Si se pasa la direcci\u00f3n de una variable, la funci\u00f3n puede modificar el contenido de esa posici\u00f3n (no as\u00ed la propia direcci\u00f3n, que es una copia) Arrays y matrices como par\u00e1metro \u00b6 Paso de par\u00e1metros por valor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void funcion ( char * cad ) { printf ( \"Funci\u00f3n. Valor: %s, Direcci\u00f3n: %p, Referencia: %p \\n \" , cad , cad , & cad ); } int main () { // Definimos una cadena de caracteres constante char * cadena = { \"Hola mundo\" }; printf ( \"Main. Valor: %s, Direcci\u00f3n: %p, Referencia: %p \\n \" , cadena , cadena , & cadena ); funcion ( cadena ); } /* Salida por pantalla: Main. Valor: Hola mundo, Direcci\u00f3n: 0x1046e0f77, Referencia: 0x7fff5b51f9e8 Funci\u00f3n. Valor: Hola mundo, Direcci\u00f3n: 0x1046e0f77, Referencia: 0x7fff5b51f9c8 */ Como vemos, en funcion hay una referencia a los elementos del array pero no al puntero en si\u0301, que es una copia. Es decir, no podr\u00edamos modificar din\u00e1micamente su memoria porque no tenemos una referencia a la misma. Paso de par\u00e1metros por referencia \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void funcionRef ( char ** cad ) { printf ( \"Funci\u00f3n. Valor: %s, Direcci\u00f3n: %p, Referencia: %p \\n \" , * cad , * cad , cad ); } int main () { char * cadena = { \"Hola mundo\" }; printf ( \"Main. Valor: %s, Direcci\u00f3n: %p, Referencia: %p \\n \" , cadena , cadena , & cadena ); funcionRef ( & cadena ); } /* Salida por pantalla: Main. Valor: Hola mundo, Direcci\u00f3n: 0x10861af77, Referencia: 0x7fff575e59e8 Funci\u00f3n. Valor: Hola mundo, Direcci\u00f3n: 0x10861af77, Referencia: 0x7fff575e59e8 */ Ahora tenemos referencia a los datos y al propio puntero con lo que podemos modificar la memoria que tiene reservada. Ejemplo con vector: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #define TAM 20 void creaVector ( int ** ); int main () { int * vector ; // Reservamos la memoria creaVector ( & vector ); vector [ 0 ] = 1 ; //Rellenamos al azar vector [ 2 ] = 2 ; printf ( \"Pos 2: %d \\n \" , vector [ 2 ]); //Comprobamos // Liberamos memoria free ( vector ); vector = NULL ; } void creaVector ( int ** v ) { * v = ( int * ) malloc ( sizeof ( int ) * TAM ); } Devoluci\u00f3n de punteros \u00b6 Una funci\u00f3n tambi\u00e9n puede devolver un tipo de datos puntero. La funci\u00f3n se declara as\u00ed: 1 < tipo *> funcion ( < argumentos > ); Este tipo de funciones se suelen usar para reservar memoria o crear elementos en estructuras din\u00e1micas de datos. En el ejemplo anterior, la reserva de memoria din\u00e1mica del vector tambi\u00e9n podr\u00eda hacerse as\u00ed: 1 2 3 4 5 6 int * creaVector () { int * v ; v = ( int * ) malloc ( sizeof ( int ) * TAM ); return v ; } Ejercicio: Dado un TPunto, define una estructura que contenga un array din\u00e1mico de puntos y la cantidad de puntos que contiene. S\u00f3lo se debe reservar la memoria necesaria. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 typedef struct { int x ; int y ; } TPunto ; typedef struct { int num ; TPunto * puntos ; } TPuntos ; TPuntos rellenaLista (); int main () { TPuntos puntos ; puntos = rellenaLista (); //Funci\u00f3n para imprimir los puntos free ( puntos . puntos ); } TPuntos rellenaLista () { TPuntos lista ; bool fin ; int x , y , n ; fin = false ; n = 0 ; lista . puntos = NULL ; lista . num = 0 ; printf ( \"Introduce puntos hasta introducir -1 -1 \\n \" ); while ( ! fin ) { scanf ( \"%d %d\" , & x , & y ); if ( x != - 1 && y != - 1 ) { lista . puntos = ( TPunto * ) realloc ( lista . puntos , sizeof ( TPunto ) * ( n + 1 )); lista . puntos [ n ]. x = x ; lista . puntos [ n ]. y = y ; n ++ ; } else fin = true ; } lista . num = n ; return lista ; } En el siguiente ejemplo modificamos la funci\u00f3n rellenaLista y le pasamos por par\u00e1metro por referencia TPuntos lista. \u00bfQu\u00e9 sucede si quitamos los par\u00e9ntesis de (*lista) ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void rellenaLista ( TPuntos * lista ) { bool fin ; int x , y , n ; fin = false ; n = 0 ; ( * lista ). puntos = NULL ; ( * lista ). num = 0 ; printf ( \"Introduce puntos hasta introducir -1 -1 \\n \" ); while ( ! fin ) { scanf ( \"%d %d\" , & x , & y ); if ( x != - 1 && y != - 1 ) { ( * lista ). puntos = ( TPunto * ) realloc (( * lista ). puntos , sizeof ( TPunto ) * ( n + 1 )); ( * lista ). puntos [ n ]. x = x ; ( * lista ). puntos [ n ]. y = y ; n ++ ; } else fin = true ; } ( * lista ). num = n ; } 4. Arrays de punteros \u00b6 Si se necesita reservar muchos punteros o gestionar de forma m\u00e1s eficiente la memoria, se puede declarar un array de punteros. Un array de punteros es un array cuyos elementos son punteros. Ejemplo: 1 int * a [ 10 ]; // Array de 10 punteros a enteros Cada elemento contiene una direcci\u00f3n que apunta a otras posiciones de memoria. Cada valor apuntado en este caso debe ser un entero.. Ejemplo: 1 2 a [ 5 ] = & edad ; // a[5] apunta a la direcci\u00f3n de edad a [ 4 ] = NULL ; // a[4] no contiene direcci\u00f3n Podemos crear arrays de punteros a cualquier tipo: arrays de punteros a cadenas, a registros, etc. Ejemplo de array de punteros a registro Siguiendo con el ejemplo de los puntos y los segmentos, vamos definir un array de punteros a segmento: 1 2 3 4 5 TSegmento * segmentos [ 100 ]; TSegmento s1 , s2 ; segmentos [ 0 ] = & s1 ; segmentos [ 1 ] = & s2 ; Reserva din\u00e1mica de memoria de un registro En el caso anterior, los segmentos s1 y s2 los tenemos definidos de forma est\u00e1tica. Pero tambi\u00e9n podr\u00edamos haberlo hecho de forma din\u00e1mica: 1 2 3 4 5 6 7 8 TSegmento * segmentos [ 100 ]; //array est\u00e1tico de punteros a registro TSegmento * s ; // Reservando una zona de memoria din\u00e1mica: s = ( TSegmento * ) malloc ( sizeof ( TSegmento )); segmentos [ 0 ] = s ; ... // Despu\u00e9s de su uso hay que liberar la memoria: free ( s ); Ejercicio: Modifica el array est\u00e1tico anterior y hazlo din\u00e1mico Tambi\u00e9n podemos reservar la memoria din\u00e1mica dentro de una funci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 //Funciones para reservar memoria de dos formas diferentes: TSegmento * creaSegmento (); void creaPunto ( TPunto ** ); // Pasamos por referencia el puntero a TPunto int main () { TSegmento * s = NULL ; TPunto * p1 = NULL ; TPunto * p2 = NULL ; // Reservar memoria s = creaSegmento (); creaPunto ( & p1 ); creaPunto ( & p2 ); // Resto del c\u00f3digo s -> p1 = p1 ; s -> p2 = p2 ; p1 -> x = 4 ; // Modificamos los puntos p1 -> y = 5 ; // Por tanto, se modifica el segmento p2 -> x = 6 ; // Porque apuntan al mismo \"objeto\" p2 -> y = 7 ; imprimeSegmento ( * s ); // Liberar memoria free ( p1 ); free ( p2 ); free ( s ); s = NULL ; p1 = NULL ; p2 = NULL ; } TSegmento * creaSegmento () { TSegmento * s ; s = ( TSegmento * ) malloc ( sizeof ( TSegmento )); return s ; } void creaPunto ( TPunto ** p ) { * p = ( TPunto * ) malloc ( sizeof ( TPunto )); } Ejercicios resueltos \u00b6 Ejercicio 1: Array din\u00e1mico de registros \u00b6 Escribe un programa que guarde informacio\u0301n de veh\u00edculos. De cada veh\u00edculo interesa almacenar la matr\u00edcula, la marca, el propietario y el precio. Del propietario guardaremos sus datos personales: nombre, direcci\u00f3n, tel\u00e9fono y nif. Se almacenar\u00e1n en un array din\u00e1mico que ir\u00e1 aumentando conforme se vayan a\u00f1adiendo coches. Despu\u00e9s responde a las siguientes preguntas: \u00bfQu\u00e9 sucede si no inicializamos el array a NULL? Si hacemos el realloc en el main , \u00bfqu\u00e9 habr\u00eda que cambiar? \u00bfPor qu\u00e9? Prueba a no pasar el vector por referencia a nuevoCoche. Qu\u00e9 sucede? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #define TAMCAD 15 typedef struct { char nombre [ TAMCAD ]; char nif [ TAMCAD ]; } TPersona ; typedef struct { char matricula [ TAMCAD ]; char marca [ TAMCAD ]; float precio ; TPersona propietario ; } TFichaCoche ; typedef TFichaCoche * TCoches ; // Array din\u00e1mico de tipo TFichaCoche void nuevoCoche ( TCoches * , int * ); void muestraCoches ( TCoches , int ); int main () { TCoches coches ; // Array din\u00e1mico que va aumentando conforme se a\u00f1aden coches int numCoches = 0 , i ; coches = NULL ; //Necesario si no inicializamos el puntero con malloc // Probamos: a\u00f1adimos 3 coches for ( i = 0 ; i < 3 ; i ++ ) { nuevoCoche ( & coches , & numCoches ); } // Los mostramos muestraCoches ( coches , numCoches ); // Liberamos memoria free ( coches ); } void nuevoCoche ( TCoches * coches , int * numCoches ) { int num ; * coches = ( TFichaCoche * ) realloc ( * coches , sizeof ( TFichaCoche ) * ( num + 1 )); num = * numCoches ; printf ( \"**** Coche %d **** \\n \" , num ); printf ( \"Introduce matr\u00edcula: \" ); scanf ( \"%s\" ,( * coches )[ num ]. matricula ); printf ( \"Introduce marca: \" ); scanf ( \" \\n %[^ \\n ]s\" ,( * coches )[ num ]. marca ); printf ( \"Introduce precio: \" ); scanf ( \"%f\" , & ( * coches )[ num ]. precio ); // propietario printf ( \"Nombre propietario: \" ); scanf ( \" \\n %[^ \\n ]s\" ,( * coches )[ num ]. propietario . nombre ); printf ( \"NIF propietario: \" ); scanf ( \" \\n %s\" , ( * coches )[ num ]. propietario . nif ); ( * numCoches ) ++ ; } void muestraCoches ( TCoches coches , int num ) { int i ; for ( i = 0 ; i < num ; i ++ ) { printf ( \"*********************** \\n \" ); printf ( \"Matr\u00edcula: %s \\n \" , coches [ i ]. matricula ); printf ( \"Marca: %s \\n \" , coches [ i ]. marca ); printf ( \"Precio: %f \\n \" , coches [ i ]. precio ); printf ( \"Propietario: %s con nif: %s \\n \" , coches [ i ]. propietario . nombre , coches [ i ]. propietario . nif ); printf ( \"*********************** \\n \" ); } } Ejercicio 2: Tabla 3D definida con typedef \u00b6 Como hemos visto en temas anteriores, definir tipos propios con typedef resulta muy \u00fatil. Veamos el ejemplo de un array multidimensional de 3 dimensiones tabla3D usando typedef : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #define X 5 #define Y 7 #define Z 20 typedef int *** TTabla3D ; TTabla3D crearTabla3D (); void freeTabla3D ( TTabla3D ); void rellenarTabla3D ( TTabla3D ); int main () { TTabla3D tabla3D ; tabla3D = crearTabla3D (); if ( tabla3D ) { // Comprobamos que malloc no haya devuelto NULL rellenarTabla3D ( tabla3D ); printf ( \"%d \\n \" , tabla3D [ 2 ][ 3 ][ 1 ]); // comprobamos una posici\u00f3n al azar freeTabla3D ( tabla3D ); tabla3D = NULL ; // Si queremos poner tabla3D = NULL dentro de la funci\u00f3n // freeTabla3D, tenemos que pasar el puntero tabla3D por // referencia para poder modificarlo } } TTabla3D crearTabla3D () { TTabla3D tabla3D ; //ser\u00e1 de 5x7x20 int dim1 , dim2 , dim3 ; tabla3D = ( int *** ) malloc ( sizeof ( int ** ) * X ); for ( dim1 = 0 ; dim1 < X ; dim1 ++ ){ tabla3D [ dim1 ] = ( int ** ) malloc ( sizeof ( int * ) * Y ); for ( dim2 = 0 ; dim2 < Y ; dim2 ++ ){ tabla3D [ dim1 ][ dim2 ] = ( int * ) malloc ( sizeof ( int ) * Z ); for ( dim3 = 0 ; dim3 < Z ; dim3 ++ ){ tabla3D [ dim1 ][ dim2 ][ dim3 ] = 0 ; /*inicializaci\u00f3n*/ } } } return tabla3D ; } void freeTabla3D ( TTabla3D tabla ) { int dim1 , dim2 , dim3 ; for ( dim1 = 0 ; dim1 < X ; dim1 ++ ){ for ( dim2 = 0 ; dim2 < Y ; dim2 ++ ){ free ( tabla [ dim1 ][ dim2 ]); } free ( tabla [ dim1 ]); } free ( tabla ); } void rellenarTabla3D ( TTabla3D tabla ) { int dim1 , dim2 , dim3 ; for ( dim1 = 0 ; dim1 < X ; dim1 ++ ){ for ( dim2 = 0 ; dim2 < Y ; dim2 ++ ){ for ( dim3 = 0 ; dim3 < Z ; dim3 ++ ){ tabla [ dim1 ][ dim2 ][ dim3 ] = 100 ; } } } } La funci\u00f3n crearTabla3D tambi\u00e9n se puede hacer pasando la tabla3D por referencia para poder reservar la memoria din\u00e1micamente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void crear2Tabla3D ( TTabla3D * ); ... int main () { ... crear2Tabla3D ( & tabla3D ); ... } void crear2Tabla3D ( TTabla3D * tabla3D ) { int dim1 , dim2 , dim3 ; * tabla3D = ( int *** ) malloc ( sizeof ( int ** ) * X ); for ( dim1 = 0 ; dim1 < X ; dim1 ++ ){ ( * tabla3D )[ dim1 ] = ( int ** ) malloc ( sizeof ( int * ) * Y ); for ( dim2 = 0 ; dim2 < Y ; dim2 ++ ){ ( * tabla3D )[ dim1 ][ dim2 ] = ( int * ) malloc ( sizeof ( int ) * Z ); for ( dim3 = 0 ; dim3 < Z ; dim3 ++ ){ ( * tabla3D )[ dim1 ][ dim2 ][ dim3 ] = 0 ; /*inicializaci\u00f3n*/ } } } } Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares Puig","title":"Tema 7: Punteros y memoria din\u00e1mica"},{"location":"Teoria/tema07-punteros-y-memoria-dinamica/tema07-punteros-y-memoria-dinamica.html#tema-7-punteros-y-memoria-dinamica","text":"","title":"Tema 7: Punteros y memoria din\u00e1mica"},{"location":"Teoria/tema07-punteros-y-memoria-dinamica/tema07-punteros-y-memoria-dinamica.html#contenidos","text":"1. Punteros 1.1 Operadores para el manejo de punteros 1.2 Punteros y arrays 1.3 Punteros a estructuras 2. Gesti\u00f3n de memoria din\u00e1mica 2.1. Memoria din\u00e1mica 2.2. Funciones para gestionar la memoria din\u00e1mica 2.3 Arrays din\u00e1micos multidimensionales 3. Punteros y funciones 4. Arrays de punteros","title":"Contenidos"},{"location":"Teoria/tema07-punteros-y-memoria-dinamica/tema07-punteros-y-memoria-dinamica.html#arrays-y-matrices-como-parametro","text":"","title":"Arrays y matrices como par\u00e1metro"},{"location":"Teoria/tema07-punteros-y-memoria-dinamica/tema07-punteros-y-memoria-dinamica.html#paso-de-parametros-por-referencia","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void funcionRef ( char ** cad ) { printf ( \"Funci\u00f3n. Valor: %s, Direcci\u00f3n: %p, Referencia: %p \\n \" , * cad , * cad , cad ); } int main () { char * cadena = { \"Hola mundo\" }; printf ( \"Main. Valor: %s, Direcci\u00f3n: %p, Referencia: %p \\n \" , cadena , cadena , & cadena ); funcionRef ( & cadena ); } /* Salida por pantalla: Main. Valor: Hola mundo, Direcci\u00f3n: 0x10861af77, Referencia: 0x7fff575e59e8 Funci\u00f3n. Valor: Hola mundo, Direcci\u00f3n: 0x10861af77, Referencia: 0x7fff575e59e8 */ Ahora tenemos referencia a los datos y al propio puntero con lo que podemos modificar la memoria que tiene reservada. Ejemplo con vector: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #define TAM 20 void creaVector ( int ** ); int main () { int * vector ; // Reservamos la memoria creaVector ( & vector ); vector [ 0 ] = 1 ; //Rellenamos al azar vector [ 2 ] = 2 ; printf ( \"Pos 2: %d \\n \" , vector [ 2 ]); //Comprobamos // Liberamos memoria free ( vector ); vector = NULL ; } void creaVector ( int ** v ) { * v = ( int * ) malloc ( sizeof ( int ) * TAM ); }","title":"Paso de par\u00e1metros por referencia"},{"location":"Teoria/tema07-punteros-y-memoria-dinamica/tema07-punteros-y-memoria-dinamica.html#devolucion-de-punteros","text":"Una funci\u00f3n tambi\u00e9n puede devolver un tipo de datos puntero. La funci\u00f3n se declara as\u00ed: 1 < tipo *> funcion ( < argumentos > ); Este tipo de funciones se suelen usar para reservar memoria o crear elementos en estructuras din\u00e1micas de datos. En el ejemplo anterior, la reserva de memoria din\u00e1mica del vector tambi\u00e9n podr\u00eda hacerse as\u00ed: 1 2 3 4 5 6 int * creaVector () { int * v ; v = ( int * ) malloc ( sizeof ( int ) * TAM ); return v ; } Ejercicio: Dado un TPunto, define una estructura que contenga un array din\u00e1mico de puntos y la cantidad de puntos que contiene. S\u00f3lo se debe reservar la memoria necesaria. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 typedef struct { int x ; int y ; } TPunto ; typedef struct { int num ; TPunto * puntos ; } TPuntos ; TPuntos rellenaLista (); int main () { TPuntos puntos ; puntos = rellenaLista (); //Funci\u00f3n para imprimir los puntos free ( puntos . puntos ); } TPuntos rellenaLista () { TPuntos lista ; bool fin ; int x , y , n ; fin = false ; n = 0 ; lista . puntos = NULL ; lista . num = 0 ; printf ( \"Introduce puntos hasta introducir -1 -1 \\n \" ); while ( ! fin ) { scanf ( \"%d %d\" , & x , & y ); if ( x != - 1 && y != - 1 ) { lista . puntos = ( TPunto * ) realloc ( lista . puntos , sizeof ( TPunto ) * ( n + 1 )); lista . puntos [ n ]. x = x ; lista . puntos [ n ]. y = y ; n ++ ; } else fin = true ; } lista . num = n ; return lista ; } En el siguiente ejemplo modificamos la funci\u00f3n rellenaLista y le pasamos por par\u00e1metro por referencia TPuntos lista. \u00bfQu\u00e9 sucede si quitamos los par\u00e9ntesis de (*lista) ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void rellenaLista ( TPuntos * lista ) { bool fin ; int x , y , n ; fin = false ; n = 0 ; ( * lista ). puntos = NULL ; ( * lista ). num = 0 ; printf ( \"Introduce puntos hasta introducir -1 -1 \\n \" ); while ( ! fin ) { scanf ( \"%d %d\" , & x , & y ); if ( x != - 1 && y != - 1 ) { ( * lista ). puntos = ( TPunto * ) realloc (( * lista ). puntos , sizeof ( TPunto ) * ( n + 1 )); ( * lista ). puntos [ n ]. x = x ; ( * lista ). puntos [ n ]. y = y ; n ++ ; } else fin = true ; } ( * lista ). num = n ; }","title":"Devoluci\u00f3n de punteros"},{"location":"Teoria/tema07-punteros-y-memoria-dinamica/tema07-punteros-y-memoria-dinamica.html#ejercicios-resueltos","text":"","title":"Ejercicios resueltos"},{"location":"Teoria/tema07-punteros-y-memoria-dinamica/tema07-punteros-y-memoria-dinamica.html#ejercicio-1-array-dinamico-de-registros","text":"Escribe un programa que guarde informacio\u0301n de veh\u00edculos. De cada veh\u00edculo interesa almacenar la matr\u00edcula, la marca, el propietario y el precio. Del propietario guardaremos sus datos personales: nombre, direcci\u00f3n, tel\u00e9fono y nif. Se almacenar\u00e1n en un array din\u00e1mico que ir\u00e1 aumentando conforme se vayan a\u00f1adiendo coches. Despu\u00e9s responde a las siguientes preguntas: \u00bfQu\u00e9 sucede si no inicializamos el array a NULL? Si hacemos el realloc en el main , \u00bfqu\u00e9 habr\u00eda que cambiar? \u00bfPor qu\u00e9? Prueba a no pasar el vector por referencia a nuevoCoche. Qu\u00e9 sucede? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #define TAMCAD 15 typedef struct { char nombre [ TAMCAD ]; char nif [ TAMCAD ]; } TPersona ; typedef struct { char matricula [ TAMCAD ]; char marca [ TAMCAD ]; float precio ; TPersona propietario ; } TFichaCoche ; typedef TFichaCoche * TCoches ; // Array din\u00e1mico de tipo TFichaCoche void nuevoCoche ( TCoches * , int * ); void muestraCoches ( TCoches , int ); int main () { TCoches coches ; // Array din\u00e1mico que va aumentando conforme se a\u00f1aden coches int numCoches = 0 , i ; coches = NULL ; //Necesario si no inicializamos el puntero con malloc // Probamos: a\u00f1adimos 3 coches for ( i = 0 ; i < 3 ; i ++ ) { nuevoCoche ( & coches , & numCoches ); } // Los mostramos muestraCoches ( coches , numCoches ); // Liberamos memoria free ( coches ); } void nuevoCoche ( TCoches * coches , int * numCoches ) { int num ; * coches = ( TFichaCoche * ) realloc ( * coches , sizeof ( TFichaCoche ) * ( num + 1 )); num = * numCoches ; printf ( \"**** Coche %d **** \\n \" , num ); printf ( \"Introduce matr\u00edcula: \" ); scanf ( \"%s\" ,( * coches )[ num ]. matricula ); printf ( \"Introduce marca: \" ); scanf ( \" \\n %[^ \\n ]s\" ,( * coches )[ num ]. marca ); printf ( \"Introduce precio: \" ); scanf ( \"%f\" , & ( * coches )[ num ]. precio ); // propietario printf ( \"Nombre propietario: \" ); scanf ( \" \\n %[^ \\n ]s\" ,( * coches )[ num ]. propietario . nombre ); printf ( \"NIF propietario: \" ); scanf ( \" \\n %s\" , ( * coches )[ num ]. propietario . nif ); ( * numCoches ) ++ ; } void muestraCoches ( TCoches coches , int num ) { int i ; for ( i = 0 ; i < num ; i ++ ) { printf ( \"*********************** \\n \" ); printf ( \"Matr\u00edcula: %s \\n \" , coches [ i ]. matricula ); printf ( \"Marca: %s \\n \" , coches [ i ]. marca ); printf ( \"Precio: %f \\n \" , coches [ i ]. precio ); printf ( \"Propietario: %s con nif: %s \\n \" , coches [ i ]. propietario . nombre , coches [ i ]. propietario . nif ); printf ( \"*********************** \\n \" ); } }","title":"Ejercicio 1: Array din\u00e1mico de registros"},{"location":"Teoria/tema07-punteros-y-memoria-dinamica/tema07-punteros-y-memoria-dinamica.html#ejercicio-2-tabla-3d-definida-con-typedef","text":"Como hemos visto en temas anteriores, definir tipos propios con typedef resulta muy \u00fatil. Veamos el ejemplo de un array multidimensional de 3 dimensiones tabla3D usando typedef : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #define X 5 #define Y 7 #define Z 20 typedef int *** TTabla3D ; TTabla3D crearTabla3D (); void freeTabla3D ( TTabla3D ); void rellenarTabla3D ( TTabla3D ); int main () { TTabla3D tabla3D ; tabla3D = crearTabla3D (); if ( tabla3D ) { // Comprobamos que malloc no haya devuelto NULL rellenarTabla3D ( tabla3D ); printf ( \"%d \\n \" , tabla3D [ 2 ][ 3 ][ 1 ]); // comprobamos una posici\u00f3n al azar freeTabla3D ( tabla3D ); tabla3D = NULL ; // Si queremos poner tabla3D = NULL dentro de la funci\u00f3n // freeTabla3D, tenemos que pasar el puntero tabla3D por // referencia para poder modificarlo } } TTabla3D crearTabla3D () { TTabla3D tabla3D ; //ser\u00e1 de 5x7x20 int dim1 , dim2 , dim3 ; tabla3D = ( int *** ) malloc ( sizeof ( int ** ) * X ); for ( dim1 = 0 ; dim1 < X ; dim1 ++ ){ tabla3D [ dim1 ] = ( int ** ) malloc ( sizeof ( int * ) * Y ); for ( dim2 = 0 ; dim2 < Y ; dim2 ++ ){ tabla3D [ dim1 ][ dim2 ] = ( int * ) malloc ( sizeof ( int ) * Z ); for ( dim3 = 0 ; dim3 < Z ; dim3 ++ ){ tabla3D [ dim1 ][ dim2 ][ dim3 ] = 0 ; /*inicializaci\u00f3n*/ } } } return tabla3D ; } void freeTabla3D ( TTabla3D tabla ) { int dim1 , dim2 , dim3 ; for ( dim1 = 0 ; dim1 < X ; dim1 ++ ){ for ( dim2 = 0 ; dim2 < Y ; dim2 ++ ){ free ( tabla [ dim1 ][ dim2 ]); } free ( tabla [ dim1 ]); } free ( tabla ); } void rellenarTabla3D ( TTabla3D tabla ) { int dim1 , dim2 , dim3 ; for ( dim1 = 0 ; dim1 < X ; dim1 ++ ){ for ( dim2 = 0 ; dim2 < Y ; dim2 ++ ){ for ( dim3 = 0 ; dim3 < Z ; dim3 ++ ){ tabla [ dim1 ][ dim2 ][ dim3 ] = 100 ; } } } } La funci\u00f3n crearTabla3D tambi\u00e9n se puede hacer pasando la tabla3D por referencia para poder reservar la memoria din\u00e1micamente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void crear2Tabla3D ( TTabla3D * ); ... int main () { ... crear2Tabla3D ( & tabla3D ); ... } void crear2Tabla3D ( TTabla3D * tabla3D ) { int dim1 , dim2 , dim3 ; * tabla3D = ( int *** ) malloc ( sizeof ( int ** ) * X ); for ( dim1 = 0 ; dim1 < X ; dim1 ++ ){ ( * tabla3D )[ dim1 ] = ( int ** ) malloc ( sizeof ( int * ) * Y ); for ( dim2 = 0 ; dim2 < Y ; dim2 ++ ){ ( * tabla3D )[ dim1 ][ dim2 ] = ( int * ) malloc ( sizeof ( int ) * Z ); for ( dim3 = 0 ; dim3 < Z ; dim3 ++ ){ ( * tabla3D )[ dim1 ][ dim2 ][ dim3 ] = 0 ; /*inicializaci\u00f3n*/ } } } } Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares Puig","title":"Ejercicio 2: Tabla 3D definida con typedef"},{"location":"Teoria/tema08-entrada-salida/tema08-entrada-salida.html","text":"Tema 8: Entrada / salida \u00b6 Contenidos \u00b6 1. Introducci\u00f3n 1.1 Ficheros 1.2 Streams (flujos) de E/S 2. Manejo de ficheros 2.1 Abrir el fichero 2.2 Cerrar el fichero 2.3 Funciones de entrada y salida para ficheros 3. Par\u00e1metros a main desde l\u00ednea de comandos 1. Introducci\u00f3n \u00b6 C ofrece un conjunto de funciones para realizar operaciones de entrada y salida (E/S) con las cuales puedes leer y escribir cualquier tipo de fichero. El manejo de archivos en C se hace mediante el concepto de flujo ( streams ) o canal. Los flujos pueden estar abiertos o cerrados, y conducen los datos entre el programa y los dispositivos externos. 1.1 Ficheros \u00b6 Toda la informacio\u0301n manejada hasta ahora se pierde cuando termina la ejecucio\u0301n de un programa, tanto la introducida como la generada. Si tenemos que manejar una gran cantidad de informacio\u0301n (un nu\u0301mero elevado de variables, valores, etc.) no parece razonable definir esa informacio\u0301n en el co\u0301digo. Adema\u0301s, puede que la informacio\u0301n a tratar no la tengamos, sino que queramos procesar informacio\u0301n que nos suministran almacenada. Un fichero almacena de manera permanente la informacio\u0301n, usando la memoria permanente (disco duro) del ordenador. Para C todo en el ordenador es un fichero: teclado, impresora, cualquier otro dispositivo conectado al ordenador. 1.2 Streams (flujos) de E/S \u00b6 Un stream (flujo) es una abstracci\u00f3n que se refiere a un conjunto de datos que fluye entre un origen y un destino. Entre el origen y el destino debe existir una conexi\u00f3n o canal ( pipe ) por el que circulen los datos. Cuando se crea o abre un fichero, se crea un stream asociado al fichero, y se genera un descriptor de archivo para poder identificarlo. Adem\u00e1s, se crea un buffer (almac\u00e9n intermedio) por donde pasan los datos del archivo. Se utiliza para optimizar las lecturas y escrituras, sobre todo si se realizan de pocos datos y de forma continua. Se puede pensar en el buffer como un array donde se van almacenando los datos dirigidos al archivo o desde el archivo. El buffer se vuelca cuando de una forma u otra se da la orden de vaciarlo. Todo archivo abierto lleva asociado un puntero de posici\u00f3n que indica el lugar donde realizar\u00e1 la siguiente lectura o escritura. Cuando se crea un archivo, el puntero de la posici\u00f3n es cero (inicio). Se va actualizando conforme se lee o se escribe. Se puede indicar una nueva posici\u00f3n con la funci\u00f3n fseek . Hay dos tipos de streams : Uno es el stream de texto , consistente en l\u00edneas de texto. Una l\u00ednea es una secuencia de caracteres terminada en el car\u00e1cter de l\u00ednea nueva ('\\n' \u00f3 '\\r\\n'). El otro formato es el del stream binario , que consiste en una secuencia de bytes que representan datos internos como n\u00fameros, estructuras o arrays. Se utiliza principalmente para datos que no son de tipo texto, pueden contener cualquier informacio\u0301n. La codificacio\u0301n de estos ficheros ha de estar especificada mediante un esta\u0301ndar o con la documentacio\u0301n del programa. En el momento de abrir o crear un stream , hay que indicar de qu\u00e9 tipo de archivo se trata: Texto . Formado por l\u00edneas de caracteres, terminadas en un salto de l\u00ednea. Binario . Formado por una secuencia ordenada de caracteres, sin separadores especiales, que pueden almacenar cualquier tipo de informaci\u00f3n. No hay diferencia real entre uno y otro, salvo que en un fichero en modo texto hay fines de l\u00ednea y hay funciones de ficheros que pueden buscarlos. Si se abre en modo binario, la informaci\u00f3n puede ser de cualquier tipo y las funciones de ficheros no buscar\u00e1n fines de l\u00ednea. 2. Manejo de ficheros \u00b6 Cuando trabajamos con ficheros se suele usar el mismo esquema, tanto si escribimos como si leemos: Abrir el fichero Comprobar si el fichero esta\u0301 abierto Si esta\u0301 abierto, leer/escribir en e\u0301l hasta que se encuentra el fin de fichero Cerrar el fichero FILE* \u00b6 FILE* es la estructura que representa un archivo y se encuentra en la cabecera stdio.h . Esta estructura contiene informaci\u00f3n sobre el archivo, como la direcci\u00f3n del buffer , el modo de apertura,el \u00faltimo car\u00e1cter le\u00eddo, o el indicador de posici\u00f3n de fichero. Los campos de FILE* pueden cambiar de un compilador a otro. Ejemplo: 1 2 FILE * ptr_fich ; FILE * mostrar (); // prototipo de funci\u00f3n 2.1 Abrir el fichero \u00b6 Para trabajar con un archivo, la primera operaci\u00f3n que hay que realizar es abrirlo. La apertura conecta el archivo externo con el programa, y hay que indicarle c\u00f3mo se va a tratar: binario, de caracteres. etc. El programa accede a los archivos a trav\u00e9s de FILE* , la funci\u00f3n de apertura devuelve dicho puntero. La funci\u00f3n fopen abre o crea un fichero: Sintaxis: 1 FILE * fopen ( char * nombre , char * modo ) Los para\u0301metros que recibe fopen son: nombre : cadena de caracteres con la ruta del fichero a abrir modo : cadena de caracteres que indica co\u0301mo vamos a abrir el fichero. Lo veremos ma\u0301s adelante. La funci\u00f3n fopen devuelve un puntero de tipo FILE . Si ha ocurrido alg\u00fan error al abrirse, devuelve NULL. El par\u00e1metro modo es una combinaci\u00f3n de los caracteres r (read, lectura), w (write, escritura), b (binario), a (append, a\u00f1adir), y + (actualizar). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <stdio.h> #include <stdlib.h> int main () { FILE * f ; char name [] = \"notas.txt\" ; f = fopen ( name , \"r\" ); if ( f == NULL ) { printf ( \"Error al abrir el archivo \\n \" ); } else { // Archivo abierto con \u00e9xito } Modos de apertura de un archivo El segundo par\u00e1metro de fopen indica el modo de tratar el archivo: lectura, escritura, a\u00f1adido, texto o binario. Por defecto siempre el archivo es de texto. Se utiliza la letra b para modo binario como \u00faltimo car\u00e1cter. Algunos compiladores admiten la letra t al final para archivos de texto. \"r\" modo lectura. El flujo se posiciona al principio del fichero. \"r+\" modo lectura y escritura. El flujo se posiciona al principio del fichero \"w\" modo escritura. Si el fichero no existe, se crea. Si existe, se trunca a 0. El flujo se posiciona al principio del fichero \"w+\" modo lectura y escritura. Si el fichero no existe, se crea. Si existe, se trunca a 0. El flujo se posiciona al principio del fichero \"a\" modo escritura an\u0303adir al final. Si el fichero no existe, se crea. El flujo se posiciona al final del fichero. \"a+\" modo lectura y escritura an\u0303adir al final. Si el fichero no existe, se crea. El flujo se posiciona al final del fichero. Podemos combinar modos: \"rw\" Para abrir un archivo binario: 1 \"rb\" , \"wb\" , \"ab\" , \"r+b\" , \"w+b\" , \"a+b\" Ejemplo: Tenemos un archivo de texto de lectura \"licencia,txt\" y queremos grabar los datos procesados en un archivo binario \"resumen.dat\". Las operaciones de apertura son: 1 2 3 4 5 6 7 8 9 10 11 int main () { FILE * pf1 , * pf2 ; char org [] = \"licencia.txt\" ; char dest [] = \"resumen.dat\" ; pf1 = fopen ( org , \"r\" ); pf2 = fopen ( dest , \"wb\" ); if ( fp1 == NULL || fp2 == NULL ) { // Error } } 2.2 Cerrar un fichero \u00b6 Los archivos en C trabajan con una memoria intermedia llamada buffer . La entrada y salida de datos se almacena en ese buffer , volc\u00e1ndose cuando est\u00e1 lleno. Siempre que se termina de trabajar con un fichero y siempre que se termine la ejecuci\u00f3n de un programa, hay que cerrar los ficheros abiertos para que, entre otras cosas, se vuelque el buffer y no queden datos sin actualizar. La funci\u00f3n fclose cierra un fichero. 1 int fclose ( FILE * f ) La funcio\u0301n devuelve 0 si se cerro\u0301 con e\u0301xito Cuando se termina la ejecucio\u0301n de un programa, el sistema operativo se \"suele\" encargar de cerrar todos los ficheros abiertos Si no cerramos los ficheros abiertos podemos tener problemas. Ejemplo: 1 2 3 4 5 6 7 FILE * f1 , * f2 ; f1 = fopen ( \"datos.txt\" , \"r\" ); f2 = fopen ( \"arbol.txt\" , \"w\" ); fclose ( f1 ); fclose ( f2 ); 2.3 Funciones de entrada y salida para ficheros \u00b6 La estructura FILE contiene una posici\u00f3n (marca) de por do\u0301nde vamos leyendo en el fichero. Si leemos algo del fichero, la marca avanza hasta el siguiente cara\u0301cter/dato disponible. Si volvemos a leer del fichero, leemos a partir de la marca. Para saber si hemos llegado al final del fichero, usaremos la funcio\u0301n feof (FILE *f) (devuelve 0 si no se ha encontrado). Funciones de entrada y salida de caracteres: fgetc y fputc fputc escribe un car\u00e1cter en el archivo asociado con el puntero a FILE . Devuelve EOF si no puede escribirse. Si todo es correcto, avanza el puntero de posici\u00f3n. 1 int fputc ( int cara \u0301 cter , FILE * f ) Ejemplo: Lee caracteres desde teclado hasta introducir la 'Z', y los va grabando uno a uno en el fichero: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main () { char c ; FILE * f ; char salida [] = \"salida.txt\" ; if (( f = fopen ( salida , \"w\" )) == NULL ) printf ( \"Error en la apertura del fichero\" ); else { do { scanf ( \" \\n %c\" , & c ); fputc ( c , f ); } while ( c != 'Z' ); fclose ( f ); } } fgetc devuelve el car\u00e1cter siguiente del archivo ( stream ). Devuelve el cara\u0301cter EOF si hemos llegado al final del fichero. Sintaxis: 1 int fgetc ( FILE * f ) Ejemplo: Imprime por pantalla el contenido del fichero car\u00e1cter a car\u00e1cter y el n\u00famero de l\u00edneas que contiene: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int main () { int c , n = 0 ; FILE * f ; char salida [] = \"salida.txt\" ; if (( f = fopen ( salida , \"r\" )) == NULL ) printf ( \"Error en la apertura del fichero\" ); else { while (( c = fgetc ( f )) != EOF ){ if ( c == '\\n' ) { n ++ ; printf ( \" \\n \" ); } else printf ( \"%c\" , c ); } printf ( \"N\u00famero de l\u00edneas del archivo: %d\" , n ); fclose ( f ); } } Ejemplo con fputc y fgetc : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 int main () { FILE * f1 , * f2 ; char ch ; f1 = fopen ( \"file1.txt\" , \"r\" ); f2 = fopen ( \"file2.txt\" , \"w\" ); if ( f1 == NULL ) { printf ( \"Error al abrir file1.txt \\n \" ); } else { if ( f2 == NULL ) { printf ( \"Error al abrir file2.txt \\n \" ); fclose ( f1 ); } else { //Bucle de copia car\u00e1cter a car\u00e1cter while (( ch = fgetc ( f1 )) != EOF ) fputc ( ch , f2 ); fclose ( f1 ); fclose ( f2 ); } } } Lectura y escritura de l\u00edneas completas: fgets y fputs \u00b6 Estas funciones escriben / leen una cadena de caracteres en el archivo asociado. La funci\u00f3n fputs escribe una cadena de caracteres. Devuelve EOF si no ha podido escribir la cadena, y un valor no negativo si la escritura es correcta. 1 int fputs ( char * cadena , FILE * f ) La funci\u00f3n fgets lee una cadena de caracteres del archivo. Termina cuando lee el fin de l\u00ednea (l\u00ednea completa) o bien cuando ha le\u00eddo tam-1 caracteres, siendo tam un n\u00famero entero de la funci\u00f3n. Devuelve un puntero a la cadena devuelta o NULL si ha habido error. 1 char * fgets ( char * cadena , int tam , FILE * f ) Le indicamos con tam cua\u0301ntos caracteres leer. Si encuentra un \\n solo devuelve lo lei\u0301do hasta ese cara\u0301cter (incluido). El valor lei\u0301do se guarda en cadena y tambie\u0301n se devuelve. Si se ha producido un error (fin de fichero, por ejemplo) se devuelve NULL. Ejemplo: Lectura de un m\u00e1ximo de 80 caracteres: 1 2 3 4 5 6 7 8 9 10 #define T 81 // contamos el '\\0' int main () { char cad [ T ]; FILE * f ; // instrucciones para abrir el fichero fgets ( cad , T , f ); } Ejemplo: Copiar ficheros l\u00ednea a l\u00ednea modo texto 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #define TAM 100 int main () { FILE * f ; FILE * f2 ; char cad [ TAM ]; f = fopen ( \"ejemplo1.c\" , \"r\" ); f2 = fopen ( \"ejemplo3.c\" , \"w\" ); if ( f == NULL ) { printf ( \"Error al abrir ejemplo1.c \\n \" ); } else { if ( f2 == NULL ) { printf ( \"Error al abrir ejemplo2.c \\n \" ); fclose ( f ); } else { while ( ! feof ( f )) { if ( fgets ( cad , TAM , f ) != NULL ) fputs ( cad , f2 ); } fclose ( f ); fclose ( f2 ); } } } Lectura y escritura con formato: fscanf y fprintf La funci\u00f3n fscanf permite leer datos de un stream . Todos los formatos y opciones de scanf se pueden aplicar a fscanf . 1 fscanf ( FILE * f , char * formato ...) Ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main (){ FILE * f ; int x ; char c ; char cad [ 15 ]; f = fopen ( \"ejemplo.txt\" , \"r\" ); if ( f != NULL ) { while ( ! feof ( f )) { fscanf ( f , \"%d %c %s \\n \" , & x , & c , cad ); // aqu\u00ed continuar\u00eda el c\u00f3digo } fclose ( f ); } } Ejercicio: Crea un archivo de txt compatible con el ejemplo anterior y pru\u00e9balo. Para escribir datos con formato en un stream se usa fprintf . Todos los formatos y opciones de printf se pueden aplicar a fprintf . 1 fprintf ( FILE * f , char * formato ...) Ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main () { FILE * descriptor ; // Creamos el archivo y lo abrimos para escritura descriptor = fopen ( \"./ejemplo.txt\" , \"w\" ); if ( descriptor == NULL ) printf ( \"Error, no se puede crear el archivo\" ); else fprintf ( descriptor , \"%d\" , 1234 ); // Escribimos algo //Cerramos el archivo fclose ( descriptor ); } Ejemplo: Queremos crear el archivo \"datos.dat\" de forma que cada l\u00ednea contenga un registro con los datos de una persona: nombre, fecha nacimiento. Los campos de la estructura se escriben con fprintf en el fichero. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 typedef struct { char * nombre ; int dia ; int mes ; int anyo ; } TPersona ; void entrada ( TPersona * p ); int main () { FILE * f ; char file [] = \"datos.dat\" ; char resp = 'S' ; TPersona p ; p . nombre = NULL ; if (( f = fopen ( file , \"w\" )) == NULL ) { printf ( \"Error al abrir el archivo \\n \" ); } else { while ( toupper ( resp ) == 'S' ) { entrada ( & p ); fprintf ( f , \"%s %d-%d-%d \\n \" , p . nombre , p . dia , p . mes , p . anyo ); printf ( \"Otro registro?: \" ); scanf ( \" \\n %c\" , & resp ); } fclose ( f ); free ( p . nombre ); p . nombre = NULL ; } } void entrada ( TPersona * p ) { char cad [ 25 ]; printf ( \"Nombre: \" ); scanf ( \"%s\" , cad ); p -> nombre = ( char * ) realloc ( p -> nombre , ( strlen ( cad ) + 1 ) * sizeof ( char )); strcpy ( p -> nombre , cad ); printf ( \"Fecha nacimiento (dd mm aaaa): \" ); scanf ( \"%d %d %d\" , & p -> dia , & p -> mes , & p -> anyo ); } Funciones de entrada y salida para archivos binarios: fread y fwrite \u00b6 Para abrir un archivo en modo binario hay que especificar la opci\u00f3n b en el modo de apertura. Los archivos binarios son secuencias de 0s y 1s, bloques de datos. Optimizan la memoria ocupada por un archivo, sobre todo con campos num\u00e9ricos. Por ejemplo, para almacenar un entero, ocupa 2 bytes . Para leer un archivo binario se ha de realizar en modo binario y s\u00f3lo se pueden visualizar desde el entorno de un programa C. Modos de apertura binario: 1 \"rb\" , \"wb\" , \"ab\" , \"r+b\" , \"w+b\" , \"a+b\" Ejemplo: Abrir tres archivos en modo binario 1 2 3 4 FILE * f1 , * f2 , * f3 ; f1 = fopen ( \"file1.ene\" , \"rb\" ); // lectura binario f2 = fopen ( \"file2.feb\" , \"w+b\" ); // leer/escribir binario f3 = fopen ( \"file3.mar\" , \"ab\" ); // a\u00f1adir a archivo binario fwrite escribe un buffer de cualquier tipo de dato en un archivo binario. Permite escribir un n\u00famero num_el de elementos, de tama\u00f1o tam_el , desde una zona de memoria indicada por puntero , a un stream . 1 size_t fwrite ( void * puntero , size_t tam_el , size_t num_el , FILE * stream ) Ejemplo: Guardamos en un archivo binario un conjunto de puntos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 typedef struct { int x ; int y ; } TPunto ; int main () { TPunto p ; char * file = \"puntos.dat\" ; FILE * f ; if (( f = fopen ( file , \"wb\" )) == NULL ) { printf ( \"Error en la apertura del fichero \\n \" ); } else { do { printf ( \"Introduce las coordenadas del punto. Para acabar (0 0): \" ); scanf ( \"%d %d\" , & p . x , & p . y ); if ( p . x != 0 && p . y != 0 ) fwrite ( & p , sizeof ( TPunto ), 1 , f ); } while ( p . x != 0 && p . y != 0 ); fclose ( f ); } } La funci\u00f3n fread lee de un archivo n bloques de bytes y lo almacena en un buffer. El n\u00famero de bytes de cada bloque (tama\u00f1o) se pasa como par\u00e1metro, al igual que el n\u00famero n de bloques y la direcci\u00f3n del buffer o variable donde se almacena. La funci\u00f3n devuelve el n\u00famero de bloques que lee y debe coincidir con n. 1 size_t fread ( void * puntero , size_t tam , size_t n , FILE * f ) Ejemplo: Abrir archivo en modo binario para lectura. Leer el archivo hasta el final y cada lectura es un n\u00famero real que se acumula en la variable suma : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main () { FILE * f ; double x , suma = 0.0 ; if (( f = fopen ( \"reales.num\" , \"rb\" )) == NULL ) { printf ( \"Error al abrir el archivo \\n \" ); } else { while ( ! feof ( f )) { fread ( & x , sizeof ( double ), 1 , f ); suma += x ; } fclose ( f ); } } Ejemplos de escritura de array de enteros en archivos binarios (la lectura es igual): 1 2 3 4 5 int arr [ 3 ] = { 10 , 20 , 30 }; // Escribe el array entero: fwrite ( arr , sizeof ( arr ), 1 , fp ); //Escribe los dos primeros elementos del array: fwrite ( arr , sizeof ( int ), 2 , fp ); Ejemplos de escritura de array de structs en archivos binarios (usamos el TPunto definido previamente): 1 2 3 4 5 TPunto puntos [ 3 ] = { { 2 , 3 },{ 3 , 5 },{ 6 , 2 } }; // Escribe el array entero: fwrite ( puntos , sizeof ( puntos ), 1 , fp ); //Escribe los dos primeros elementos del array: fwrite ( puntos , sizeof ( TPunto ), 2 , fp ); Funciones de entrada y salida para tipos de datos compuestos \u00b6 Si tenemos que escribir una estructura o registro en un stream , se puede hacer de dos formas: Escribir uno a uno cada uno de los campos, utilizando funciones como printf , etc. Escribir toda la estructura a la vez usando la funci\u00f3n fwrite , indicando la direcci\u00f3n de comienzo y el tama\u00f1o del registro en bytes (obtenido con sizeof ). Lo hemos vistro previamente con el ejemplo del punto. La segunda estrategia es m\u00e1s eficiente. En el siguiente ejemplo vemos las dos formas: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #define TAMCAD 15 typedef struct { char nombre [ TAMCAD ]; char apellidos [ TAMCAD ]; int edad ; } TPersona ; int main () { TPersona alumno ; FILE * f , * f2 ; strcpy ( alumno . nombre , \"Pepe\" ); strcpy ( alumno . apellidos , \"Garcia Sanchez\" ); alumno . edad = 25 ; f = fopen ( \"alumno.dat\" , \"wb\" ); if ( f == NULL ) { printf ( \"Error al abrir fichero \\n \" ); } else { // Escribimos el registro de una sola vez fwrite ( & alumno , // direcci\u00f3n de comienzo sizeof ( alumno ), // tama\u00f1o 1 , // n\u00famero de elementos f ); // descriptor del fichero fclose ( f ); } f2 = fopen ( \"alumno.txt\" , \"w\" ); if ( f2 == NULL ) { printf ( \"Error al abrir fichero \\n \" ); } else { // Escribimos a continuaci\u00f3n el registro campo a campo fprintf ( f2 , \" \\n %s \\n \" , alumno . nombre ); fprintf ( f2 , \"%s \\n \" , alumno . apellidos ); fprintf ( f2 , \"%d\" , alumno . edad ); fclose ( f2 ); } } 3. Par\u00e1metros a main desde l\u00ednea de comandos \u00b6 Para poder pasar par\u00e1metros a un programa a trav\u00e9s de la l\u00ednea de comandos utilizamos la siguiente definici\u00f3n de la funci\u00f3n main : 1 int main ( int argc , char * argv []) El primer agumento entero argc , contiene el n\u00famero de argumentos recibidos por el programa, debemos considerar que siempre ser\u00e1 el n\u00famero de argumentos pasados m\u00e1s 1, ya que el primer agumento se reserva para contener el nombre del programa. El segundo argv es un puntero a un array de chars que contiene los par\u00e1metros pasados en el mismo orden en que fueron escritos. Supongamos que llamamos a un programa de la siguiente manera: 1 . / miprograma fichero1 . txt fichero2 . txt argc contendr\u00e1 el valor 3, debido al nombre del programa, y los dos argumentos pasados. argv[0] contendr\u00e1 el nombre del ejecutable miprograma argv[1] ser\u00e1 fichero1.txt argv[2] ser\u00e1 fichero2.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #define TAM 2048 // Ejemplo de lectura y escritura binaria, pasamos el nombre del fichero como par\u00e1metro a main int main ( int argc , char ** argv ) { FILE * fe , * fs ; char buffer [ TAM ]; int bytesLeidos ; // Abrir el fichero de entrada en lectura y binario fe = fopen ( argv [ 1 ], \"r\" ); if ( ! fe ) { printf ( \"El fichero %s no existe o no puede ser abierto. \\n \" , argv [ 1 ]); } else { // Crear o sobreescribir el fichero de salida en binario fs = fopen ( argv [ 2 ], \"wb\" ); if ( ! fs ) { printf ( \"El fichero %s no puede ser creado. \\n \" , argv [ 2 ]); fclose ( fe ); } else { // Bucle de copia: while (( bytesLeidos = fread ( buffer , 1 , TAM , fe ))) fwrite ( buffer , 1 , bytesLeidos , fs ); // Cerrar ficheros: fclose ( fe ); fclose ( fs ); } } } 4. Ejercicios propuestos \u00b6 Hacer un programa que pida palabras al usuario y que las guarde en un fichero. El programa finalizara\u0301 cuando el usuario introduzca \"fin\". Hacer un programa que pregunte el nombre de un fichero. Si existe, debera\u0301 mostrar el contenido del fichero de 25 en 25 li\u0301neas. Cuando muestre 25 li\u0301neas, esperara\u0301 hasta que el usuario pulse una tecla ( getchar ) y mostrara\u0301 las siguientes 25 li\u0301neas. Crear un programa que pida al usuario pares de n\u00fameros enteros y escriba su suma (con el formato 20 + 3 = 23 ) en pantalla y en un fichero llamado \"sumas.txt\". Cada vez que se ejecute el programa, deber\u00e1 a\u00f1adir los nuevos resultados a continuaci\u00f3n de los resultados de las ejecuciones anteriores. Soluci\u00f3n ejercicio 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #define TAMCAD 60 int main () { FILE * pf ; char fin [] = \"fin\" ; char palabra [ TAMCAD ]; pf = fopen ( \"palabras.txt\" , \"w\" ); if ( pf == NULL ) { printf ( \"Error al abrir fichero \\n \" ); } else { do { printf ( \" \\n Escriba una palabra (fin para terminar). \\n \" ); scanf ( \"%s\" , palabra ); if ( strcmp ( palabra , fin ) != 0 ) fprintf ( pf , \"%s \\n \" , palabra ); } while ( strcmp ( palabra , fin ) != 0 ); fclose ( pf ); } } Soluci\u00f3n ejercicio 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #define TAMLINEA 100 #define TAM 20 int main () { FILE * f ; char linea [ TAMLINEA ], nombre [ TAM ]; int i ; printf ( \" \\n Introduzca el nombre de fichero: \" ); scanf ( \"%s\" , nombre ); f = fopen ( nombre , \"r\" ); if ( f != NULL ) { while ( ! feof ( f )) { for ( i = 0 ; i < 25 ; i ++ ) { fgets ( linea , TAMLINEA , f ); if ( ! feof ( f )) { printf ( \"%s \\n \" , linea ); } } getchar (); } fclose ( f ); } } Soluci\u00f3n ejercicio 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 int main () { FILE * resultados ; int numero1 = 0 , numero2 = 0 , suma = 0 ; if (( resultados = fopen ( \"sumas.txt\" , \"a+\" )) == NULL ) printf ( \"No se pudo abrir el archivo. \\n \" ); else { printf ( \"Escriba dos numeros. \\n\\\" 000 \\\" para salir. \\n \" ); do { printf ( \"Primer numero: \" ); scanf ( \"%d\" , & numero1 ); if ( numero1 != 0 ) { printf ( \"Segundo numero: \" ); scanf ( \"%d\" , & numero2 ); suma = numero1 + numero2 ; printf ( \"%d + %d = %d \\n \" , numero1 , numero2 , suma ); fprintf ( resultados , \"%d + %d = %d \\n \" , numero1 , numero2 , suma ); } } while ( numero1 != 0 ); fclose ( resultados ); } } Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares Puig","title":"Tema 8: Entrada / salida"},{"location":"Teoria/tema08-entrada-salida/tema08-entrada-salida.html#tema-8-entrada-salida","text":"","title":"Tema 8: Entrada / salida"},{"location":"Teoria/tema08-entrada-salida/tema08-entrada-salida.html#contenidos","text":"1. Introducci\u00f3n 1.1 Ficheros 1.2 Streams (flujos) de E/S 2. Manejo de ficheros 2.1 Abrir el fichero 2.2 Cerrar el fichero 2.3 Funciones de entrada y salida para ficheros 3. Par\u00e1metros a main desde l\u00ednea de comandos","title":"Contenidos"},{"location":"Teoria/tema08-entrada-salida/tema08-entrada-salida.html#file","text":"FILE* es la estructura que representa un archivo y se encuentra en la cabecera stdio.h . Esta estructura contiene informaci\u00f3n sobre el archivo, como la direcci\u00f3n del buffer , el modo de apertura,el \u00faltimo car\u00e1cter le\u00eddo, o el indicador de posici\u00f3n de fichero. Los campos de FILE* pueden cambiar de un compilador a otro. Ejemplo: 1 2 FILE * ptr_fich ; FILE * mostrar (); // prototipo de funci\u00f3n","title":"FILE*"},{"location":"Teoria/tema08-entrada-salida/tema08-entrada-salida.html#lectura-y-escritura-de-lineas-completas-fgetsy-fputs","text":"Estas funciones escriben / leen una cadena de caracteres en el archivo asociado. La funci\u00f3n fputs escribe una cadena de caracteres. Devuelve EOF si no ha podido escribir la cadena, y un valor no negativo si la escritura es correcta. 1 int fputs ( char * cadena , FILE * f ) La funci\u00f3n fgets lee una cadena de caracteres del archivo. Termina cuando lee el fin de l\u00ednea (l\u00ednea completa) o bien cuando ha le\u00eddo tam-1 caracteres, siendo tam un n\u00famero entero de la funci\u00f3n. Devuelve un puntero a la cadena devuelta o NULL si ha habido error. 1 char * fgets ( char * cadena , int tam , FILE * f ) Le indicamos con tam cua\u0301ntos caracteres leer. Si encuentra un \\n solo devuelve lo lei\u0301do hasta ese cara\u0301cter (incluido). El valor lei\u0301do se guarda en cadena y tambie\u0301n se devuelve. Si se ha producido un error (fin de fichero, por ejemplo) se devuelve NULL. Ejemplo: Lectura de un m\u00e1ximo de 80 caracteres: 1 2 3 4 5 6 7 8 9 10 #define T 81 // contamos el '\\0' int main () { char cad [ T ]; FILE * f ; // instrucciones para abrir el fichero fgets ( cad , T , f ); } Ejemplo: Copiar ficheros l\u00ednea a l\u00ednea modo texto 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #define TAM 100 int main () { FILE * f ; FILE * f2 ; char cad [ TAM ]; f = fopen ( \"ejemplo1.c\" , \"r\" ); f2 = fopen ( \"ejemplo3.c\" , \"w\" ); if ( f == NULL ) { printf ( \"Error al abrir ejemplo1.c \\n \" ); } else { if ( f2 == NULL ) { printf ( \"Error al abrir ejemplo2.c \\n \" ); fclose ( f ); } else { while ( ! feof ( f )) { if ( fgets ( cad , TAM , f ) != NULL ) fputs ( cad , f2 ); } fclose ( f ); fclose ( f2 ); } } }","title":"Lectura y escritura de l\u00edneas completas: fgetsy fputs"},{"location":"Teoria/tema08-entrada-salida/tema08-entrada-salida.html#funciones-de-entrada-y-salida-para-archivos-binarios-fready-fwrite","text":"Para abrir un archivo en modo binario hay que especificar la opci\u00f3n b en el modo de apertura. Los archivos binarios son secuencias de 0s y 1s, bloques de datos. Optimizan la memoria ocupada por un archivo, sobre todo con campos num\u00e9ricos. Por ejemplo, para almacenar un entero, ocupa 2 bytes . Para leer un archivo binario se ha de realizar en modo binario y s\u00f3lo se pueden visualizar desde el entorno de un programa C. Modos de apertura binario: 1 \"rb\" , \"wb\" , \"ab\" , \"r+b\" , \"w+b\" , \"a+b\" Ejemplo: Abrir tres archivos en modo binario 1 2 3 4 FILE * f1 , * f2 , * f3 ; f1 = fopen ( \"file1.ene\" , \"rb\" ); // lectura binario f2 = fopen ( \"file2.feb\" , \"w+b\" ); // leer/escribir binario f3 = fopen ( \"file3.mar\" , \"ab\" ); // a\u00f1adir a archivo binario fwrite escribe un buffer de cualquier tipo de dato en un archivo binario. Permite escribir un n\u00famero num_el de elementos, de tama\u00f1o tam_el , desde una zona de memoria indicada por puntero , a un stream . 1 size_t fwrite ( void * puntero , size_t tam_el , size_t num_el , FILE * stream ) Ejemplo: Guardamos en un archivo binario un conjunto de puntos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 typedef struct { int x ; int y ; } TPunto ; int main () { TPunto p ; char * file = \"puntos.dat\" ; FILE * f ; if (( f = fopen ( file , \"wb\" )) == NULL ) { printf ( \"Error en la apertura del fichero \\n \" ); } else { do { printf ( \"Introduce las coordenadas del punto. Para acabar (0 0): \" ); scanf ( \"%d %d\" , & p . x , & p . y ); if ( p . x != 0 && p . y != 0 ) fwrite ( & p , sizeof ( TPunto ), 1 , f ); } while ( p . x != 0 && p . y != 0 ); fclose ( f ); } } La funci\u00f3n fread lee de un archivo n bloques de bytes y lo almacena en un buffer. El n\u00famero de bytes de cada bloque (tama\u00f1o) se pasa como par\u00e1metro, al igual que el n\u00famero n de bloques y la direcci\u00f3n del buffer o variable donde se almacena. La funci\u00f3n devuelve el n\u00famero de bloques que lee y debe coincidir con n. 1 size_t fread ( void * puntero , size_t tam , size_t n , FILE * f ) Ejemplo: Abrir archivo en modo binario para lectura. Leer el archivo hasta el final y cada lectura es un n\u00famero real que se acumula en la variable suma : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main () { FILE * f ; double x , suma = 0.0 ; if (( f = fopen ( \"reales.num\" , \"rb\" )) == NULL ) { printf ( \"Error al abrir el archivo \\n \" ); } else { while ( ! feof ( f )) { fread ( & x , sizeof ( double ), 1 , f ); suma += x ; } fclose ( f ); } } Ejemplos de escritura de array de enteros en archivos binarios (la lectura es igual): 1 2 3 4 5 int arr [ 3 ] = { 10 , 20 , 30 }; // Escribe el array entero: fwrite ( arr , sizeof ( arr ), 1 , fp ); //Escribe los dos primeros elementos del array: fwrite ( arr , sizeof ( int ), 2 , fp ); Ejemplos de escritura de array de structs en archivos binarios (usamos el TPunto definido previamente): 1 2 3 4 5 TPunto puntos [ 3 ] = { { 2 , 3 },{ 3 , 5 },{ 6 , 2 } }; // Escribe el array entero: fwrite ( puntos , sizeof ( puntos ), 1 , fp ); //Escribe los dos primeros elementos del array: fwrite ( puntos , sizeof ( TPunto ), 2 , fp );","title":"Funciones de entrada y salida para archivos binarios: fready fwrite"},{"location":"Teoria/tema08-entrada-salida/tema08-entrada-salida.html#funciones-de-entrada-y-salida-para-tipos-de-datos-compuestos","text":"Si tenemos que escribir una estructura o registro en un stream , se puede hacer de dos formas: Escribir uno a uno cada uno de los campos, utilizando funciones como printf , etc. Escribir toda la estructura a la vez usando la funci\u00f3n fwrite , indicando la direcci\u00f3n de comienzo y el tama\u00f1o del registro en bytes (obtenido con sizeof ). Lo hemos vistro previamente con el ejemplo del punto. La segunda estrategia es m\u00e1s eficiente. En el siguiente ejemplo vemos las dos formas: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #define TAMCAD 15 typedef struct { char nombre [ TAMCAD ]; char apellidos [ TAMCAD ]; int edad ; } TPersona ; int main () { TPersona alumno ; FILE * f , * f2 ; strcpy ( alumno . nombre , \"Pepe\" ); strcpy ( alumno . apellidos , \"Garcia Sanchez\" ); alumno . edad = 25 ; f = fopen ( \"alumno.dat\" , \"wb\" ); if ( f == NULL ) { printf ( \"Error al abrir fichero \\n \" ); } else { // Escribimos el registro de una sola vez fwrite ( & alumno , // direcci\u00f3n de comienzo sizeof ( alumno ), // tama\u00f1o 1 , // n\u00famero de elementos f ); // descriptor del fichero fclose ( f ); } f2 = fopen ( \"alumno.txt\" , \"w\" ); if ( f2 == NULL ) { printf ( \"Error al abrir fichero \\n \" ); } else { // Escribimos a continuaci\u00f3n el registro campo a campo fprintf ( f2 , \" \\n %s \\n \" , alumno . nombre ); fprintf ( f2 , \"%s \\n \" , alumno . apellidos ); fprintf ( f2 , \"%d\" , alumno . edad ); fclose ( f2 ); } }","title":"Funciones de entrada y salida para tipos de datos compuestos"},{"location":"Teoria/tema09-recursion/tema09-recursio\u0301n.html","text":"Tema 9: Recursi\u00f3n \u00b6 Contenidos \u00b6 1. Qu\u00e9 es la recursividad 2. C\u00f3mo dise\u00f1ar una funci\u00f3n recursiva 3. La pila de llamadas y el proceso de la recursi\u00f3n 4. Recursi\u00f3n mutua 5. Ventajas y desventajas de la recursi\u00f3n 6. Ejemplos 1. Qu\u00e9 es la recursividad \u00b6 Una funci\u00f3n es recursiva si en su definici\u00f3n hay una llamada a s\u00ed misma. La recursi\u00f3n o recursividad es una forma diferente de realizar las acciones repetitivas, permitiendo que un subprograma se llame a s\u00ed mismo para resolver una versi\u00f3n m\u00e1s peque\u00f1a del problema original. Se puede utilizar la recursividad como una alternativa a la iteraci\u00f3n. Una soluci\u00f3n recursiva es normalmente menos eficiente que una soluci\u00f3n iterativa, pero en numerosos casos el uso de la recursi\u00f3n permite a los programadores especificar soluciones naturales, sencillas que ser\u00edan, en caso contrario, muy dif\u00edciles de resolver. Por este motivo, la recursi\u00f3n es una herramienta muy importante y poderosa en la resoluci\u00f3n de problemas y en la programaci\u00f3n. Una vez que uno se acostumbra a su uso, se comprueba que la recursi\u00f3n es una forma mucho m\u00e1s natural que la iteraci\u00f3n de expresar un gran n\u00famero de funciones. El primer lenguaje de programaci\u00f3n que permiti\u00f3 el uso de expresiones recursivas fue Lisp. En el momento de su creaci\u00f3n exist\u00eda ya Fortran, que no permit\u00eda que una funci\u00f3n se llamase a si misma. Hay muchas funciones matema\u0301ticas que se definen de forma natural de manera recursiva. Por ejemplo: Factorial de un nu\u0301mero n: factorial(n) = n * factorial(n-1) Potencia de dos nu\u0301meros: x^n = x * x^n-1 2. C\u00f3mo dise\u00f1ar una funci\u00f3n recursiva \u00b6 Esquema b\u00e1sico de una funci\u00f3n recursiva Caso general o recursivo : Incluye una o ma\u0301s llamadas recursivas. Estas llamadas recursivas deben resolver versiones \"ma\u0301s pequen\u0303as\" del problema que tiene que resolver la funci\u00f3n. Caso base : Es el problema m\u00e1s peque\u00f1o que podemos encontrar y del cual sabemos su soluci\u00f3n inmediata (sin necesidad de hacer una llamada recursiva). Pensando recursivamente Para dise\u00f1ar funciones recursivas no funciona el m\u00e9todo de prueba y error. Hay que dise\u00f1ar la soluci\u00f3n recursiva desde el principio. Debemos fijarnos en lo que devuelve la funci\u00f3n y debemos preguntarnos c\u00f3mo ser\u00eda posible descomponer el problema de forma que podamos lanzar la recursi\u00f3n sobre una versi\u00f3n m\u00e1s sencilla del mismo. Supondremos que la llamada recursiva funciona correctamente y devuelve el resultado correcto. Y despu\u00e9s debemos transformar este resultado correcto de la versi\u00f3n m\u00e1s peque\u00f1a en el resultado de la soluci\u00f3n completa. Debes confiar en que la llamada recursiva va a hacer su trabajo y devolver el resultado correcto. Despu\u00e9s tendr\u00e1s que utilizar lo que la llamada recursiva ha devuelto para componer la soluci\u00f3n definitiva al problema. El caso base debe ser el caso m\u00e1s sencillo del problema a resolver. Aquel cuyo resultado conocemos de forma inmediata y no depende de otros resultados. Por ejemplo, el problema del factorial. Debemos empezar pensando en distintos casos: 1 2 factorial ( 5 ) = 5 * 4 * 3 * 2 * 1 factorial ( 4 ) = 4 * 3 * 2 * 1 Si nos fijamos en estos ejemplos, vemos que el factorial(4) forma parte de la soluci\u00f3n de factorial(5) , de forma que se puede plantear como una llamada a s\u00ed misma pero con un problema m\u00e1s peque\u00f1o: 1 factorial ( 5 ) = 5 * factorial ( 4 ) Ya tenemos el caso general o caso recursivo. Necesitamos un caso base , porque si no es as\u00ed, se llamar\u00eda indefinidamente a s\u00ed mismo. El caso base es el caso m\u00e1s peque\u00f1o que podemos encontrar, que no depende de ninguna llamada recursiva y que conocemos su soluci\u00f3n de forma inmediata. En el caso del factorial, se trata de: 1 factorial ( 1 ) = 1 Ahora tenemos que reformularlo de forma general: 1 2 factorial ( n ) = n * factorial ( n - 1 ) factorial ( 1 ) = 1 Una vez ya tenemos la soluci\u00f3n, s\u00f3lo falta implementarlo en C: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int factorial ( int n ) { int res ; if ( n == 1 ) // caso base res = 1 ; else res = n * factorial ( n - 1 ); return res ; } int main () { int num ; printf ( \"Introduce un nu\u0301mero: \" ); scanf ( \"%d\" , & num ); printf ( \"El factorial de %d es %d \\n \" , num , factorial ( num )); } Como ves, no hemos empezado a programar directamente. Hemos planteado ejemplos, a continuaci\u00f3n los hemos expresado de forma recursiva y por \u00faltimo hemos expresado la soluci\u00f3n general. El \u00faltimo paso es traducirlo a C. Sumatorio Vamos a resolver el sumatorio desde 0 hasta un n\u00famero n. Casos de ejemplo: 1 2 sumatorio ( 5 ) = 5 + 4 + 3 + 2 + 1 + 0 sumatorio ( 4 ) = 4 + 3 + 2 + 1 + 0 Ya podemos deducir cu\u00e1l es el caso general: 1 sumatorio ( n ) = n + sumatorio ( n - 1 ) \u00bfCu\u00e1l es el caso base? 1 sumatorio ( 0 ) = 0 Ahora lo codificamos en C: 1 2 3 4 5 6 7 8 9 10 11 int sumatorio ( int n ) { int res ; if ( n == 0 ) // caso base res = 0 ; else res = n + sumatorio ( n - 1 ); return res ; } Potencia Vamos a resolver la potencia de un num\u00e9ro elevado a otro. Casos de ejemplo: 1 2 potencia ( 2 , 5 ) = 2 * 2 * 2 * 2 * 2 potencia ( 2 , 4 ) = 2 * potencia ( 2 , 3 ) Caso base: 1 2 potencia ( 2 , 0 ) = 1 potencia ( 5 , 0 = 1 Formulaci\u00f3n recursiva: 1 2 potencia ( n , m ) = n * potencia ( n , m - 1 ) potencia ( _ , 0 ) = 1 Lo pasamos a C: 1 2 3 4 5 6 7 8 9 10 11 12 int potencia ( int num , int pow ) { int res ; if ( pow ){ res = ( num * potencia ( num , pow - 1 )); } else res = 1 ; return res ; } Fibonacci La secuencia de Fibonacci es 0,1,1,2,3,5,8,13,... Formulaci\u00f3n matem\u00e1tica de la secuencia de Fibonacci: 1 2 3 Fibonacci ( n ) = Fibonacci ( n - 1 ) + Fibonacci ( n - 2 ) Fibonacci ( 0 ) = 0 Fibonacci ( 1 ) = 1 Lo pasadmos a C: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int fib ( int n ) { int res ; if ( n == 0 ) res = 0 ; else if ( n == 1 ) res = 1 ; else res = fib ( n - 1 ) + fib ( n - 2 ); return res ; } int main () { int n ; printf ( \"Introduce n\u00famero: \" ); scanf ( \"%d\" , & n ); printf ( \"El n\u00famero %d de fibonacci es %d \\n \" , n , fib ( n )); return 0 ; } Fibonacci es un ejemplo especial en el que el caso general est\u00e1 compuesto por la suma de dos llamadas recursivas. Conversi\u00f3n n\u00famero decimal a binario 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void binario ( int n ) { if ( n != 0 ) { binario ( n / 2 ); printf ( \"%i\" , n % 2 ); } } int main () { int dec , bin ; printf ( \"Introduce n\u00famero decimal: \" ); scanf ( \"%d\" , & dec ); binario ( dec ); return 0 ; } 3. La pila de llamadas y el proceso de la recursi\u00f3n \u00b6 La pila de llamadas \u00b6 La pila de llamadas o call stack es una estructura din\u00e1mica de datos LIFO ( last in first out ) que almacena la informaci\u00f3n sobre las funciones o subrutinas activas de un programa. Esto hace que sea m\u00e1s sencillo mantener el control de los bloques que deben ser liberados, puesto que ser\u00e1 aquel que est\u00e9 en el tope de la pila. Su objetivo es seguir el curso del punto al cual cada funci\u00f3n activa debe retornar el control cuando termine su ejecuci\u00f3n, es decir, aquellas funciones que se han llamado pero todav\u00eda no han completado su ejecuci\u00f3n ni retornando al lugar siguiente desde donde han sido llamadas. Algunos de los datos que suelen almacenar son: la direcci\u00f3n de retorno variables locales valores de los par\u00e1metros Ejemplo: Supongamos que main ha llamado a funcion1 y \u00e9sta a funcion2 : El proceso de la recursi\u00f3n \u00b6 Qu\u00e9 ocurre cuando se invoca a una funci\u00f3n: Cuando se llama a una funci\u00f3n, se crea un \u00e1mbito nuevo (tambi\u00e9n llamado marco o frame ) local a la funci\u00f3n, donde se asigna memoria a las variables locales de la funci\u00f3n, y al finalizar su ejecuci\u00f3n, se libera la memoria asignada y se devuelve la ejecuci\u00f3n al punto en que se hizo la llamada haciendo uso de lo que se llama direcci\u00f3n de retorno . Cuando la funci\u00f3n que se invoca es recursiva: En el caso recursivo, cada llamada genera un nuevo \u00e1mbito de la funci\u00f3n con sus correspondientes variables locales: la funci\u00f3n se ejecutar\u00e1 normalmente hasta la llamada a s\u00ed misma. Se almacenan en la pila de llamadas los par\u00e1metros y variables locales, y se van creando m\u00e1s copias hasta llegar al caso base, donde se resuelve directamente el valor, y se va saliendo liberando memoria hasta llegar a la primera llamada (\u00faltima en cerrarse). Vistos estos conceptos, ya podemos trazar la ejecuci\u00f3n del factorial para el caso de num = 4. 1 2 3 4 5 6 7 8 9 10 11 int factorial ( int n ) { int res ; if ( n == 1 ) // caso base res = 1 ; else res = n * factorial ( n - 1 ); > return res ; } La llamada a factorial(4) realiza la siguiente secuencia de operaciones (traza): 1 2 3 4 5 6 7 8 factorial ( 4 ) => 4 * factorial ( 3 ) => 4 * 3 * factorial ( 2 ) => 4 * 3 * 2 * factorial ( 1 ) => 4 * 3 * 2 * 1 => 4 * 3 * 2 => 4 * 6 => 24 Cada llamada a la recursi\u00f3n deja una funci\u00f3n en espera de ser evaluada cuando la recursi\u00f3n devuelva un valor (en el caso anterior las llamadas a factorial ). Estas llamadas en espera, junto con sus argumentos, se almacenan en la pila de llamadas . Cuando la recursi\u00f3n devuelve un valor, los valores se recuperan de la pila , se realiza la llamada y se devuelve el valor a la anterior llamada en espera. Si la recursi\u00f3n est\u00e1 mal hecha y nunca termina se genera un stack overflow porque la memoria que se almacena en la pila sobrepasa la memoria reservada. Ejercicio: Haz las trazas de las funciones recursivas potencia y sumatorio . \u00bfCu\u00e1l ser\u00e1 el proceso que genera una llamada a Fibonacci? El caso de Fibonacci es distinto, porque en cada funci\u00f3n se realizan dos llamadas recursivas, de forma que la pila crece exponencialmente. 4. Recursi\u00f3n mutua \u00b6 Este tipo de recursi\u00f3n se produce cuando una funci\u00f3n llama a otra y \u00e9ste a su vez a la primera. Por ejemplo, el siguiente programa muestra por pantalla el alfabeto utilizando recursi\u00f3n mutua: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void funcionA ( char ); void funcionB ( char ); int main (){ funcionA ( 'Z' ); printf ( \" \\n \" ); } void funcionA ( char c ) { if ( c > 'A' ) funcionB ( c ); printf ( \"%c\" , c ); } void funcionB ( char c ) { c -- ; funcionA ( c ); } El programa principal llama a la funci\u00f3n recursiva funcionA con el argumento 'Z', que a su vez llama a funcionB que decrementa el car\u00e1cter (obtiene el car\u00e1cter anterior) y llama nuevamente a funcionA . Este proceso se repite hasta que c sea el car\u00e1cter 'A' (caso base). En ese momento, la recursi\u00f3n termina y se ejecutan los 26 printf que se hab\u00edan quedado en espera en la pila de llamadas y visualizando el alfabeto car\u00e1cter a car\u00e1cter de la A a la Z. 5. Ventajas y desventajas de la recursi\u00f3n \u00b6 Ventajas Soluciones simples, claras. Soluciones elegantes. Soluciones sencillas a problemas complejos. Desventajas Ineficiencia en algunos problemas Sobrecarga asociada con las llamadas recursivas: una simple llamada puede generar un gran numero de llamadas El valor de la recursividad reside en el hecho de que se puede usar para resolver problemas cuya soluci\u00f3n iterativa no es f\u00e1cil de obtener, y sin embargo resueltos de forma recursiva resultan muy concisos y claros. Ejercicios resueltos \u00b6 Dado un array de enteros, escribe un programa que calcule el menor n\u00famero de un array de enteros utilizando una funci\u00f3n recursiva. Formulaci\u00f3n recursiva: el n\u00famero menor de un array es el menor entre el elemento actual y el menor del resto de los elementos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 int Menor ( int [], int , int ); int Min ( int , int ); int main () { int a [] = { 4 , 2 , 8 , 45 , 9 }; int res ; res = Menor ( a , 0 , 5 ); printf ( \"%d \\n \" , res ); } int Min ( int a , int b ) { int res ; if ( a < b ) res = a ; else res = b ; return res ; } int Menor ( int s [], int ini , int fin ) { int menor , res ; if ( ini == fin ) { res = s [ ini ]; } else { menor = Menor ( s , ini + 1 , fin ); res = Min ( s [ ini ], menor ); } return res ; } Escribe una funci\u00f3n recursiva que reciba como par\u00e1metros un array de enteros y su tama\u00f1o, y devuelva la suma de todos sus elementos. 1 2 3 4 5 6 7 8 9 10 int sumaVector ( int array [], int n ){ int res = 0 ; if ( n == 0 ){ res = array [ 0 ]; } else { res = array [ n ] + sumaVector ( array , n - 1 ); } return res ; } Escribe una funci\u00f3n recursiva llamada mayoresQue(int array[], int elem, int longitud) que reciba un array, un n\u00famero y el tama\u00f1o del array, y devuelva la cantidad de elementos del array que son mayores que el n\u00famero que le pasamos como par\u00e1metro. 1 2 3 4 5 6 7 8 9 10 11 12 int mayoresQue ( int array [], int elem , int n ){ int res = 0 ; if ( n == 0 ) res = 0 ; else if ( array [ n ] > elem ) res = 1 + mayoresQue ( array , elem , n - 1 ); else res = mayoresQue ( array , elem , n - 1 ); return res ; } Ejercicios propuestos \u00b6 Define una funci\u00f3n recursiva que para un nu\u0301mero natural n muestre por pantalla la serie creciente de nu\u0301meros naturales del 1 al n, es decir, 1 2 3... n. Define una funci\u00f3n recursiva que para un nu\u0301mero natural n devuelva la suma de los cuadrados de los nu\u0301meros del 1 hasta el n. Por ejemplo, para n=4, debe devolver 30 ya que 1^2+ 2^2 + 3^2 + 4^2 = 30. Define una funci\u00f3n recursiva que, dado un nu\u0301mero natural, muestre por pantalla el nu\u0301mero formado por los mismos di\u0301gitos en sentido contrario. Por ejemplo: para el nu\u0301mero 2089 debe mostrar 9802. Define una funcio\u0301n recursiva que devuelva el nu\u0301mero de di\u0301gitos impares de un nu\u0301mero. Ejemplo: rec(321)=2, rec(28)=0. Comprobar si un n\u00famero es par o impar, utilizando recursi\u00f3n mutua. Define una funci\u00f3n recursiva que obtenga el valor m\u00e1ximo de un array de enteros. Pista: puedes definir y utilizar la funci\u00f3n max(int, int) que devuelve el m\u00e1ximo entre dos n\u00fameros enteros. El caso base es cuando el array s\u00f3lo tiene un elemento. El caso general se puede plantear como el m\u00e1ximo entre el primer elemento y el m\u00e1ximo del resto de elementos. Curiosidad: Algoritmos recursivos de vuelta a atr\u00e1s ( backtracking ) \u00b6 Se trata de una estrategia recursiva para resolver problemas como los de los laberintos, el sudoku, algunos problemas de ajedrez como el recorrido del caballo o las ocho damas y similares, en los que mediante una b\u00fasqueda en profundidad se puede dar con la soluci\u00f3n. El nombre vuelta atr\u00e1s ( backtracking ) viene del hecho de que en la b\u00fasqueda de la soluci\u00f3n se va volviendo a un punto anterior para probar alternativas. Si est\u00e1is interesados en el tema, pod\u00e9is hacer un ejercicio. Se trata de que, dado un mapa con obst\u00e1culos y una posici\u00f3n inicial de un robot y una posici\u00f3n objetivo, el robot sea capaz de encontrar el objetivo. Pod\u00e9is utilizar las estructuras de datos similares a las de la pr\u00e1ctica y leer el mapa con los obst\u00e1culos desde l\u00ednea de comandos. El camino lo resolver\u00e1 el algoritmo recursivo. Pod\u00e9is encontrar mucha informaci\u00f3n al respecto en internet, como por ejemplo en el siguiente enlace . En este video de youtube pod\u00e9is ver c\u00f3mo funciona el salvapantallas xscreensaver en el modo de resoluci\u00f3n de laberintos, se ve muy claro el avance, decisi\u00f3n y retroceso. Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares Puig","title":"Tema 9: Recursi\u00f3n"},{"location":"Teoria/tema09-recursion/tema09-recursio\u0301n.html#tema-9-recursion","text":"","title":"Tema 9: Recursi\u00f3n"},{"location":"Teoria/tema09-recursion/tema09-recursio\u0301n.html#contenidos","text":"1. Qu\u00e9 es la recursividad 2. C\u00f3mo dise\u00f1ar una funci\u00f3n recursiva 3. La pila de llamadas y el proceso de la recursi\u00f3n 4. Recursi\u00f3n mutua 5. Ventajas y desventajas de la recursi\u00f3n 6. Ejemplos","title":"Contenidos"},{"location":"Teoria/tema09-recursion/tema09-recursio\u0301n.html#la-pila-de-llamadas","text":"La pila de llamadas o call stack es una estructura din\u00e1mica de datos LIFO ( last in first out ) que almacena la informaci\u00f3n sobre las funciones o subrutinas activas de un programa. Esto hace que sea m\u00e1s sencillo mantener el control de los bloques que deben ser liberados, puesto que ser\u00e1 aquel que est\u00e9 en el tope de la pila. Su objetivo es seguir el curso del punto al cual cada funci\u00f3n activa debe retornar el control cuando termine su ejecuci\u00f3n, es decir, aquellas funciones que se han llamado pero todav\u00eda no han completado su ejecuci\u00f3n ni retornando al lugar siguiente desde donde han sido llamadas. Algunos de los datos que suelen almacenar son: la direcci\u00f3n de retorno variables locales valores de los par\u00e1metros Ejemplo: Supongamos que main ha llamado a funcion1 y \u00e9sta a funcion2 :","title":"La pila de llamadas"},{"location":"Teoria/tema09-recursion/tema09-recursio\u0301n.html#el-proceso-de-la-recursion","text":"Qu\u00e9 ocurre cuando se invoca a una funci\u00f3n: Cuando se llama a una funci\u00f3n, se crea un \u00e1mbito nuevo (tambi\u00e9n llamado marco o frame ) local a la funci\u00f3n, donde se asigna memoria a las variables locales de la funci\u00f3n, y al finalizar su ejecuci\u00f3n, se libera la memoria asignada y se devuelve la ejecuci\u00f3n al punto en que se hizo la llamada haciendo uso de lo que se llama direcci\u00f3n de retorno . Cuando la funci\u00f3n que se invoca es recursiva: En el caso recursivo, cada llamada genera un nuevo \u00e1mbito de la funci\u00f3n con sus correspondientes variables locales: la funci\u00f3n se ejecutar\u00e1 normalmente hasta la llamada a s\u00ed misma. Se almacenan en la pila de llamadas los par\u00e1metros y variables locales, y se van creando m\u00e1s copias hasta llegar al caso base, donde se resuelve directamente el valor, y se va saliendo liberando memoria hasta llegar a la primera llamada (\u00faltima en cerrarse). Vistos estos conceptos, ya podemos trazar la ejecuci\u00f3n del factorial para el caso de num = 4. 1 2 3 4 5 6 7 8 9 10 11 int factorial ( int n ) { int res ; if ( n == 1 ) // caso base res = 1 ; else res = n * factorial ( n - 1 ); > return res ; } La llamada a factorial(4) realiza la siguiente secuencia de operaciones (traza): 1 2 3 4 5 6 7 8 factorial ( 4 ) => 4 * factorial ( 3 ) => 4 * 3 * factorial ( 2 ) => 4 * 3 * 2 * factorial ( 1 ) => 4 * 3 * 2 * 1 => 4 * 3 * 2 => 4 * 6 => 24 Cada llamada a la recursi\u00f3n deja una funci\u00f3n en espera de ser evaluada cuando la recursi\u00f3n devuelva un valor (en el caso anterior las llamadas a factorial ). Estas llamadas en espera, junto con sus argumentos, se almacenan en la pila de llamadas . Cuando la recursi\u00f3n devuelve un valor, los valores se recuperan de la pila , se realiza la llamada y se devuelve el valor a la anterior llamada en espera. Si la recursi\u00f3n est\u00e1 mal hecha y nunca termina se genera un stack overflow porque la memoria que se almacena en la pila sobrepasa la memoria reservada. Ejercicio: Haz las trazas de las funciones recursivas potencia y sumatorio . \u00bfCu\u00e1l ser\u00e1 el proceso que genera una llamada a Fibonacci? El caso de Fibonacci es distinto, porque en cada funci\u00f3n se realizan dos llamadas recursivas, de forma que la pila crece exponencialmente.","title":"El proceso de la recursi\u00f3n"},{"location":"Teoria/tema09-recursion/tema09-recursio\u0301n.html#ejercicios-resueltos","text":"Dado un array de enteros, escribe un programa que calcule el menor n\u00famero de un array de enteros utilizando una funci\u00f3n recursiva. Formulaci\u00f3n recursiva: el n\u00famero menor de un array es el menor entre el elemento actual y el menor del resto de los elementos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 int Menor ( int [], int , int ); int Min ( int , int ); int main () { int a [] = { 4 , 2 , 8 , 45 , 9 }; int res ; res = Menor ( a , 0 , 5 ); printf ( \"%d \\n \" , res ); } int Min ( int a , int b ) { int res ; if ( a < b ) res = a ; else res = b ; return res ; } int Menor ( int s [], int ini , int fin ) { int menor , res ; if ( ini == fin ) { res = s [ ini ]; } else { menor = Menor ( s , ini + 1 , fin ); res = Min ( s [ ini ], menor ); } return res ; } Escribe una funci\u00f3n recursiva que reciba como par\u00e1metros un array de enteros y su tama\u00f1o, y devuelva la suma de todos sus elementos. 1 2 3 4 5 6 7 8 9 10 int sumaVector ( int array [], int n ){ int res = 0 ; if ( n == 0 ){ res = array [ 0 ]; } else { res = array [ n ] + sumaVector ( array , n - 1 ); } return res ; } Escribe una funci\u00f3n recursiva llamada mayoresQue(int array[], int elem, int longitud) que reciba un array, un n\u00famero y el tama\u00f1o del array, y devuelva la cantidad de elementos del array que son mayores que el n\u00famero que le pasamos como par\u00e1metro. 1 2 3 4 5 6 7 8 9 10 11 12 int mayoresQue ( int array [], int elem , int n ){ int res = 0 ; if ( n == 0 ) res = 0 ; else if ( array [ n ] > elem ) res = 1 + mayoresQue ( array , elem , n - 1 ); else res = mayoresQue ( array , elem , n - 1 ); return res ; }","title":"Ejercicios resueltos"},{"location":"Teoria/tema09-recursion/tema09-recursio\u0301n.html#ejercicios-propuestos","text":"Define una funci\u00f3n recursiva que para un nu\u0301mero natural n muestre por pantalla la serie creciente de nu\u0301meros naturales del 1 al n, es decir, 1 2 3... n. Define una funci\u00f3n recursiva que para un nu\u0301mero natural n devuelva la suma de los cuadrados de los nu\u0301meros del 1 hasta el n. Por ejemplo, para n=4, debe devolver 30 ya que 1^2+ 2^2 + 3^2 + 4^2 = 30. Define una funci\u00f3n recursiva que, dado un nu\u0301mero natural, muestre por pantalla el nu\u0301mero formado por los mismos di\u0301gitos en sentido contrario. Por ejemplo: para el nu\u0301mero 2089 debe mostrar 9802. Define una funcio\u0301n recursiva que devuelva el nu\u0301mero de di\u0301gitos impares de un nu\u0301mero. Ejemplo: rec(321)=2, rec(28)=0. Comprobar si un n\u00famero es par o impar, utilizando recursi\u00f3n mutua. Define una funci\u00f3n recursiva que obtenga el valor m\u00e1ximo de un array de enteros. Pista: puedes definir y utilizar la funci\u00f3n max(int, int) que devuelve el m\u00e1ximo entre dos n\u00fameros enteros. El caso base es cuando el array s\u00f3lo tiene un elemento. El caso general se puede plantear como el m\u00e1ximo entre el primer elemento y el m\u00e1ximo del resto de elementos.","title":"Ejercicios propuestos"},{"location":"Teoria/tema09-recursion/tema09-recursio\u0301n.html#curiosidad-algoritmos-recursivos-de-vuelta-a-atras-backtracking","text":"Se trata de una estrategia recursiva para resolver problemas como los de los laberintos, el sudoku, algunos problemas de ajedrez como el recorrido del caballo o las ocho damas y similares, en los que mediante una b\u00fasqueda en profundidad se puede dar con la soluci\u00f3n. El nombre vuelta atr\u00e1s ( backtracking ) viene del hecho de que en la b\u00fasqueda de la soluci\u00f3n se va volviendo a un punto anterior para probar alternativas. Si est\u00e1is interesados en el tema, pod\u00e9is hacer un ejercicio. Se trata de que, dado un mapa con obst\u00e1culos y una posici\u00f3n inicial de un robot y una posici\u00f3n objetivo, el robot sea capaz de encontrar el objetivo. Pod\u00e9is utilizar las estructuras de datos similares a las de la pr\u00e1ctica y leer el mapa con los obst\u00e1culos desde l\u00ednea de comandos. El camino lo resolver\u00e1 el algoritmo recursivo. Pod\u00e9is encontrar mucha informaci\u00f3n al respecto en internet, como por ejemplo en el siguiente enlace . En este video de youtube pod\u00e9is ver c\u00f3mo funciona el salvapantallas xscreensaver en el modo de resoluci\u00f3n de laberintos, se ve muy claro el avance, decisi\u00f3n y retroceso. Programaci\u00f3n 1, Grado de Rob\u00f3tica, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Cristina Pomares Puig","title":"Curiosidad: Algoritmos recursivos de vuelta a atr\u00e1s (backtracking)"}]}